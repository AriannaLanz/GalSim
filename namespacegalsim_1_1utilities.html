<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">galsim.utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_attribute_dict.html">AttributeDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary class that allows for easy initialization and refs to key values via attributes.  <a href="classgalsim_1_1utilities_1_1_attribute_dict.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_comparison_shape_data.html">ComparisonShapeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to contain the outputs of a comparison between photon shooting and DFT rendering of GSObjects, as measured by the HSM module's FindAdaptiveMom or (in future) EstimateShear.  <a href="classgalsim_1_1utilities_1_1_comparison_shape_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1utilities_1_1_simple_generator.html">SimpleGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that is constructed with an arbitrary object.  <a href="classgalsim_1_1utilities_1_1_simple_generator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13e9d483f84e5d442b47384d26f5f65b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a13e9d483f84e5d442b47384d26f5f65b">roll2d</a></td></tr>
<tr class="memdesc:a13e9d483f84e5d442b47384d26f5f65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a 2D roll (circular shift) on a supplied 2D numpy array, conveniently.  <a href="#a13e9d483f84e5d442b47384d26f5f65b">More...</a><br/></td></tr>
<tr class="separator:a13e9d483f84e5d442b47384d26f5f65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#ae3d1586e7c70ecfd9582b71f6f5147ab">kxky</a></td></tr>
<tr class="memdesc:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tuple kx, ky corresponding to the DFT of a unit integer-sampled array of input shape.  <a href="#ae3d1586e7c70ecfd9582b71f6f5147ab">More...</a><br/></td></tr>
<tr class="separator:ae3d1586e7c70ecfd9582b71f6f5147ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5623a48fc511636b486d42816ba940"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a9e5623a48fc511636b486d42816ba940">g1g2_to_e1e2</a></td></tr>
<tr class="memdesc:a9e5623a48fc511636b486d42816ba940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for going from (g1, g2) -&gt; (e1, e2).  <a href="#a9e5623a48fc511636b486d42816ba940">More...</a><br/></td></tr>
<tr class="separator:a9e5623a48fc511636b486d42816ba940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e66b2539898963681cd1bf1fba0214"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af0e66b2539898963681cd1bf1fba0214">rotate_xy</a></td></tr>
<tr class="memdesc:af0e66b2539898963681cd1bf1fba0214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates points in the xy-Cartesian plane counter-clockwise through an angle theta about the origin of the Cartesian coordinate system.  <a href="#af0e66b2539898963681cd1bf1fba0214">More...</a><br/></td></tr>
<tr class="separator:af0e66b2539898963681cd1bf1fba0214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#af424a90c9e1c9f64eaaf4f52bcb1aceb">parse_pos_args</a></td></tr>
<tr class="memdesc:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the args and kwargs of a function call to be some kind of position.  <a href="#af424a90c9e1c9f64eaaf4f52bcb1aceb">More...</a><br/></td></tr>
<tr class="separator:af424a90c9e1c9f64eaaf4f52bcb1aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd8593ea30d16263c2f03e1147b5b27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#abbd8593ea30d16263c2f03e1147b5b27">rand_arr</a></td></tr>
<tr class="memdesc:abbd8593ea30d16263c2f03e1147b5b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to make a 2d array of random deviates (of any sort).  <a href="#abbd8593ea30d16263c2f03e1147b5b27">More...</a><br/></td></tr>
<tr class="separator:abbd8593ea30d16263c2f03e1147b5b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea0edb61ecb4fee9e1ed17af11a1559"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#acea0edb61ecb4fee9e1ed17af11a1559">convert_interpolant_to_2d</a></td></tr>
<tr class="memdesc:acea0edb61ecb4fee9e1ed17af11a1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant2d.html" title="Two-dimensional version of the Interpolant interface. ">Interpolant2d</a> if it is given as a string or 1-d.  <a href="#acea0edb61ecb4fee9e1ed17af11a1559">More...</a><br/></td></tr>
<tr class="separator:acea0edb61ecb4fee9e1ed17af11a1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd0e60b389f6d9e1c19409c50772f1b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a4cd0e60b389f6d9e1c19409c50772f1b">compare_dft_vs_photon_object</a></td></tr>
<tr class="memdesc:a4cd0e60b389f6d9e1c19409c50772f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an input object (with optional PSF) and render it in two ways comparing results at high precision.  <a href="#a4cd0e60b389f6d9e1c19409c50772f1b">More...</a><br/></td></tr>
<tr class="separator:a4cd0e60b389f6d9e1c19409c50772f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619df15ad265e575d84da86fcd80d090"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a619df15ad265e575d84da86fcd80d090">compare_dft_vs_photon_config</a></td></tr>
<tr class="memdesc:a619df15ad265e575d84da86fcd80d090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an input config dictionary and render the object it describes in two ways, comparing results at high precision.  <a href="#a619df15ad265e575d84da86fcd80d090">More...</a><br/></td></tr>
<tr class="separator:a619df15ad265e575d84da86fcd80d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726162f079025bf5e5a622702d001ad7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegalsim_1_1utilities.html#a726162f079025bf5e5a622702d001ad7">thin_tabulated_values</a></td></tr>
<tr class="memdesc:a726162f079025bf5e5a622702d001ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy.  <a href="#a726162f079025bf5e5a622702d001ad7">More...</a><br/></td></tr>
<tr class="separator:a726162f079025bf5e5a622702d001ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a619df15ad265e575d84da86fcd80d090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.compare_dft_vs_photon_config </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gal_num</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nproc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pixel_scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>abs_tol_ellip</em> = <code>1.e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>abs_tol_size</em> = <code>1.e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_trials_per_iter</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_max_iter</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons_per_trial</em> = <code>1e7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>moments</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hsm</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>logger</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an input config dictionary and render the object it describes in two ways, comparing results at high precision. </p>
<p>The config dictionary can contain either: (i) one single object, (ii) a collection of objects, each one of them repeated in a Sequence n_trials_per_iter times. The image type should be 'Single'. Example config fragment: </p>
<pre class="fragment">&amp;n_trials_per_iter 32 
gal :
  type : Sersic    
  half_light_radius : 
    type : Catalog , 
    col : 2,  index : { type: Sequence, repeat: *n_trials_per_iter} }
  n : 
    type : Catalog , 
    col : 1,  
    index : { type: Sequence, repeat: *n_trials_per_iter} 
...
image: { type : Single  ... }
</pre><p>For both cases there should be no randomly selected parameters in the galaxy and PSF config specification.</p>
<p>For an example of defining a config dictionary of the sort suitable for input to this function, see examples/demo8.py in the GalSim repository.</p>
<p>Using both photon shooting (via drawShoot) and Discrete Fourier Transform (via shoot) to render images, we compare the numerical values of adaptive moments estimates of ellipticity and size to check consistency.</p>
<p>We generate successive sets of <code>n_trials_per_iter</code> photon-shot images, using <code>n_photons_per_trial</code> photons in each image, until the standard error on the mean absolute size and ellipticty drop below <code>abs_tol_size</code> and <code>abs_tol_ellip</code>. We then output a <a class="el" href="classgalsim_1_1utilities_1_1_comparison_shape_data.html" title="A class to contain the outputs of a comparison between photon shooting and DFT rendering of GSObjects...">ComparisonShapeData</a> object which stores the results.</p>
<p>Note that <code>n_photons_per_trial</code> should be large (&gt;~ 1e6) to ensure that any biases detected between the photon shooting and DFT-drawn images are due to numerical differences rather than biases on adaptive moments due to noise itself, a generic feature in this work. This can be verified with a convergence test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>GalSim config dictionary describing the GSObject we wish to test (see e.g. examples/demo8.py). </td></tr>
    <tr><td class="paramname">gal_num</td><td>Number for the galaxy in the config dictionary, which will be passed to the config system. It related to obj_num in the config system by obj_num = gal_num * n_trials_per_iter (assuming the config is created correctly as explained in the example above) [default: 0] </td></tr>
    <tr><td class="paramname">random_seed</td><td>Integer to be used as the basis of all seeds for the random number generator, overrides any value in config['image']. [default: None] </td></tr>
    <tr><td class="paramname">nproc</td><td>Number of cpu processes to run in parallel, overrides any value in config['image']. [default: None] </td></tr>
    <tr><td class="paramname">pixel_scale</td><td>The pixel scale to use in the test images, overrides any value in config['image']. [default: None] </td></tr>
    <tr><td class="paramname">size</td><td>The size of the images in the rendering tests - all test images are currently square, overrides any value in config['image']. [default: None] </td></tr>
    <tr><td class="paramname">wmult</td><td>The <code>wmult</code> parameter used in .draw() (see the GSObject .draw() method docs via <code>help(galsim.GSObject.draw)</code> for more details), overrides any value in config['image']. [default: None] </td></tr>
    <tr><td class="paramname">abs_tol_ellip</td><td>The test will keep iterating, adding ever greater numbers of trials, until estimates of the 1-sigma standard error on mean ellipticity moments from photon-shot images are smaller than this param value. If moments=False, then using the measurements from HSM. [default: 1.e-5] </td></tr>
    <tr><td class="paramname">abs_tol_size</td><td>The test will keep iterating, adding ever greater numbers of trials, until estimates of the 1-sigma standard error on mean size moments from photon-shot images are smaller than this param value. If moments=False, then using the measurements from HSM. [default: 1.e-5] </td></tr>
    <tr><td class="paramname">n_trials_per_iter</td><td>Number of trial images used to estimate (or successively re-estimate) the standard error on the delta quantities above for each iteration of the tests. [default: 32] </td></tr>
    <tr><td class="paramname">n_max_iter</td><td>Maximum number of iterations. After reaching it, the current uncertainty on shape measurement is reported, even if abs_tol_ellip and abs_tol_size was not reported. If a negative number is supplied, then there is no limit of number of iterations. [default: -1] </td></tr>
    <tr><td class="paramname">n_photons_per_trial</td><td>Number of photons shot in drawShoot() for each trial. This should be large enough that any noise bias (a.k.a. noise rectification bias) on moments estimates is small. [default: 1e7] </td></tr>
    <tr><td class="paramname">moments</td><td>Set True to compare rendered images using AdaptiveMoments estimates of simple observed estimates. [default: True] </td></tr>
    <tr><td class="paramname">hsm</td><td>Should the rendered images be compared using HSM shear estimates? (i.e. including a PSF correction for shears) [default: False] </td></tr>
    <tr><td class="paramname">logger</td><td>Logging Logger instance to record output and pass down to the config layer for debuging / verbose output if desired. [default: None] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cd0e60b389f6d9e1c19409c50772f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.compare_dft_vs_photon_object </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gsobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>psf_object</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pixel_scale</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>512</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>4.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>abs_tol_ellip</em> = <code>1.e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>abs_tol_size</em> = <code>1.e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_trials_per_iter</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons_per_trial</em> = <code>1e7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>moments</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hsm</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an input object (with optional PSF) and render it in two ways comparing results at high precision. </p>
<p>Using both photon shooting (via drawShoot) and Discrete Fourier Transform (via draw) to render images, we compare the numerical values of adaptive moments estimates of size and ellipticity to check consistency.</p>
<p>This function takes actual GSObjects as its input, but because these are not yet picklable this means that the internals cannot be parallelized using the Python multiprocessing module. For a parallelized function, that instead uses a config dictionary to specify the test objects, see the function <a class="el" href="namespacegalsim_1_1utilities.html#a619df15ad265e575d84da86fcd80d090" title="Take an input config dictionary and render the object it describes in two ways, comparing results at ...">compare_dft_vs_photon_config()</a> in this module.</p>
<p>We generate successive sets of <code>n_trials_per_iter</code> photon-shot images, using <code>n_photons_per_trial</code> photons in each image, until the standard error on the mean absolute size and ellipticity drop below <code>abs_tol_size</code> and <code>abs_tol_ellip</code>. We then output a <a class="el" href="classgalsim_1_1utilities_1_1_comparison_shape_data.html" title="A class to contain the outputs of a comparison between photon shooting and DFT rendering of GSObjects...">ComparisonShapeData</a> object which stores the results.</p>
<p>Note that <code>n_photons_per_trial</code> should be large (&gt;~ 1e6) to ensure that any biases detected between the photon shooting and DFT-drawn images are due to numerical differences rather than biases on adaptive moments due to noise itself, a generic feature in this work. This can be verified with a convergence test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gsobject</td><td>The galsim.GSObject for which this test is to be performed (prior to PSF convolution if a PSF is also supplied via <code>psf_object</code>). Note that this function will automatically handle integration over a galsim.Pixel of width <code>pixel_scale</code>, so a galsim.Pixel should not be included in the supplied <code>gsobject</code> (unless you really mean to include it, which will be very rare in normal usage). </td></tr>
    <tr><td class="paramname">psf_object</td><td>Optional additional PSF for tests of convolved objects, also a galsim.GSObject. Note that this function will automatically handle integration over a galsim.Pixel of width <code>pixel_scale</code>, so this should not be included in the supplied <code>psf_object</code>. [default: None] </td></tr>
    <tr><td class="paramname">rng</td><td>A <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">galsim.BaseDeviate</a> or derived deviate class instance to provide the pseudo random numbers for the photon shooting. [default: None] </td></tr>
    <tr><td class="paramname">pixel_scale</td><td>The pixel scale to use in the test images. [default: 1] </td></tr>
    <tr><td class="paramname">size</td><td>The size of the images in the rendering tests - all test images are currently square. [default: 512] </td></tr>
    <tr><td class="paramname">wmult</td><td>The <code>wmult</code> parameter used in .draw() (see the GSObject .draw() method docs via <code>help(galsim.GSObject.draw)</code> for more details). [default: 4] </td></tr>
    <tr><td class="paramname">abs_tol_ellip</td><td>The test will keep iterating, adding ever greater numbers of trials, until estimates of the 1-sigma standard error on mean ellipticity moments from photon-shot images are smaller than this param value. [default: 1.e-5] </td></tr>
    <tr><td class="paramname">abs_tol_size</td><td>The test will keep iterating, adding ever greater numbers of trials, until estimates of the 1-sigma standard error on mean size moments from photon-shot images are smaller than this param value. [default: 1.e-5] </td></tr>
    <tr><td class="paramname">n_trials_per_iter</td><td>Number of trial images used to estimate (or successively re-estimate) the standard error on the delta quantities above for each iteration of the tests. [default: 32] </td></tr>
    <tr><td class="paramname">n_photons_per_trial</td><td>Number of photons shot in drawShoot() for each trial. This should be large enough that any noise bias (a.k.a. noise rectification bias) on moments estimates is small. [default: 1e7] </td></tr>
    <tr><td class="paramname">moments</td><td>Set True to compare rendered images using AdaptiveMoments estimates of simple observed estimates. [default: True] </td></tr>
    <tr><td class="paramname">hsm</td><td>Should the rendered images be compared using HSM shear estimates? (i.e. including a PSF correction for shears) [not implemented] Convenience function to run ntrials and collect the results, uses only a single core. <pre class="fragment">    Uses a Python for loop but this is very unlikely to be a rate determining factor provided
    n_photons is suitably large (&gt;1e6).</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acea0edb61ecb4fee9e1ed17af11a1559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.convert_interpolant_to_2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given interpolant to an <a class="el" href="classgalsim_1_1_interpolant2d.html" title="Two-dimensional version of the Interpolant interface. ">Interpolant2d</a> if it is given as a string or 1-d. </p>

</div>
</div>
<a class="anchor" id="a9e5623a48fc511636b486d42816ba940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.g1g2_to_e1e2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for going from (g1, g2) -&gt; (e1, e2). </p>
<p>Here g1 and g2 are reduced shears, and e1 and e2 are distortions - see <a class="el" href="shear_8py.html" title="Redefinition of the Shear class at the Python layer. ">shear.py</a> for definitions of reduced shear and distortion in terms of axis ratios or other ways of specifying ellipses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First reduced shear component (along pixel axes) </td></tr>
    <tr><td class="paramname">g2</td><td>Second reduced shear component (at 45 degrees with respect to image axes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding distortions, e1 and e2. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3d1586e7c70ecfd9582b71f6f5147ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.kxky </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array_shape</em> = <code>(256,&#160;256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the tuple kx, ky corresponding to the DFT of a unit integer-sampled array of input shape. </p>
<p>Uses the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> conventions for Fourier space, so k varies in approximate range (-pi, pi]. Uses the most common DFT element ordering conventions (and those of FFTW), so that <code>(0, 0)</code> array element corresponds to <code>(kx, ky) = (0, 0)</code>.</p>
<p>See also the docstring for np.fftfreq, which uses the same DFT convention, and is called here, but misses a factor of pi.</p>
<p>Adopts Numpy array index ordering so that the trailing axis corresponds to kx, rather than the leading axis as would be expected in IDL/Fortran. See docstring for numpy.meshgrid which also uses this convention.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_shape</td><td>The Numpy array shape desired for <code>kx, ky</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af424a90c9e1c9f64eaaf4f52bcb1aceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.parse_pos_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integer</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>others</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the args and kwargs of a function call to be some kind of position. </p>
<p>We allow four options: </p>
<pre class="fragment">f(x,y)
f(galsim.PositionD(x,y)) or f(galsim.PositionI(x,y))
f( (x,y) )  (or any indexable thing)
f(name1=x, name2=y)
</pre><p>If the inputs must be integers, set <code>integer=True</code>. If there are other args/kwargs to parse after these, then their names should be be given as the parameter <code>others</code>, which are passed back in a tuple after the position. </p>

</div>
</div>
<a class="anchor" id="abbd8593ea30d16263c2f03e1147b5b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rand_arr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deviate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to make a 2d array of random deviates (of any sort). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A list of length 2, indicating the desired 2d array dimensions </td></tr>
    <tr><td class="paramname">deviate</td><td>Any GalSim deviate (see <a class="el" href="random_8py.html" title="Addition of docstrings to the Random deviate classes at the Python layer and definition of the DistDe...">random.py</a>) such as <a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.). ">UniformDeviate</a>, <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution. ">GaussianDeviate</a>, etc. to be used to generate random numbers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Numpy array of the desired dimensions with random numbers generated using the supplied deviate. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e9d483f84e5d442b47384d26f5f65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.roll2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iroll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jroll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a 2D roll (circular shift) on a supplied 2D numpy array, conveniently. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The numpy array to be circular shifted. </td></tr>
    <tr><td class="paramname">(iroll,jroll)</td><td>The roll in the i and j dimensions, respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rolled image. </dd></dl>

</div>
</div>
<a class="anchor" id="af0e66b2539898963681cd1bf1fba0214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.rotate_xy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates points in the xy-Cartesian plane counter-clockwise through an angle theta about the origin of the Cartesian coordinate system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>NumPy array of input x coordinates </td></tr>
    <tr><td class="paramname">y</td><td>NumPy array of input y coordinates </td></tr>
    <tr><td class="paramname">theta</td><td>Rotation angle (+ve counter clockwise) as a <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">galsim.Angle</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated coordinates (x_rot,y_rot). </dd></dl>

</div>
</div>
<a class="anchor" id="a726162f079025bf5e5a622702d001ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.utilities.thin_tabulated_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_err</em> = <code>1.e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>preserve_range</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove items from a set of tabulated f(x) values so that the error in the integral is still accurate to a given relative accuracy. </p>
<p>The input x,f values can be lists, numpy arrays, or really anything that can be converted to a numpy array. The new lists will be output as python lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">f</td><td>The f values in the f(x) tabulation. </td></tr>
    <tr><td class="paramname">rel_err</td><td>The maximum relative error to allow in the integral from the removal. (default: 1.e-4) </td></tr>
    <tr><td class="paramname">preserve_range</td><td>Should the original range of x be preserved? (True) Or should the ends be trimmed to include only the region where the integral is significant? (False) (default: False)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of lists (x_new, y_new) with the thinned tabulation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>

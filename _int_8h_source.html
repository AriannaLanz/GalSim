<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GalSim: include/galsim/integ/Int.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>include/galsim/integ/Int.h</h1><a href="_int_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- c++ -*-</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright 2012-2014 The GalSim developers:</span>
<a name="l00003"></a>00003 <span class="comment"> * https://github.com/GalSim-developers</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * GalSim is free software: you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment"> * the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment"> * (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * GalSim is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment"> * along with GalSim.  If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 
<a name="l00146"></a>00146 <span class="preprocessor">#ifndef INT_H</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor">#define INT_H</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>
<a name="l00149"></a>00149 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00150"></a>00150 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00151"></a>00151 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00152"></a>00152 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00153"></a>00153 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00154"></a>00154 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00155"></a>00155 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00156"></a>00156 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00157"></a>00157 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00158"></a>00158 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00159"></a>00159 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00160"></a><a class="code" href="_int_8h.html#ae23b24e85d04f74fdebd21fe0cc0ebcf">00160</a> <span class="preprocessor">#define BOOST_NO_CXX11_SMART_PTR</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/shared_ptr.hpp&gt;</span>
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="preprocessor">#include &quot;MoreFunctional.h&quot;</span>
<a name="l00164"></a>00164 <span class="comment">//#include &quot;IntGKPData10.h&quot;</span>
<a name="l00165"></a>00165 <span class="preprocessor">#include &quot;IntGKPData1.h&quot;</span>
<a name="l00166"></a>00166 <span class="keyword">namespace </span>galsim {
<a name="l00167"></a><a class="code" href="namespacegalsim_1_1integ.html">00167</a> <span class="keyword">namespace </span>integ {
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="namespacegalsim_1_1integ.html#a6b6018110186f8c2f79e01f175c1dfa6">00169</a>     <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacegalsim_1_1integ.html#a6b6018110186f8c2f79e01f175c1dfa6" title="May be used to indicate infinity in integration regions.">MOCK_INF</a> = 1.e100;  
<a name="l00170"></a><a class="code" href="namespacegalsim_1_1integ.html#ac48378074a01f187e7df24157f2f8119">00170</a>     <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacegalsim_1_1integ.html#ac48378074a01f187e7df24157f2f8119" title="Anything larger than this is treated as infinity.">MOCK_INF2</a> = 1.e10;  
<a name="l00171"></a><a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5">00171</a>     <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a> = 1.e-6;  
<a name="l00172"></a><a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4">00172</a>     <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a> = 1.e-12; 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00176"></a><a class="code" href="structgalsim_1_1integ_1_1_int_failure.html">00176</a>     <span class="keyword">struct </span><a class="code" href="structgalsim_1_1integ_1_1_int_failure.html" title="An exception type thrown if the integrator encounters a problem.">IntFailure</a> : <span class="keyword">public</span> std::runtime_error
<a name="l00177"></a><a class="code" href="structgalsim_1_1integ_1_1_int_failure.html#accfe79d657bcf85677d4f85daee1466b">00177</a>     { <a class="code" href="structgalsim_1_1integ_1_1_int_failure.html#accfe79d657bcf85677d4f85daee1466b">IntFailure</a>(<span class="keyword">const</span> std::string&amp; s) : std::runtime_error(s) {} };
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="preprocessor">#ifdef NDEBUG</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#define integ_dbg1 if (false) (*dbgout)</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor">#define integ_dbg2 if (false) (*reg.dbgout)</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span><span class="preprocessor">#define integ_dbg3 if (false) (*tempreg.dbgout)</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00184"></a><a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">00184</a> <span class="preprocessor"></span><span class="preprocessor">#define integ_dbg1 if (dbgout) (*dbgout)</span>
<a name="l00185"></a><a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">00185</a> <span class="preprocessor"></span><span class="preprocessor">#define integ_dbg2 if (reg.dbgout) (*reg.dbgout)</span>
<a name="l00186"></a><a class="code" href="_int_8h.html#a3930e446fb38950e18570ac555ae9bfb">00186</a> <span class="preprocessor"></span><span class="preprocessor">#define integ_dbg3 if (tempreg.dbgout) (*tempreg.dbgout)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span>
<a name="l00189"></a>00189 <span class="preprocessor">#ifdef COUNTFEVAL</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>    <span class="keywordtype">int</span> nfeval = 0;  
<a name="l00191"></a>00191 <span class="preprocessor">#endif</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>
<a name="l00202"></a>00202     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
<a name="l00203"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html">00203</a>     <span class="keyword">struct </span><a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion</a> 
<a name="l00204"></a>00204     {
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="keyword">public</span>:
<a name="l00215"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#aa7b59b7477c2e421c2033b0cf481988b">00215</a>         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion</a>(
<a name="l00216"></a>00216             <span class="keyword">const</span> T a,  
<a name="l00217"></a>00217             <span class="keyword">const</span> T b,  
<a name="l00218"></a>00218             std::ostream* dbgout_=0,  
<a name="l00219"></a>00219             std::map&lt;T,T&gt;* fxmap_=0   
<a name="l00220"></a>00220         ) :
<a name="l00221"></a>00221             _a(a), _b(b), _error(0.), _area(0), dbgout(dbgout_), fxmap(fxmap_) {}
<a name="l00222"></a>00222 
<a name="l00224"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a922a07aae1733dfe003abf336013a49b">00224</a>         <span class="keywordtype">bool</span> operator&lt;(const IntRegion&lt;T&gt;&amp; r2) <span class="keyword">const</span> 
<a name="l00225"></a>00225         { <span class="keywordflow">return</span> _error &lt; r2._error; }
<a name="l00226"></a>00226 
<a name="l00228"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a08765f39ab9be5f14a6b884d470c4c96">00228</a>         <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a>&amp; r2)<span class="keyword"> const </span>
<a name="l00229"></a>00229 <span class="keyword">        </span>{ <span class="keywordflow">return</span> _error &gt; r2._error; }
<a name="l00230"></a>00230 
<a name="l00239"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a178bdfcc6af29942689d40b56308fcd2">00239</a>         <span class="keywordtype">void</span> subDivide(std::vector&lt;<a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a> &gt;&amp; children) 
<a name="l00240"></a>00240         {
<a name="l00241"></a>00241             assert(children.size() == 0);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243             <span class="comment">// If no current split points, then just use bisection.</span>
<a name="l00244"></a>00244             <span class="keywordflow">if</span> (_split_points.size() == 0) bisect();
<a name="l00245"></a>00245 
<a name="l00246"></a>00246             <span class="keywordflow">if</span> (_split_points.size() &gt; 1) 
<a name="l00247"></a>00247                 std::sort(_split_points.begin(),_split_points.end());
<a name="l00248"></a>00248 
<a name="l00249"></a>00249             assert(_split_points[0] &gt;= _a);
<a name="l00250"></a>00250             assert(_split_points.back() &lt;= _b);
<a name="l00251"></a>00251             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Using split points:\n&quot;</span>;
<a name="l00252"></a>00252             integ_dbg1&lt;&lt;_split_points[0]&lt;&lt;<span class="charliteral">&apos;\n&apos;</span>;
<a name="l00253"></a>00253             children.push_back(<a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a>(_a,_split_points[0],dbgout,fxmap));
<a name="l00254"></a>00254             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=1;i&lt;_split_points.size();i++) {
<a name="l00255"></a>00255                 integ_dbg1&lt;&lt;_split_points[i]&lt;&lt;<span class="charliteral">&apos;\n&apos;</span>;
<a name="l00256"></a>00256                 children.push_back(
<a name="l00257"></a>00257                     <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a>(_split_points[i-1],_split_points[i],dbgout,fxmap));
<a name="l00258"></a>00258             }
<a name="l00259"></a>00259             children.push_back(<a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a>(_split_points.back(),_b,dbgout,fxmap));
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261 
<a name="l00263"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#ab0c41515a1389efa8fbc10e718bff523">00263</a>         <span class="keywordtype">void</span> <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#ab0c41515a1389efa8fbc10e718bff523" title="Set a split point at the bisection.">bisect</a>() { _split_points.push_back((_a+_b)/2.); }
<a name="l00264"></a>00264 
<a name="l00266"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3fcc5fc087e21c5a6ac6dac790801469">00266</a>         <span class="keywordtype">void</span> findZeroCrossings()
<a name="l00267"></a>00267         {
<a name="l00268"></a>00268             <span class="keyword">typedef</span> <span class="keyword">typename</span> std::map&lt;T,T&gt;::const_iterator MapIter;
<a name="l00269"></a>00269             <span class="keywordflow">if</span> (fxmap) {
<a name="l00270"></a>00270                 MapIter start = fxmap-&gt;lower_bound(_a);
<a name="l00271"></a>00271                 MapIter end = fxmap-&gt;upper_bound(_b);
<a name="l00272"></a>00272                 <span class="keywordflow">if</span> (start == end) <span class="keywordflow">return</span>;
<a name="l00273"></a>00273                 MapIter previt = start;
<a name="l00274"></a>00274                 MapIter it = start;
<a name="l00275"></a>00275                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;f(&quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="stringliteral">&quot;) = &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00276"></a>00276                 <span class="keywordtype">bool</span> zero_train = <span class="keyword">false</span>;
<a name="l00277"></a>00277                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Start search for zero crossings\n&quot;</span>;
<a name="l00278"></a>00278                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;first = &quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;std::endl;
<a name="l00279"></a>00279                 <span class="keywordflow">while</span> (++it != end) {
<a name="l00280"></a>00280                     <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;f(&quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="stringliteral">&quot;) = &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00281"></a>00281                     <span class="keywordflow">if</span> ( (it-&gt;second &gt; T(0) &amp;&amp; previt-&gt;second &lt; T(0)) ||
<a name="l00282"></a>00282                          (it-&gt;second &lt; T(0) &amp;&amp; previt-&gt;second &gt; T(0)) ) {
<a name="l00283"></a>00283                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Found zero crossing.\n&quot;</span>;
<a name="l00284"></a>00284                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;prev = &quot;</span>&lt;&lt;previt-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;previt-&gt;second&lt;&lt;std::endl;
<a name="l00285"></a>00285                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;this = &quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;std::endl;
<a name="l00286"></a>00286                         <span class="keywordtype">double</span> m = (it-&gt;first - previt-&gt;first) / (it-&gt;second - previt-&gt;second);
<a name="l00287"></a>00287                         <span class="keywordtype">double</span> x = it-&gt;first - m * it-&gt;second;
<a name="l00288"></a>00288                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;m = &quot;</span>&lt;&lt;m&lt;&lt;<span class="stringliteral">&quot;, x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;
<a name="l00289"></a>00289                         _split_points.push_back(x);
<a name="l00290"></a>00290                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (zero_train &amp;&amp; it-&gt;second != T(0)) {
<a name="l00291"></a>00291                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Found end of zero train.\n&quot;</span>;
<a name="l00292"></a>00292                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;prev = &quot;</span>&lt;&lt;previt-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;previt-&gt;second&lt;&lt;std::endl;
<a name="l00293"></a>00293                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;this = &quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;std::endl;
<a name="l00294"></a>00294                         _split_points.push_back(previt-&gt;first);
<a name="l00295"></a>00295                         _split_points.push_back(it-&gt;first);
<a name="l00296"></a>00296                         zero_train = <span class="keyword">false</span>;
<a name="l00297"></a>00297                         MapIter nextit = it; ++nextit;
<a name="l00298"></a>00298                         <span class="keywordflow">if</span> (nextit != end) {
<a name="l00299"></a>00299                             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Not last element in list.  Try to refine\n&quot;</span>;
<a name="l00300"></a>00300                             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;next = &quot;</span>&lt;&lt;nextit-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;nextit-&gt;second&lt;&lt;std::endl;
<a name="l00301"></a>00301                             <span class="keywordtype">double</span> m = (it-&gt;first - nextit-&gt;first) / (it-&gt;second - nextit-&gt;second);
<a name="l00302"></a>00302                             <span class="keywordtype">double</span> x = it-&gt;first - m * it-&gt;second;
<a name="l00303"></a>00303                             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;m = &quot;</span>&lt;&lt;m&lt;&lt;<span class="stringliteral">&quot;, x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;
<a name="l00304"></a>00304                             <span class="keywordflow">if</span> (x &gt; previt-&gt;first &amp;&amp; x &lt; it-&gt;first) {
<a name="l00305"></a>00305                                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Valid extrapolation.\n&quot;</span>;
<a name="l00306"></a>00306                                 _split_points.push_back(x);
<a name="l00307"></a>00307                             } <span class="keywordflow">else</span> {
<a name="l00308"></a>00308                                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Invalid extrapolation.  Ignore.\n&quot;</span>;
<a name="l00309"></a>00309                             }
<a name="l00310"></a>00310                         }
<a name="l00311"></a>00311                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!zero_train &amp;&amp; it-&gt;second == T(0)) {
<a name="l00312"></a>00312                         <span class="keywordflow">if</span> (previt-&gt;second == T(0)) zero_train = <span class="keyword">true</span>;
<a name="l00313"></a>00313                         <span class="keywordflow">else</span> {
<a name="l00314"></a>00314                             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Found possible start of zero train.\n&quot;</span>;
<a name="l00315"></a>00315                             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;prev = &quot;</span>&lt;&lt;previt-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;previt-&gt;second&lt;&lt;std::endl;
<a name="l00316"></a>00316                             <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;this = &quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;std::endl;
<a name="l00317"></a>00317                             MapIter nextit = it; ++nextit;
<a name="l00318"></a>00318                             <span class="keywordflow">if</span> (nextit != end) {
<a name="l00319"></a>00319                                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;this is last in list.  Just add last two as splits\n&quot;</span>;
<a name="l00320"></a>00320                                 _split_points.push_back(previt-&gt;first);
<a name="l00321"></a>00321                                 _split_points.push_back(it-&gt;first);
<a name="l00322"></a>00322                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nextit-&gt;second == T(0)) {
<a name="l00323"></a>00323                                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Yes.  Start of zero train.\n&quot;</span>;
<a name="l00324"></a>00324                                 _split_points.push_back(previt-&gt;first);
<a name="l00325"></a>00325                                 _split_points.push_back(it-&gt;first);
<a name="l00326"></a>00326                                 MapIter previt2 = previt;
<a name="l00327"></a>00327                                 --previt2;
<a name="l00328"></a>00328                                 <span class="keywordflow">if</span> (previt2 != start) {
<a name="l00329"></a>00329                                     <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Not first element in list.  Try to refine\n&quot;</span>;
<a name="l00330"></a>00330                                     <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;prev2 = &quot;</span>&lt;&lt;previt2-&gt;first&lt;&lt;<span class="stringliteral">&quot; , &quot;</span>&lt;&lt;previt2-&gt;second&lt;&lt;std::endl;
<a name="l00331"></a>00331                                     <span class="keywordtype">double</span> m = (previt-&gt;first - previt2-&gt;first) /
<a name="l00332"></a>00332                                         (previt-&gt;second - previt2-&gt;second);
<a name="l00333"></a>00333                                     <span class="keywordtype">double</span> x = previt-&gt;first - m * previt-&gt;second;
<a name="l00334"></a>00334                                     <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;m = &quot;</span>&lt;&lt;m&lt;&lt;<span class="stringliteral">&quot;, x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;
<a name="l00335"></a>00335                                     <span class="keywordflow">if</span> (x &gt; previt-&gt;first &amp;&amp; x &lt; it-&gt;first) {
<a name="l00336"></a>00336                                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Valid extrapolation.\n&quot;</span>;
<a name="l00337"></a>00337                                         _split_points.push_back(x);
<a name="l00338"></a>00338                                     } <span class="keywordflow">else</span> {
<a name="l00339"></a>00339                                         <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Invalid extrapolation.  Ignore.\n&quot;</span>;
<a name="l00340"></a>00340                                     }
<a name="l00341"></a>00341                                 }
<a name="l00342"></a>00342                             } <span class="keywordflow">else</span> {
<a name="l00343"></a>00343                                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;No.  Not start of zero train.\n&quot;</span>;
<a name="l00344"></a>00344                                 <a class="code" href="_int_8h.html#a0cc3adeb5466ce22fddb289ef0924689">integ_dbg1</a>&lt;&lt;<span class="stringliteral">&quot;Just add this point as split point\n&quot;</span>;
<a name="l00345"></a>00345                                 _split_points.push_back(it-&gt;first);
<a name="l00346"></a>00346                             }
<a name="l00347"></a>00347                         }
<a name="l00348"></a>00348                     }
<a name="l00349"></a>00349                     previt = it;
<a name="l00350"></a>00350                 }
<a name="l00351"></a>00351             }
<a name="l00352"></a>00352         }
<a name="l00353"></a>00353 
<a name="l00360"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#ada5d8c79a86f8b7092b635a8a26c2b5d">00360</a>         <span class="keywordtype">void</span> <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#ada5d8c79a86f8b7092b635a8a26c2b5d" title="Add a split point to the current list to be used by the next subDivide call.">addSplit</a>(<span class="keyword">const</span> T x) { _split_points.push_back(x); }
<a name="l00361"></a>00361 
<a name="l00363"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a76c9e34358d7289a04115437e89c0de0">00363</a>         <span class="keywordtype">size_t</span> <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a76c9e34358d7289a04115437e89c0de0" title="Get the number of split points currently set.">getNSplit</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _split_points.size(); }
<a name="l00364"></a>00364 
<a name="l00366"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a">00366</a>         <span class="keyword">const</span> T&amp; <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _a; }
<a name="l00367"></a>00367 
<a name="l00369"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae">00369</a>         <span class="keyword">const</span> T&amp; <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _b; }
<a name="l00370"></a>00370 
<a name="l00372"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b">00372</a>         <span class="keyword">const</span> T&amp; <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b" title="Get the current error estimate.">getErr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _error; }
<a name="l00373"></a>00373 
<a name="l00375"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a4b27b64838fdff040f3668d0dcf01675">00375</a>         <span class="keyword">const</span> T&amp; <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a4b27b64838fdff040f3668d0dcf01675" title="Get the current estimate of the integral over the region.">getArea</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _area; }
<a name="l00376"></a>00376 
<a name="l00378"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a6657e1acd462fd33f4a5e6ded48bfd62">00378</a>         <span class="keywordtype">void</span> <a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a6657e1acd462fd33f4a5e6ded48bfd62" title="Set a new estimate of the area and error.">setArea</a>(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; e) { _area = a; _error = e; }
<a name="l00379"></a>00379 
<a name="l00381"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#ae1d3b8bf655b1700d58b3608b5460dd0">00381</a>         <span class="keywordtype">void</span> useFXMap() 
<a name="l00382"></a>00382         { _fxmap_source.reset(<span class="keyword">new</span> std::map&lt;T,T&gt;()); fxmap = _fxmap_source.get(); }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384     <span class="keyword">private</span>:
<a name="l00385"></a>00385         T _a,_b,_error,_area;
<a name="l00386"></a>00386         std::vector&lt;T&gt; _split_points;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="keyword">public</span>:
<a name="l00389"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a34438b9e684c31d58b07870c546f74c8">00389</a>         std::ostream* dbgout;
<a name="l00390"></a><a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1fb312aed660972beca41b4c599a9f18">00390</a>         std::map&lt;T,T&gt;* fxmap;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392     <span class="keyword">private</span>:
<a name="l00393"></a>00393         boost::shared_ptr&lt;std::map&lt;T,T&gt; &gt; _fxmap_source;
<a name="l00394"></a>00394     };
<a name="l00395"></a>00395 
<a name="l00396"></a>00396     <span class="keyword">namespace </span>{
<a name="l00398"></a>00398         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
<a name="l00399"></a>00399         <span class="keyword">inline</span> T rescaleError(
<a name="l00400"></a>00400             T err, 
<a name="l00401"></a>00401             <span class="keyword">const</span> T&amp; int_abs,     
<a name="l00402"></a>00402             <span class="keyword">const</span> T&amp; int_absdiff 
<a name="l00403"></a>00403         )
<a name="l00404"></a>00404         {
<a name="l00405"></a>00405             <span class="keyword">const</span> T eps = std::numeric_limits&lt;T&gt;::epsilon();
<a name="l00406"></a>00406             <span class="keyword">const</span> T minrep = std::numeric_limits&lt;T&gt;::min();
<a name="l00407"></a>00407 
<a name="l00408"></a>00408             <span class="keywordflow">if</span> (int_absdiff != 0. &amp;&amp; err != 0.) {
<a name="l00409"></a>00409                 <span class="keyword">const</span> T <a class="code" href="_c_h_a_n_g_e_l_o_g_8md.html#a7c480a64ce70877a04ac4ad9799961ba">scale</a> = (200. * err / int_absdiff);
<a name="l00410"></a>00410                 <span class="keywordflow">if</span> (scale &lt; 1.) err = int_absdiff * scale * sqrt(scale) ;
<a name="l00411"></a>00411                 <span class="keywordflow">else</span> err = int_absdiff ;
<a name="l00412"></a>00412             }
<a name="l00413"></a>00413             <span class="keywordflow">if</span> (int_abs &gt; minrep / (50. * eps)) {
<a name="l00414"></a>00414                 <span class="keyword">const</span> T min_err = 50. * eps * int_abs;
<a name="l00415"></a>00415                 <span class="keywordflow">if</span> (min_err &gt; err) err = min_err;
<a name="l00416"></a>00416             }
<a name="l00417"></a>00417             <span class="keywordflow">return</span> err;
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419 
<a name="l00438"></a>00438         <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00439"></a>00439         <span class="keyword">inline</span> <span class="keywordtype">bool</span> intGKPNA(
<a name="l00440"></a>00440             <span class="keyword">const</span> UF&amp; <a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">func</a>, 
<a name="l00441"></a>00441             IntRegion&lt;typename UF::result_type&gt;&amp; reg, 
<a name="l00442"></a>00442             <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type <a class="code" href="_int_8h.html#a0e9f6681c910ef2d85e1d0efae6a4a2d">relerr</a>,  
<a name="l00443"></a>00443             <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type <a class="code" href="_int_8h.html#aa11c2f12c3630ba41a493ce0bf1cc349">abserr</a>  
<a name="l00444"></a>00444         )
<a name="l00445"></a>00445         {
<a name="l00446"></a>00446             <span class="keyword">typedef</span> <span class="keyword">typename</span> UF::result_type T;
<a name="l00447"></a>00447             <span class="keyword">const</span> T a = reg.left();
<a name="l00448"></a>00448             <span class="keyword">const</span> T b = reg.right();
<a name="l00449"></a>00449 
<a name="l00450"></a>00450             <span class="keyword">const</span> T half_length =  0.5 * (b - a);
<a name="l00451"></a>00451             <span class="keyword">const</span> T abs_half_length = std::abs(half_length);
<a name="l00452"></a>00452             <span class="keyword">const</span> T center = 0.5 * (b + a);
<a name="l00453"></a>00453             <span class="keyword">const</span> T f_center = <a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">func</a>(center);
<a name="l00454"></a>00454             <span class="keywordflow">if</span> (reg.fxmap) (*reg.fxmap)[center] = f_center;
<a name="l00455"></a>00455 <span class="preprocessor">#ifdef COUNTFEVAL</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>            nfeval++;
<a name="l00457"></a>00457 <span class="preprocessor">#endif</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>            <span class="keyword">const</span> <span class="keywordtype">int</span> nmax = 2*gkp_x&lt;T&gt;(NGKPLEVELS-1).size()-1;
<a name="l00459"></a>00459             <span class="keyword">static</span> std::vector&lt;T&gt; fv1(nmax), fv2(nmax);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461             fv1.clear();
<a name="l00462"></a>00462             fv2.clear();
<a name="l00463"></a>00463             assert(fv1.size() == 0);
<a name="l00464"></a>00464             assert(fv2.size() == 0);
<a name="l00465"></a>00465             assert(<span class="keywordtype">int</span>(fv1.capacity()) == nmax);
<a name="l00466"></a>00466             assert(<span class="keywordtype">int</span>(fv2.capacity()) == nmax);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468             assert(gkp_wb&lt;T&gt;(0).size() == gkp_x&lt;T&gt;(0).size()+1);
<a name="l00469"></a>00469             T area1 = gkp_wb&lt;T&gt;(0).back() * f_center;
<a name="l00470"></a>00470             <span class="keywordtype">int</span> n0 = gkp_x&lt;T&gt;(0).size();
<a name="l00471"></a>00471             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;n0; k++) {
<a name="l00472"></a>00472                 <span class="keyword">const</span> T abscissa = half_length * gkp_x&lt;T&gt;(0)[k];
<a name="l00473"></a>00473                 <span class="keyword">const</span> T fval1 = <a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">func</a>(center - abscissa);
<a name="l00474"></a>00474                 <span class="keyword">const</span> T fval2 = <a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">func</a>(center + abscissa);
<a name="l00475"></a>00475                 area1 += gkp_wb&lt;T&gt;(0)[k] * (fval1+fval2);
<a name="l00476"></a>00476                 fv1.push_back(fval1);
<a name="l00477"></a>00477                 fv2.push_back(fval2);
<a name="l00478"></a>00478                 <span class="keywordflow">if</span> (reg.fxmap) {
<a name="l00479"></a>00479                     (*reg.fxmap)[center-abscissa] = fval1;
<a name="l00480"></a>00480                     (*reg.fxmap)[center+abscissa] = fval2;
<a name="l00481"></a>00481                 }
<a name="l00482"></a>00482             }
<a name="l00483"></a>00483             area1 *= half_length;
<a name="l00484"></a>00484 <span class="preprocessor">#ifdef COUNTFEVAL</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span>            nfeval+=gkp_x&lt;T&gt;(0).size()*2;
<a name="l00486"></a>00486 <span class="preprocessor">#endif</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>
<a name="l00488"></a>00488             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;level 0 rule: area = &quot;</span>&lt;&lt;area1&lt;&lt;std::endl;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490             T err=0; 
<a name="l00491"></a>00491             <span class="keywordtype">bool</span> calc_int_abs = <span class="keyword">true</span>;
<a name="l00492"></a>00492             T int_abs=0., int_absdiff=0.;
<a name="l00493"></a>00493             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> level=1; level&lt;NGKPLEVELS; level++) {
<a name="l00494"></a>00494                 assert(gkp_wa&lt;T&gt;(level).size() == fv1.size());
<a name="l00495"></a>00495                 assert(gkp_wa&lt;T&gt;(level).size() == fv2.size());
<a name="l00496"></a>00496                 assert(gkp_wb&lt;T&gt;(level).size() == gkp_x&lt;T&gt;(level).size()+1);
<a name="l00497"></a>00497                 T area2 = gkp_wb&lt;T&gt;(level).back() * f_center;
<a name="l00498"></a>00498                 <span class="comment">// int_abs = approximation to integral of abs(f)</span>
<a name="l00499"></a>00499                 <span class="keywordflow">if</span> (calc_int_abs) int_abs = std::abs(area2);
<a name="l00500"></a>00500                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k&lt;fv1.size(); k++) {
<a name="l00501"></a>00501                     area2 += gkp_wa&lt;T&gt;(level)[k] * (fv1[k]+fv2[k]);
<a name="l00502"></a>00502                     <span class="keywordflow">if</span> (calc_int_abs) 
<a name="l00503"></a>00503                         int_abs += gkp_wa&lt;T&gt;(level)[k] *
<a name="l00504"></a>00504                             (std::abs(fv1[k]) + std::abs(fv2[k]));
<a name="l00505"></a>00505                 }
<a name="l00506"></a>00506                 <span class="keywordtype">int</span> nl = gkp_x&lt;T&gt;(level).size();
<a name="l00507"></a>00507                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;nl; k++) {
<a name="l00508"></a>00508                     <span class="keyword">const</span> T abscissa = half_length * gkp_x&lt;T&gt;(level)[k];
<a name="l00509"></a>00509                     <span class="keyword">const</span> T fval1 = <a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">func</a>(center - abscissa);
<a name="l00510"></a>00510                     <span class="keyword">const</span> T fval2 = <a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">func</a>(center + abscissa);
<a name="l00511"></a>00511                     <span class="keyword">const</span> T fval = fval1 + fval2;
<a name="l00512"></a>00512                     area2 += gkp_wb&lt;T&gt;(level)[k] * fval;
<a name="l00513"></a>00513                     <span class="keywordflow">if</span> (calc_int_abs) 
<a name="l00514"></a>00514                         int_abs += gkp_wb&lt;T&gt;(level)[k] * (std::abs(fval1) + std::abs(fval2));
<a name="l00515"></a>00515                     fv1.push_back(fval1);
<a name="l00516"></a>00516                     fv2.push_back(fval2);
<a name="l00517"></a>00517                     <span class="keywordflow">if</span> (reg.fxmap) {
<a name="l00518"></a>00518                         (*reg.fxmap)[center-abscissa] = fval1;
<a name="l00519"></a>00519                         (*reg.fxmap)[center+abscissa] = fval2;
<a name="l00520"></a>00520                     }
<a name="l00521"></a>00521                 }
<a name="l00522"></a>00522 <span class="preprocessor">#ifdef COUNTFEVAL</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span>                nfeval+=gkp_x&lt;T&gt;(level).size()*2;
<a name="l00524"></a>00524 <span class="preprocessor">#endif</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (calc_int_abs) {
<a name="l00526"></a>00526                     <span class="keyword">const</span> T mean = area1*T(0.5);
<a name="l00527"></a>00527                     <span class="comment">// int_absdiff = approximation to the integral of abs(f-mean) </span>
<a name="l00528"></a>00528                     int_absdiff = gkp_wb&lt;T&gt;(level).back() * std::abs(f_center-mean);
<a name="l00529"></a>00529                     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k&lt;gkp_wa&lt;T&gt;(level).size(); k++) {
<a name="l00530"></a>00530                         int_absdiff += gkp_wa&lt;T&gt;(level)[k] * 
<a name="l00531"></a>00531                             (std::abs(fv1[k]-mean) + std::abs(fv2[k]-mean));
<a name="l00532"></a>00532                     }
<a name="l00533"></a>00533                     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k&lt;gkp_x&lt;T&gt;(level).size(); k++) {
<a name="l00534"></a>00534                         int_absdiff += gkp_wb&lt;T&gt;(level)[k] * 
<a name="l00535"></a>00535                             (std::abs(fv1[k]-mean) + std::abs(fv2[k]-mean));
<a name="l00536"></a>00536                     }
<a name="l00537"></a>00537                     int_absdiff *= abs_half_length ;
<a name="l00538"></a>00538                     int_abs *= abs_half_length;
<a name="l00539"></a>00539                 }
<a name="l00540"></a>00540                 area2 *= half_length;
<a name="l00541"></a>00541                 err = rescaleError(std::abs(area2-area1), int_abs, int_absdiff) ;
<a name="l00542"></a>00542                 <span class="keywordflow">if</span> (err &lt; int_absdiff) calc_int_abs = <span class="keyword">false</span>;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;at level &quot;</span>&lt;&lt;level&lt;&lt;<span class="stringliteral">&quot; area2 = &quot;</span>&lt;&lt;area2;
<a name="l00545"></a>00545                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;err&lt;&lt;std::endl;
<a name="l00546"></a>00546                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;error was &quot;</span>&lt;&lt;std::abs(area2-area1)&lt;&lt;std::endl;
<a name="l00547"></a>00547                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;rescaled using int_abs = &quot;</span>&lt;&lt;int_abs&lt;&lt;<span class="stringliteral">&quot;, int_absdiff = &quot;</span>&lt;&lt;int_absdiff&lt;&lt;std::endl;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549                 <span class="comment">//  Test for convergence.</span>
<a name="l00550"></a>00550                 <span class="keywordflow">if</span> (err &lt; abserr || err &lt; relerr * std::abs(area2)) {
<a name="l00551"></a>00551                     <span class="comment">// Converged.  Return current estimate.</span>
<a name="l00552"></a>00552                     reg.setArea(area2,err);
<a name="l00553"></a>00553                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00554"></a>00554                 }
<a name="l00555"></a>00555                 area1 = area2;
<a name="l00556"></a>00556             }
<a name="l00557"></a>00557             assert(<span class="keywordtype">int</span>(fv1.size()) == nmax);
<a name="l00558"></a>00558             assert(<span class="keywordtype">int</span>(fv2.size()) == nmax);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560             <span class="comment">// Failed to converge.  Return with current estimate of area and error</span>
<a name="l00561"></a>00561             reg.setArea(area1,err);
<a name="l00562"></a>00562 
<a name="l00563"></a>00563             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Failed to reach tolerance with highest-order GKP rule\n&quot;</span>;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565             <span class="keywordflow">if</span> (reg.fxmap) reg.findZeroCrossings();
<a name="l00566"></a>00566 
<a name="l00567"></a>00567             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569 
<a name="l00587"></a>00587         <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00588"></a>00588         <span class="keyword">inline</span> <span class="keywordtype">void</span> intGKP(
<a name="l00589"></a>00589             <span class="keyword">const</span> UF&amp; func, IntRegion&lt;typename UF::result_type&gt;&amp; reg,
<a name="l00590"></a>00590             <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type relerr,
<a name="l00591"></a>00591             <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type abserr)
<a name="l00592"></a>00592         {
<a name="l00593"></a>00593             <span class="keyword">typedef</span> <span class="keyword">typename</span> UF::result_type T;
<a name="l00594"></a>00594             <span class="keyword">const</span> T eps = std::numeric_limits&lt;T&gt;::epsilon();
<a name="l00595"></a>00595 
<a name="l00596"></a>00596             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Start intGKP\n&quot;</span>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598             assert(abserr &gt;= 0.);
<a name="l00599"></a>00599             assert(relerr &gt; 0.);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601             <span class="comment">// Check for early exit:</span>
<a name="l00602"></a>00602             <span class="keywordflow">if</span> (reg.left() == reg.right()) {
<a name="l00603"></a>00603                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;left == right, so integral is trivially 0.\n&quot;</span>;
<a name="l00604"></a>00604                 reg.setArea(0.,0.);
<a name="l00605"></a>00605                 <span class="keywordflow">return</span>;
<a name="l00606"></a>00606             }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608             <span class="comment">// Perform the first integration </span>
<a name="l00609"></a>00609             <span class="keywordtype">bool</span> done = intGKPNA(func, reg, relerr, abserr);
<a name="l00610"></a>00610             <span class="keywordflow">if</span> (done) {
<a name="l00611"></a>00611                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;GKPNA suceeded, so we&apos;re done.\n&quot;</span>;
<a name="l00612"></a>00612                 <span class="keywordflow">return</span>;
<a name="l00613"></a>00613             }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;In adaptive GKP, failed first pass... subdividing\n&quot;</span>;
<a name="l00616"></a>00616             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Intial range = &quot;</span>&lt;&lt;reg.left()&lt;&lt;<span class="stringliteral">&quot;..&quot;</span>&lt;&lt;reg.right()&lt;&lt;std::endl;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618             <span class="keywordtype">int</span> roundoff_type1 = 0, error_type = 0;
<a name="l00619"></a>00619             T roundoff_type2 = 0.;
<a name="l00620"></a>00620             <span class="keywordtype">int</span> iteration = 1;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622             <span class="comment">// Keep track of all subdivision in a priority_queue.  </span>
<a name="l00623"></a>00623             <span class="comment">// The top() is always the largest value, and pop() removes it.</span>
<a name="l00624"></a>00624             <span class="comment">// We define &lt; and &gt; for IntRegoins such that the &quot;largest&quot; is the one </span>
<a name="l00625"></a>00625             <span class="comment">// with the largest current error estimate.  This is the next one to be split </span>
<a name="l00626"></a>00626             <span class="comment">// if we need to split further.</span>
<a name="l00627"></a>00627             std::priority_queue&lt;IntRegion&lt;T&gt;,std::vector&lt;IntRegion&lt;T&gt; &gt; &gt; allregions;
<a name="l00628"></a>00628             allregions.push(reg);
<a name="l00629"></a>00629             T finalarea = reg.getArea();
<a name="l00630"></a>00630             T finalerr = reg.getErr();
<a name="l00631"></a>00631             T tolerance= std::max(abserr, relerr * std::abs(finalarea));
<a name="l00632"></a>00632             assert(finalerr &gt; tolerance);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634             <span class="keywordflow">while</span>(!error_type &amp;&amp; finalerr &gt; tolerance) {
<a name="l00635"></a>00635                 <span class="comment">// Bisect the subinterval with the largest error estimate </span>
<a name="l00636"></a>00636                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Current answer = &quot;</span>&lt;&lt;finalarea&lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;finalerr;
<a name="l00637"></a>00637                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;  (tol = &quot;</span>&lt;&lt;tolerance&lt;&lt;<span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00638"></a>00638                 IntRegion&lt;T&gt; parent = allregions.top(); 
<a name="l00639"></a>00639                 allregions.pop();
<a name="l00640"></a>00640                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Subdividing largest error region &quot;</span>;
<a name="l00641"></a>00641                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;parent.left()&lt;&lt;<span class="stringliteral">&quot;..&quot;</span>&lt;&lt;parent.right()&lt;&lt;std::endl;
<a name="l00642"></a>00642                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;parent area = &quot;</span>&lt;&lt;parent.getArea();
<a name="l00643"></a>00643                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;parent.getErr()&lt;&lt;std::endl;
<a name="l00644"></a>00644                 std::vector&lt;IntRegion&lt;T&gt; &gt; children;
<a name="l00645"></a>00645                 parent.subDivide(children);
<a name="l00646"></a>00646                 <span class="comment">// For &quot;GKP&quot;, there are only two, but for GKPOSC, there is one </span>
<a name="l00647"></a>00647                 <span class="comment">// for each oscillation in region</span>
<a name="l00648"></a>00648 
<a name="l00649"></a>00649                 <span class="comment">// Try to do at least 3x better with the children</span>
<a name="l00650"></a>00650                 T factor = 3*children.size()*finalerr/tolerance;
<a name="l00651"></a>00651                 T newabserr = std::abs(parent.getErr()/factor);
<a name="l00652"></a>00652                 T newrelerr = newabserr/std::abs(parent.getArea());
<a name="l00653"></a>00653                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;New abserr,rel = &quot;</span>&lt;&lt;newabserr&lt;&lt;<span class="charliteral">&apos;,&apos;</span>&lt;&lt;newrelerr;
<a name="l00654"></a>00654                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;  (&quot;</span>&lt;&lt;children.size()&lt;&lt;<span class="stringliteral">&quot; children)\n&quot;</span>;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656                 T newarea = T(0.0);
<a name="l00657"></a>00657                 T newerror = 0.0;
<a name="l00658"></a>00658                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;children.size();i++) {
<a name="l00659"></a>00659                     IntRegion&lt;T&gt;&amp; child = children[i];
<a name="l00660"></a>00660                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Integrating child &quot;</span>&lt;&lt;child.left();
<a name="l00661"></a>00661                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;..&quot;</span>&lt;&lt;child.right()&lt;&lt;std::endl;
<a name="l00662"></a>00662                     <span class="keywordtype">bool</span> converged;
<a name="l00663"></a>00663                     converged = intGKPNA(func, child, newrelerr, newabserr);
<a name="l00664"></a>00664                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;child (&quot;</span>&lt;&lt;i+1&lt;&lt;<span class="charliteral">&apos;/&apos;</span>&lt;&lt;children.size()&lt;&lt;<span class="stringliteral">&quot;) &quot;</span>;
<a name="l00665"></a>00665                     <span class="keywordflow">if</span> (converged) {
<a name="l00666"></a>00666                         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot; converged.&quot;</span>; 
<a name="l00667"></a>00667                     } <span class="keywordflow">else</span> {
<a name="l00668"></a>00668                         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot; failed.&quot;</span>;
<a name="l00669"></a>00669                     }
<a name="l00670"></a>00670                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;  Area = &quot;</span>&lt;&lt;child.getArea()&lt;&lt;
<a name="l00671"></a>00671                         <span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;child.getErr()&lt;&lt;std::endl;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673                     newarea += child.getArea();
<a name="l00674"></a>00674                     newerror += child.getErr();
<a name="l00675"></a>00675                 }
<a name="l00676"></a>00676                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Compare: newerr = &quot;</span>&lt;&lt;newerror;
<a name="l00677"></a>00677                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot; to parent err = &quot;</span>&lt;&lt;parent.getErr()&lt;&lt;std::endl;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679                 finalerr += (newerror - parent.getErr());
<a name="l00680"></a>00680                 finalarea += newarea - parent.getArea();
<a name="l00681"></a>00681 
<a name="l00682"></a>00682                 T delta = parent.getArea() - newarea;
<a name="l00683"></a>00683                 <span class="keywordflow">if</span> (newerror &lt;= parent.getErr() &amp;&amp; std::abs(delta) &lt;= parent.getErr()
<a name="l00684"></a>00684                     &amp;&amp; newerror &gt;= 0.99 * parent.getErr()) {
<a name="l00685"></a>00685                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;roundoff type 1: delta/newarea = &quot;</span>;
<a name="l00686"></a>00686                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;std::abs(delta)/std::abs(newarea);
<a name="l00687"></a>00687                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;, newerror/error = &quot;</span>&lt;&lt;
<a name="l00688"></a>00688                         newerror/parent.getErr()&lt;&lt;std::endl;
<a name="l00689"></a>00689                     roundoff_type1++;
<a name="l00690"></a>00690                 }
<a name="l00691"></a>00691                 <span class="keywordflow">if</span> (iteration &gt;= 10 &amp;&amp; newerror &gt; parent.getErr() &amp;&amp; 
<a name="l00692"></a>00692                     std::abs(delta) &lt;= newerror-parent.getErr()) {
<a name="l00693"></a>00693                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;roundoff type 2: newerror/error = &quot;</span>;
<a name="l00694"></a>00694                     <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;newerror/parent.getErr()&lt;&lt;std::endl;
<a name="l00695"></a>00695                     roundoff_type2+=std::min(newerror/parent.getErr()-1.,T(1.));
<a name="l00696"></a>00696                 }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698                 tolerance = std::max(abserr, relerr * std::abs(finalarea));
<a name="l00699"></a>00699                 <span class="keywordflow">if</span> (finalerr &gt; tolerance) {
<a name="l00700"></a>00700                     <span class="keywordflow">if</span> (roundoff_type1 &gt;= 200) {
<a name="l00701"></a>00701                         error_type = 1;    <span class="comment">// round off error </span>
<a name="l00702"></a>00702                         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;GKP: Round off error 1\n&quot;</span>;
<a name="l00703"></a>00703                     }
<a name="l00704"></a>00704                     <span class="keywordflow">if</span> (roundoff_type2 &gt;= 200.) {
<a name="l00705"></a>00705                         error_type = 2;    <span class="comment">// round off error </span>
<a name="l00706"></a>00706                         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;GKP: Round off error 2\n&quot;</span>;
<a name="l00707"></a>00707                     }
<a name="l00708"></a>00708                     <span class="keyword">const</span> <span class="keywordtype">double</span> parent_size = parent.right()-parent.left();
<a name="l00709"></a>00709                     <span class="keyword">const</span> <span class="keywordtype">double</span> reg_size = reg.right()-parent.left();
<a name="l00710"></a>00710                     <span class="keywordflow">if</span> (std::abs(parent_size / reg_size) &lt; eps) {
<a name="l00711"></a>00711                         error_type = 3; <span class="comment">// found singularity</span>
<a name="l00712"></a>00712                         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;GKP: Probable singularity\n&quot;</span>;
<a name="l00713"></a>00713                     }
<a name="l00714"></a>00714                 }
<a name="l00715"></a>00715                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;children.size();i++) allregions.push(children[i]);
<a name="l00716"></a>00716                 iteration++;
<a name="l00717"></a>00717             } 
<a name="l00718"></a>00718 
<a name="l00719"></a>00719             <span class="comment">// Recalculate finalarea in case there are any slight rounding errors</span>
<a name="l00720"></a>00720             finalarea=0.; finalerr=0.;
<a name="l00721"></a>00721             <span class="keywordflow">while</span> (!allregions.empty()) {
<a name="l00722"></a>00722                 <span class="keyword">const</span> IntRegion&lt;T&gt;&amp; r=allregions.top();
<a name="l00723"></a>00723                 finalarea += r.getArea();
<a name="l00724"></a>00724                 finalerr += r.getErr();
<a name="l00725"></a>00725                 allregions.pop();
<a name="l00726"></a>00726             }
<a name="l00727"></a>00727             reg.setArea(finalarea,finalerr);
<a name="l00728"></a>00728 
<a name="l00729"></a>00729             <span class="keywordflow">if</span> (error_type == 1) {
<a name="l00730"></a>00730                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Type 1 roundoff = &quot;</span>&lt;&lt;roundoff_type1&lt;&lt;std::endl;
<a name="l00731"></a>00731                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Type 2 roundoff = &quot;</span>&lt;&lt;roundoff_type2&lt;&lt;std::endl;
<a name="l00732"></a>00732                 <span class="keywordflow">throw</span> IntFailure(
<a name="l00733"></a>00733                     <span class="stringliteral">&quot;Roundoff error 1 prevents tolerance from being achieved in intGKP&quot;</span>);
<a name="l00734"></a>00734             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error_type == 2) {
<a name="l00735"></a>00735                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Type 1 roundoff = &quot;</span>&lt;&lt;roundoff_type1&lt;&lt;std::endl;
<a name="l00736"></a>00736                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Type 2 roundoff = &quot;</span>&lt;&lt;roundoff_type2&lt;&lt;std::endl;
<a name="l00737"></a>00737                 <span class="keywordflow">throw</span> IntFailure(
<a name="l00738"></a>00738                     <span class="stringliteral">&quot;Roundoff error 2 prevents tolerance from being achieved in intGKP&quot;</span>);
<a name="l00739"></a>00739             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error_type == 3) {
<a name="l00740"></a>00740                 <span class="keywordflow">throw</span> IntFailure(
<a name="l00741"></a>00741                     <span class="stringliteral">&quot;Bad integrand behavior found in the integration interval in intGKP&quot;</span>);
<a name="l00742"></a>00742             }
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00746"></a>00746         <span class="keyword">struct </span>AuxFunc1 : <span class="comment">// f(1/x-1) for int(a..infinity)</span>
<a name="l00747"></a>00747             <span class="keyword">public</span> std::unary_function&lt;typename UF::argument_type,
<a name="l00748"></a>00748             typename UF::result_type&gt; 
<a name="l00749"></a>00749         {
<a name="l00750"></a>00750         <span class="keyword">public</span>:
<a name="l00751"></a>00751             AuxFunc1(<span class="keyword">const</span> UF&amp; _f) : <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a>(_f) {}
<a name="l00752"></a>00752             <span class="keyword">typename</span> UF::result_type operator()(
<a name="l00753"></a>00753                 <span class="keyword">typename</span> UF::argument_type x)<span class="keyword"> const </span>
<a name="l00754"></a>00754 <span class="keyword">            </span>{ <span class="keywordflow">return</span> <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a>(1./x-1.)/(x*x); }
<a name="l00755"></a>00755         <span class="keyword">private</span>:
<a name="l00756"></a><a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">00756</a>             <span class="keyword">const</span> UF&amp; <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a>;
<a name="l00757"></a>00757         };
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00760"></a>00760         AuxFunc1&lt;UF&gt; <span class="keyword">inline</span> Aux1(<span class="keyword">const</span> UF&amp; uf) 
<a name="l00761"></a>00761         { <span class="keywordflow">return</span> AuxFunc1&lt;UF&gt;(uf); }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763         <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00764"></a>00764         <span class="keyword">struct </span>AuxFunc2 : <span class="comment">// f(1/x+1) for int(-infinity..b)</span>
<a name="l00765"></a>00765             <span class="keyword">public</span> std::unary_function&lt;typename UF::argument_type,
<a name="l00766"></a>00766             typename UF::result_type&gt; 
<a name="l00767"></a>00767         {
<a name="l00768"></a>00768         <span class="keyword">public</span>:
<a name="l00769"></a>00769             AuxFunc2(<span class="keyword">const</span> UF&amp; _f) : <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a>(_f) {}
<a name="l00770"></a>00770             <span class="keyword">typename</span> UF::result_type operator()(
<a name="l00771"></a>00771                 <span class="keyword">typename</span> UF::argument_type x)<span class="keyword"> const </span>
<a name="l00772"></a>00772 <span class="keyword">            </span>{ <span class="keywordflow">return</span> <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a>(1./x+1.)/(x*x); }
<a name="l00773"></a>00773         <span class="keyword">private</span>:
<a name="l00774"></a>00774             <span class="keyword">const</span> UF&amp; <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a>;
<a name="l00775"></a>00775         };
<a name="l00776"></a>00776 
<a name="l00777"></a>00777         <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; AuxFunc2&lt;UF&gt; 
<a name="l00778"></a>00778         <span class="keyword">inline</span> Aux2(<span class="keyword">const</span> UF&amp; uf) 
<a name="l00779"></a>00779         { <span class="keywordflow">return</span> AuxFunc2&lt;UF&gt;(uf); }
<a name="l00780"></a>00780     } <span class="comment">// anonymous namespace</span>
<a name="l00781"></a>00781 
<a name="l00783"></a>00783     <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00784"></a><a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1">00784</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> UF::result_type <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(
<a name="l00785"></a>00785         <span class="keyword">const</span> UF&amp; func,  
<a name="l00786"></a>00786         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename UF::result_type&gt;</a>&amp; reg, 
<a name="l00787"></a>00787         <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>, 
<a name="l00788"></a>00788         <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>  
<a name="l00789"></a>00789     )
<a name="l00790"></a>00790     {
<a name="l00791"></a>00791         <span class="keyword">typedef</span> <span class="keyword">typename</span> UF::result_type T;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;start int1d: &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()&lt;&lt;<span class="stringliteral">&quot;..&quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()&lt;&lt;std::endl;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordflow">if</span> ((reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>() &lt;= -<a class="code" href="namespacegalsim_1_1integ.html#ac48378074a01f187e7df24157f2f8119" title="Anything larger than this is treated as infinity.">MOCK_INF2</a> &amp;&amp; reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>() &gt; 0) ||
<a name="l00796"></a>00796             (reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>() &gt;= <a class="code" href="namespacegalsim_1_1integ.html#ac48378074a01f187e7df24157f2f8119" title="Anything larger than this is treated as infinity.">MOCK_INF2</a> &amp;&amp; reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>() &lt; 0)) { 
<a name="l00797"></a>00797             reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#ada5d8c79a86f8b7092b635a8a26c2b5d" title="Add a split point to the current list to be used by the next subDivide call.">addSplit</a>(0);
<a name="l00798"></a>00798         }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         <span class="keywordflow">if</span> (reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a76c9e34358d7289a04115437e89c0de0" title="Get the number of split points currently set.">getNSplit</a>() &gt; 0) {
<a name="l00801"></a>00801             std::vector&lt;IntRegion&lt;T&gt; &gt; children;
<a name="l00802"></a>00802             reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a178bdfcc6af29942689d40b56308fcd2" title="Subdivide a region according to the current split points or biset.">subDivide</a>(children);
<a name="l00803"></a>00803             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Subdivided into &quot;</span>&lt;&lt;children.size()&lt;&lt;<span class="stringliteral">&quot; children\n&quot;</span>;
<a name="l00804"></a>00804             T answer=0;
<a name="l00805"></a>00805             T err=0;
<a name="l00806"></a>00806             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;children.size();i++) {
<a name="l00807"></a>00807                 <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a>&amp; child = children[i];
<a name="l00808"></a>00808                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;i = &quot;</span>&lt;&lt;i;
<a name="l00809"></a>00809                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;: bounds = &quot;</span>&lt;&lt;child.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()&lt;&lt;
<a name="l00810"></a>00810                     <span class="charliteral">&apos;,&apos;</span>&lt;&lt;child.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()&lt;&lt;std::endl;
<a name="l00811"></a>00811                 answer += <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(func,child,relerr,abserr);
<a name="l00812"></a>00812                 err += child.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b" title="Get the current error estimate.">getErr</a>();
<a name="l00813"></a>00813                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;subint = &quot;</span>&lt;&lt;child.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a4b27b64838fdff040f3668d0dcf01675" title="Get the current estimate of the integral over the region.">getArea</a>()&lt;&lt;
<a name="l00814"></a>00814                     <span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;child.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b" title="Get the current error estimate.">getErr</a>()&lt;&lt;std::endl;
<a name="l00815"></a>00815             }
<a name="l00816"></a>00816             reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a6657e1acd462fd33f4a5e6ded48bfd62" title="Set a new estimate of the area and error.">setArea</a>(answer,err);
<a name="l00817"></a>00817             <span class="keywordflow">return</span> answer;
<a name="l00818"></a>00818         } <span class="keywordflow">else</span> {
<a name="l00819"></a>00819             <span class="keywordflow">if</span> (reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>() &lt;= -<a class="code" href="namespacegalsim_1_1integ.html#ac48378074a01f187e7df24157f2f8119" title="Anything larger than this is treated as infinity.">MOCK_INF2</a>) {
<a name="l00820"></a>00820                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;left = -infinity, right = &quot;</span>&lt;&lt;
<a name="l00821"></a>00821                     reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()&lt;&lt;std::endl;
<a name="l00822"></a>00822                 assert(reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>() &lt;= 0.);
<a name="l00823"></a>00823                 <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a> modreg(1./(reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()-1.),0.,reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a34438b9e684c31d58b07870c546f74c8">dbgout</a>);
<a name="l00824"></a>00824                 <span class="keywordflow">if</span> (reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1fb312aed660972beca41b4c599a9f18">fxmap</a>) modreg.useFXMap();
<a name="l00825"></a>00825                 intGKP(Aux2&lt;UF&gt;(func),modreg,relerr,abserr);
<a name="l00826"></a>00826                 reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a6657e1acd462fd33f4a5e6ded48bfd62" title="Set a new estimate of the area and error.">setArea</a>(modreg.getArea(),modreg.getErr());
<a name="l00827"></a>00827             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>() &gt;= <a class="code" href="namespacegalsim_1_1integ.html#ac48378074a01f187e7df24157f2f8119" title="Anything larger than this is treated as infinity.">MOCK_INF2</a>) {
<a name="l00828"></a>00828                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;left = &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()&lt;&lt;<span class="stringliteral">&quot;, right = infinity\n&quot;</span>;
<a name="l00829"></a>00829                 assert(reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>() &gt;= 0.);
<a name="l00830"></a>00830                 <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;T&gt;</a> modreg(0.,1./(reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()+1.),reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a34438b9e684c31d58b07870c546f74c8">dbgout</a>);
<a name="l00831"></a>00831                 <span class="keywordflow">if</span> (reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1fb312aed660972beca41b4c599a9f18">fxmap</a>) modreg.useFXMap();
<a name="l00832"></a>00832                 intGKP(Aux1&lt;UF&gt;(func),modreg,relerr,abserr);
<a name="l00833"></a>00833                 reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a6657e1acd462fd33f4a5e6ded48bfd62" title="Set a new estimate of the area and error.">setArea</a>(modreg.getArea(),modreg.getErr());
<a name="l00834"></a>00834             } <span class="keywordflow">else</span> {
<a name="l00835"></a>00835                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;left = &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>();
<a name="l00836"></a>00836                 <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;, right = &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()&lt;&lt;std::endl;
<a name="l00837"></a>00837                 intGKP(func,reg,relerr,abserr);
<a name="l00838"></a>00838             }
<a name="l00839"></a>00839             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;done int1d  answer = &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a4b27b64838fdff040f3668d0dcf01675" title="Get the current estimate of the integral over the region.">getArea</a>();
<a name="l00840"></a>00840             <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b" title="Get the current error estimate.">getErr</a>()&lt;&lt;std::endl;
<a name="l00841"></a>00841             <span class="keywordflow">return</span> reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a4b27b64838fdff040f3668d0dcf01675" title="Get the current estimate of the integral over the region.">getArea</a>();
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844 
<a name="l00846"></a>00846     <span class="keyword">template</span> &lt;<span class="keyword">class</span> UF&gt; 
<a name="l00847"></a><a class="code" href="namespacegalsim_1_1integ.html#a1bae913554d895d6c701dab5cb605397">00847</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> UF::result_type <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(
<a name="l00848"></a>00848         <span class="keyword">const</span> UF&amp; func,  
<a name="l00849"></a>00849         <span class="keyword">typename</span> UF::result_type min, 
<a name="l00850"></a>00850         <span class="keyword">typename</span> UF::result_type max, 
<a name="l00851"></a>00851         <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>, 
<a name="l00852"></a>00852         <span class="keyword">const</span> <span class="keyword">typename</span> UF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>  
<a name="l00853"></a>00853     )
<a name="l00854"></a>00854     {
<a name="l00855"></a>00855         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename UF::result_type&gt;</a> reg(min,max);
<a name="l00856"></a>00856         <span class="keywordflow">return</span> <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(func,reg,relerr,abserr); 
<a name="l00857"></a>00857     }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     <span class="keyword">namespace </span>{
<a name="l00860"></a>00860         <span class="keyword">template</span> &lt;<span class="keyword">class</span> BF, <span class="keyword">class</span> YREG&gt; 
<a name="l00861"></a>00861         <span class="keyword">class </span>Int2DAuxType : 
<a name="l00862"></a>00862             <span class="keyword">public</span> std::unary_function&lt;typename BF::first_argument_type,typename BF::result_type&gt; 
<a name="l00863"></a>00863         {
<a name="l00864"></a>00864         <span class="keyword">public</span>:
<a name="l00865"></a>00865             Int2DAuxType(<span class="keyword">const</span> BF&amp; _func, <span class="keyword">const</span> YREG&amp; _yreg,
<a name="l00866"></a>00866                          <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; _relerr,
<a name="l00867"></a>00867                          <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; _abserr) :
<a name="l00868"></a>00868                 func(_func),<a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>(_yreg),relerr(_relerr),abserr(_abserr) 
<a name="l00869"></a>00869             {}
<a name="l00870"></a>00870 
<a name="l00871"></a>00871             <span class="keyword">typename</span> BF::result_type operator()(
<a name="l00872"></a>00872                 <span class="keyword">typename</span> BF::first_argument_type x)<span class="keyword"> const </span>
<a name="l00873"></a>00873 <span class="keyword">            </span>{
<a name="l00874"></a>00874                 <span class="keyword">typename</span> YREG::result_type tempreg = <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>(x);
<a name="l00875"></a>00875                 <span class="keyword">typename</span> BF::result_type result = 
<a name="l00876"></a>00876                     <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(bind21(func,x),tempreg,relerr,abserr);
<a name="l00877"></a>00877                 <a class="code" href="_int_8h.html#a3930e446fb38950e18570ac555ae9bfb">integ_dbg3</a>&lt;&lt;<span class="stringliteral">&quot;Evaluated int2dAux at x = &quot;</span>&lt;&lt;x;
<a name="l00878"></a>00878                 <a class="code" href="_int_8h.html#a3930e446fb38950e18570ac555ae9bfb">integ_dbg3</a>&lt;&lt;<span class="stringliteral">&quot;: f = &quot;</span>&lt;&lt;result&lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;tempreg.getErr()&lt;&lt;std::endl;
<a name="l00879"></a>00879                 <span class="keywordflow">return</span> result;
<a name="l00880"></a>00880             } 
<a name="l00881"></a>00881 
<a name="l00882"></a>00882         <span class="keyword">private</span>:
<a name="l00883"></a><a class="code" href="_int_8h.html#ac6eeed7beb92b341a701bdeaeaa95de8">00883</a>             <span class="keyword">const</span> BF&amp; func;
<a name="l00884"></a><a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">00884</a>             <span class="keyword">const</span> YREG&amp; <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>;
<a name="l00885"></a><a class="code" href="_int_8h.html#a0e9f6681c910ef2d85e1d0efae6a4a2d">00885</a>             <span class="keyword">typename</span> BF::result_type relerr,abserr;
<a name="l00886"></a>00886         };
<a name="l00887"></a>00887     } <span class="comment">// anonymous namespace</span>
<a name="l00888"></a>00888 
<a name="l00890"></a>00890     <span class="keyword">template</span> &lt;<span class="keyword">class</span> BF, <span class="keyword">class</span> YREG&gt; 
<a name="l00891"></a><a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52">00891</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> BF::result_type <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(
<a name="l00892"></a>00892         <span class="keyword">const</span> BF&amp; func,  
<a name="l00893"></a>00893         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename BF::result_type&gt;</a>&amp; reg,  
<a name="l00894"></a>00894         <span class="keyword">const</span> YREG&amp; <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>, 
<a name="l00895"></a>00895         <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>, 
<a name="l00896"></a>00896         <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>  
<a name="l00897"></a>00897     )
<a name="l00898"></a>00898     {
<a name="l00899"></a>00899         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Starting int2d: range = &quot;</span>;
<a name="l00900"></a>00900         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()&lt;&lt;<span class="stringliteral">&quot;..&quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()&lt;&lt;std::endl;
<a name="l00901"></a>00901         Int2DAuxType&lt;BF,YREG&gt; faux(func,yreg,relerr*1.e-3,abserr*1.e-3);
<a name="l00902"></a>00902         <span class="keyword">typename</span> BF::result_type answer = <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(faux,reg,relerr,abserr);
<a name="l00903"></a>00903         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;done int2d  answer = &quot;</span>&lt;&lt;answer&lt;&lt;
<a name="l00904"></a>00904             <span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b" title="Get the current error estimate.">getErr</a>()&lt;&lt;std::endl;
<a name="l00905"></a>00905         <span class="keywordflow">return</span> answer;
<a name="l00906"></a>00906     }
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     <span class="keyword">namespace </span>{
<a name="l00909"></a>00909         <span class="keyword">template</span> &lt;<span class="keyword">class</span> TF, <span class="keyword">class</span> YREG, <span class="keyword">class</span> ZREG&gt; 
<a name="l00910"></a>00910         <span class="keyword">class </span>Int3DAuxType : 
<a name="l00911"></a>00911             <span class="keyword">public</span> std::unary_function&lt;typename TF::firstof3_argument_type,typename TF::result_type&gt; 
<a name="l00912"></a>00912         {
<a name="l00913"></a>00913         <span class="keyword">public</span>:
<a name="l00914"></a>00914             Int3DAuxType(<span class="keyword">const</span> TF&amp; _func, <span class="keyword">const</span> YREG&amp; _yreg, <span class="keyword">const</span> ZREG&amp; _zreg, 
<a name="l00915"></a>00915                          <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; _relerr,
<a name="l00916"></a>00916                          <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; _abserr) :
<a name="l00917"></a>00917                 func(_func),<a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>(_yreg),<a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">zreg</a>(_zreg),relerr(_relerr),abserr(_abserr) 
<a name="l00918"></a>00918             {}
<a name="l00919"></a>00919 
<a name="l00920"></a>00920             <span class="keyword">typename</span> TF::result_type operator()(
<a name="l00921"></a>00921                 <span class="keyword">typename</span> TF::firstof3_argument_type x)<span class="keyword"> const </span>
<a name="l00922"></a>00922 <span class="keyword">            </span>{
<a name="l00923"></a>00923                 <span class="keyword">typename</span> YREG::result_type tempreg = <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>(x);
<a name="l00924"></a>00924                 <span class="keyword">typename</span> TF::result_type result = 
<a name="l00925"></a>00925                     <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(bind31(func,x),tempreg,bind21(<a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">zreg</a>,x),relerr,abserr);
<a name="l00926"></a>00926                 <a class="code" href="_int_8h.html#a3930e446fb38950e18570ac555ae9bfb">integ_dbg3</a>&lt;&lt;<span class="stringliteral">&quot;Evaluated int3dAux at x = &quot;</span>&lt;&lt;x;
<a name="l00927"></a>00927                 <a class="code" href="_int_8h.html#a3930e446fb38950e18570ac555ae9bfb">integ_dbg3</a>&lt;&lt;<span class="stringliteral">&quot;: f = &quot;</span>&lt;&lt;result&lt;&lt;<span class="stringliteral">&quot; +- &quot;</span>&lt;&lt;tempreg.getErr()&lt;&lt;std::endl;
<a name="l00928"></a>00928                 <span class="keywordflow">return</span> result;
<a name="l00929"></a>00929             }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="keyword">private</span>:
<a name="l00932"></a>00932             <span class="keyword">const</span> TF&amp; func;
<a name="l00933"></a>00933             <span class="keyword">const</span> YREG&amp; <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>;
<a name="l00934"></a><a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">00934</a>             <span class="keyword">const</span> ZREG&amp; <a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">zreg</a>;
<a name="l00935"></a>00935             <span class="keyword">typename</span> TF::result_type relerr,abserr;
<a name="l00936"></a>00936         };
<a name="l00937"></a>00937     } <span class="comment">// anonymous namespace</span>
<a name="l00938"></a>00938 
<a name="l00940"></a>00940     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TF, <span class="keyword">class</span> YREG, <span class="keyword">class</span> ZREG&gt; 
<a name="l00941"></a><a class="code" href="namespacegalsim_1_1integ.html#aa70af0787c498502df7bfc6f634add94">00941</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> TF::result_type <a class="code" href="namespacegalsim_1_1integ.html#aa70af0787c498502df7bfc6f634add94" title="Perform a 3-dimensional integral.">int3d</a>(
<a name="l00942"></a>00942         <span class="keyword">const</span> TF&amp; func,  
<a name="l00943"></a>00943         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a>&amp; reg,  
<a name="l00944"></a>00944         <span class="keyword">const</span> YREG&amp; <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>, 
<a name="l00945"></a>00945         <span class="keyword">const</span> ZREG&amp; <a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">zreg</a>, 
<a name="l00946"></a>00946         <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>, 
<a name="l00947"></a>00947         <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>  
<a name="l00948"></a>00948     )
<a name="l00949"></a>00949     {
<a name="l00950"></a>00950         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;Starting int3d: range = &quot;</span>;
<a name="l00951"></a>00951         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a356e250d23448cf12b373602e31cf34a" title="Get the left end of the region.">left</a>()&lt;&lt;<span class="stringliteral">&quot;..&quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a3123d955cc1425adc11363362ca85aae" title="Get the right end of the region.">right</a>()&lt;&lt;std::endl;
<a name="l00952"></a>00952         Int3DAuxType&lt;TF,YREG,ZREG&gt; faux(
<a name="l00953"></a>00953             func,yreg,zreg,relerr*1.e-3,abserr*1.e-3);
<a name="l00954"></a>00954         <span class="keyword">typename</span> TF::result_type answer = <a class="code" href="namespacegalsim_1_1integ.html#af4672548c9db35a5c783504d86b5d0d1" title="Perform a 1-dimensional integral using an IntRegion.">int1d</a>(faux,reg,relerr,abserr);
<a name="l00955"></a>00955         <a class="code" href="_int_8h.html#a18b574beefe6ea98797c91eb6045a739">integ_dbg2</a>&lt;&lt;<span class="stringliteral">&quot;done int3d  answer = &quot;</span>&lt;&lt;answer&lt;&lt;
<a name="l00956"></a>00956             <span class="stringliteral">&quot;+- &quot;</span>&lt;&lt;reg.<a class="code" href="structgalsim_1_1integ_1_1_int_region.html#a1e87299b25c071b8e01abb472c2b056b" title="Get the current error estimate.">getErr</a>()&lt;&lt;std::endl;
<a name="l00957"></a>00957         <span class="keywordflow">return</span> answer;
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="comment">// Helpers for constant regions for int2d, int3d:</span>
<a name="l00961"></a>00961 
<a name="l00962"></a>00962     <span class="keyword">namespace </span>{
<a name="l00963"></a>00963         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
<a name="l00964"></a>00964         <span class="keyword">struct </span>ConstantReg1 : 
<a name="l00965"></a>00965             <span class="keyword">public</span> std::unary_function&lt;T, IntRegion&lt;T&gt; &gt;
<a name="l00966"></a>00966         {
<a name="l00967"></a>00967             ConstantReg1(T a,T b) : <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>(a,b) {}
<a name="l00968"></a>00968             ConstantReg1(<span class="keyword">const</span> IntRegion&lt;T&gt;&amp; r) : <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>(r) {}
<a name="l00969"></a>00969             IntRegion&lt;T&gt; operator()(T x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>; }
<a name="l00970"></a><a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">00970</a>             IntRegion&lt;T&gt; <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>;
<a name="l00971"></a>00971         };
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
<a name="l00974"></a>00974         <span class="keyword">struct </span>ConstantReg2 : 
<a name="l00975"></a>00975             <span class="keyword">public</span> std::binary_function&lt;T, T, IntRegion&lt;T&gt; &gt;
<a name="l00976"></a>00976         {
<a name="l00977"></a>00977             ConstantReg2(T a,T b) : <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>(a,b) {}
<a name="l00978"></a>00978             ConstantReg2(<span class="keyword">const</span> IntRegion&lt;T&gt;&amp; r) : <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>(r) {}
<a name="l00979"></a>00979             IntRegion&lt;T&gt; operator()(T x, T y)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>; }
<a name="l00980"></a>00980             IntRegion&lt;T&gt; <a class="code" href="_int_8h.html#a79e3b453d2571ed14110a426a914785a">ir</a>;
<a name="l00981"></a>00981         };
<a name="l00982"></a>00982     } <span class="comment">// anonymous namespace</span>
<a name="l00983"></a>00983 
<a name="l00986"></a>00986     <span class="keyword">template</span> &lt;<span class="keyword">class</span> BF&gt; 
<a name="l00987"></a><a class="code" href="namespacegalsim_1_1integ.html#a92cb6d1065bb32f8c0898acf902be104">00987</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> BF::result_type <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(
<a name="l00988"></a>00988         <span class="keyword">const</span> BF&amp; func,
<a name="l00989"></a>00989         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename BF::result_type&gt;</a>&amp; reg,
<a name="l00990"></a>00990         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename BF::result_type&gt;</a>&amp; <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>,
<a name="l00991"></a>00991         <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>,
<a name="l00992"></a>00992         <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>)
<a name="l00993"></a>00993     { 
<a name="l00994"></a>00994         <span class="keywordflow">return</span> <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(
<a name="l00995"></a>00995             func,reg,
<a name="l00996"></a>00996             ConstantReg1&lt;typename BF::result_type&gt;(yreg),
<a name="l00997"></a>00997             relerr,abserr); 
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999 
<a name="l01002"></a>01002     <span class="keyword">template</span> &lt;<span class="keyword">class</span> BF&gt;
<a name="l01003"></a><a class="code" href="namespacegalsim_1_1integ.html#ac0d8325484d1569b52ae2a9b9b2762f6">01003</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> BF::result_type <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(
<a name="l01004"></a>01004         <span class="keyword">const</span> BF&amp; func,
<a name="l01005"></a>01005         <span class="keyword">typename</span> BF::result_type xmin, <span class="keyword">typename</span> BF::result_type xmax, 
<a name="l01006"></a>01006         <span class="keyword">typename</span> BF::result_type ymin, <span class="keyword">typename</span> BF::result_type ymax, 
<a name="l01007"></a>01007         <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>,
<a name="l01008"></a>01008         <span class="keyword">const</span> <span class="keyword">typename</span> BF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>)
<a name="l01009"></a>01009     { 
<a name="l01010"></a>01010         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename BF::result_type&gt;</a> xreg(xmin,xmax);
<a name="l01011"></a>01011         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename BF::result_type&gt;</a> <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>(ymin,ymax);
<a name="l01012"></a>01012         <span class="keywordflow">return</span> <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(func,xreg,yreg,relerr,abserr);
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014 
<a name="l01017"></a>01017     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TF&gt; 
<a name="l01018"></a><a class="code" href="namespacegalsim_1_1integ.html#aad150be6f85721408709d5b07f1ca57a">01018</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> TF::result_type <a class="code" href="namespacegalsim_1_1integ.html#aa70af0787c498502df7bfc6f634add94" title="Perform a 3-dimensional integral.">int3d</a>(
<a name="l01019"></a>01019         <span class="keyword">const</span> TF&amp; func,
<a name="l01020"></a>01020         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a>&amp; reg,
<a name="l01021"></a>01021         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a>&amp; <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>,
<a name="l01022"></a>01022         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a>&amp; <a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">zreg</a>,
<a name="l01023"></a>01023         <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>,
<a name="l01024"></a>01024         <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>)
<a name="l01025"></a>01025     {
<a name="l01026"></a>01026         <span class="keywordflow">return</span> <a class="code" href="namespacegalsim_1_1integ.html#aa70af0787c498502df7bfc6f634add94" title="Perform a 3-dimensional integral.">int3d</a>(
<a name="l01027"></a>01027             func,reg,
<a name="l01028"></a>01028             ConstantReg1&lt;typename TF::result_type&gt;(yreg),
<a name="l01029"></a>01029             ConstantReg2&lt;typename TF::result_type&gt;(zreg),
<a name="l01030"></a>01030             relerr,abserr);
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032 
<a name="l01035"></a>01035     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TF&gt;
<a name="l01036"></a><a class="code" href="namespacegalsim_1_1integ.html#a29e72db7f19f65738c11f0be0365cfa3">01036</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> TF::result_type <a class="code" href="namespacegalsim_1_1integ.html#aa70af0787c498502df7bfc6f634add94" title="Perform a 3-dimensional integral.">int3d</a>(
<a name="l01037"></a>01037         <span class="keyword">const</span> TF&amp; func,
<a name="l01038"></a>01038         <span class="keyword">typename</span> TF::result_type xmin, <span class="keyword">typename</span> TF::result_type xmax, 
<a name="l01039"></a>01039         <span class="keyword">typename</span> TF::result_type ymin, <span class="keyword">typename</span> TF::result_type ymax, 
<a name="l01040"></a>01040         <span class="keyword">typename</span> TF::result_type zmin, <span class="keyword">typename</span> TF::result_type zmax, 
<a name="l01041"></a>01041         <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; relerr=<a class="code" href="namespacegalsim_1_1integ.html#ac85ff48c348e30d89d01749bf3f55aa5" title="The default target relative error if not specified.">DEFRELERR</a>,
<a name="l01042"></a>01042         <span class="keyword">const</span> <span class="keyword">typename</span> TF::result_type&amp; abserr=<a class="code" href="namespacegalsim_1_1integ.html#a9a752a0cd3734acfd88aad16b3d610b4" title="The default target absolute error if not specified.">DEFABSERR</a>)
<a name="l01043"></a>01043     { 
<a name="l01044"></a>01044         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a> xreg(xmin,xmax);
<a name="l01045"></a>01045         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a> <a class="code" href="_int_8h.html#a3f475694855b6e1004b9d14e7416e9e0">yreg</a>(ymin,ymax);
<a name="l01046"></a>01046         <a class="code" href="structgalsim_1_1integ_1_1_int_region.html" title="A type that encapsulates everything known about the integral in a region.">IntRegion&lt;typename TF::result_type&gt;</a> <a class="code" href="_int_8h.html#a46bfdbb22db5417f40fcdf929af0ab4d">zreg</a>(zmin,zmax);
<a name="l01047"></a>01047         <span class="keywordflow">return</span> <a class="code" href="namespacegalsim_1_1integ.html#a7bb039d29fe14e3c9df751e1fb03ca52" title="Perform a 2-dimensional integral.">int2d</a>(func,xreg,yreg,zreg,relerr,abserr);
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 }} 
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="preprocessor">#endif</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1</small></address>
</body>
</html>

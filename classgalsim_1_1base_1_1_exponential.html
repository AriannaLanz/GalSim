<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: galsim.base.Exponential Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classgalsim_1_1base_1_1_exponential.html">Exponential</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgalsim_1_1base_1_1_exponential-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">galsim.base.Exponential Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class describing an exponential profile.  
 <a href="classgalsim_1_1base_1_1_exponential.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for galsim.base.Exponential:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgalsim_1_1base_1_1_exponential.png" usemap="#galsim.base.Exponential_map" alt=""/>
  <map id="galsim.base.Exponential_map" name="galsim.base.Exponential_map">
<area href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. " alt="galsim.base.GSObject" shape="rect" coords="0,56,147,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ac15d1aae547669a99fe61d69c463b8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_exponential.html#a9ac15d1aae547669a99fe61d69c463b8">__init__</a></td></tr>
<tr class="separator:a9ac15d1aae547669a99fe61d69c463b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0508398c3b3f8ec6829d9866be77c7e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_exponential.html#a0508398c3b3f8ec6829d9866be77c7e2">getScaleRadius</a></td></tr>
<tr class="memdesc:a0508398c3b3f8ec6829d9866be77c7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scale radius for this <a class="el" href="classgalsim_1_1base_1_1_exponential.html" title="A class describing an exponential profile. ">Exponential</a> profile.  <a href="#a0508398c3b3f8ec6829d9866be77c7e2">More...</a><br/></td></tr>
<tr class="separator:a0508398c3b3f8ec6829d9866be77c7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573a5adaf2444150c2a62db4afef98fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_exponential.html#a573a5adaf2444150c2a62db4afef98fb">getHalfLightRadius</a></td></tr>
<tr class="memdesc:a573a5adaf2444150c2a62db4afef98fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the half light radius for this <a class="el" href="classgalsim_1_1base_1_1_exponential.html" title="A class describing an exponential profile. ">Exponential</a> profile.  <a href="#a573a5adaf2444150c2a62db4afef98fb">More...</a><br/></td></tr>
<tr class="separator:a573a5adaf2444150c2a62db4afef98fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f53aa19bbfcc16f980072ef07fc9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#abb2f53aa19bbfcc16f980072ef07fc9b">evaluateAtWavelength</a></td></tr>
<tr class="memdesc:abb2f53aa19bbfcc16f980072ef07fc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return profile at a given wavelength.  <a href="#abb2f53aa19bbfcc16f980072ef07fc9b">More...</a><br/></td></tr>
<tr class="separator:abb2f53aa19bbfcc16f980072ef07fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2781f482d5599469ba51aea46b5b82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ace2781f482d5599469ba51aea46b5b82">__add__</a></td></tr>
<tr class="separator:ace2781f482d5599469ba51aea46b5b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe7e40fdb14bfcab71133684685e5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a7cfe7e40fdb14bfcab71133684685e5f">__sub__</a></td></tr>
<tr class="separator:a7cfe7e40fdb14bfcab71133684685e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31d94eb1b6367d8034d4cd2c46cd94b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa31d94eb1b6367d8034d4cd2c46cd94b">__mul__</a></td></tr>
<tr class="memdesc:aa31d94eb1b6367d8034d4cd2c46cd94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the flux of the object by the given factor.  <a href="#aa31d94eb1b6367d8034d4cd2c46cd94b">More...</a><br/></td></tr>
<tr class="separator:aa31d94eb1b6367d8034d4cd2c46cd94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a27f25c7faffd8c29a45477abc21459"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a1a27f25c7faffd8c29a45477abc21459">__rmul__</a></td></tr>
<tr class="memdesc:a1a27f25c7faffd8c29a45477abc21459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * other.  <a href="#a1a27f25c7faffd8c29a45477abc21459">More...</a><br/></td></tr>
<tr class="separator:a1a27f25c7faffd8c29a45477abc21459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d9f8b408ee4582d170c760c533d98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a182d9f8b408ee4582d170c760c533d98">__div__</a></td></tr>
<tr class="memdesc:a182d9f8b408ee4582d170c760c533d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * (1/other)  <a href="#a182d9f8b408ee4582d170c760c533d98">More...</a><br/></td></tr>
<tr class="separator:a182d9f8b408ee4582d170c760c533d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf331fe434ce3c71b64ce2745d0b75ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#adf331fe434ce3c71b64ce2745d0b75ca">__truediv__</a></td></tr>
<tr class="memdesc:adf331fe434ce3c71b64ce2745d0b75ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to obj * (1/other)  <a href="#adf331fe434ce3c71b64ce2745d0b75ca">More...</a><br/></td></tr>
<tr class="separator:adf331fe434ce3c71b64ce2745d0b75ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b398d4b0fca70211e4a73f81ea7e1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa0b398d4b0fca70211e4a73f81ea7e1a">copy</a></td></tr>
<tr class="memdesc:aa0b398d4b0fca70211e4a73f81ea7e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of an object.  <a href="#aa0b398d4b0fca70211e4a73f81ea7e1a">More...</a><br/></td></tr>
<tr class="separator:aa0b398d4b0fca70211e4a73f81ea7e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab9d51f34703ced5be1592e112605ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a4ab9d51f34703ced5be1592e112605ff">maxK</a></td></tr>
<tr class="memdesc:a4ab9d51f34703ced5be1592e112605ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value of k beyond which aliasing can be neglected.  <a href="#a4ab9d51f34703ced5be1592e112605ff">More...</a><br/></td></tr>
<tr class="separator:a4ab9d51f34703ced5be1592e112605ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95676589d95590c2ce593adcf4f4198"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ab95676589d95590c2ce593adcf4f4198">nyquistScale</a></td></tr>
<tr class="memdesc:ab95676589d95590c2ce593adcf4f4198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Image pixel spacing that does not alias maxK.  <a href="#ab95676589d95590c2ce593adcf4f4198">More...</a><br/></td></tr>
<tr class="separator:ab95676589d95590c2ce593adcf4f4198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98091310691b1ecdd0d8bfacf48b73c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a98091310691b1ecdd0d8bfacf48b73c5">nyquistDx</a></td></tr>
<tr class="memdesc:a98091310691b1ecdd0d8bfacf48b73c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An obsolete synonym for <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ab95676589d95590c2ce593adcf4f4198" title="Returns Image pixel spacing that does not alias maxK. ">nyquistScale()</a>  <a href="#a98091310691b1ecdd0d8bfacf48b73c5">More...</a><br/></td></tr>
<tr class="separator:a98091310691b1ecdd0d8bfacf48b73c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5da3e499f3c00def5f7f54cab532f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae8b5da3e499f3c00def5f7f54cab532f">stepK</a></td></tr>
<tr class="memdesc:ae8b5da3e499f3c00def5f7f54cab532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sampling in k space necessary to avoid folding of image in x space.  <a href="#ae8b5da3e499f3c00def5f7f54cab532f">More...</a><br/></td></tr>
<tr class="separator:ae8b5da3e499f3c00def5f7f54cab532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f480514538e924d29af411563384a6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a4f480514538e924d29af411563384a6d">hasHardEdges</a></td></tr>
<tr class="memdesc:a4f480514538e924d29af411563384a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if there are any hard edges in the profile, which would require very small k spacing when working in the Fourier domain.  <a href="#a4f480514538e924d29af411563384a6d">More...</a><br/></td></tr>
<tr class="separator:a4f480514538e924d29af411563384a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109bc7c81be65f8fc5d5ec32e6d0c0df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a109bc7c81be65f8fc5d5ec32e6d0c0df">isAxisymmetric</a></td></tr>
<tr class="memdesc:a109bc7c81be65f8fc5d5ec32e6d0c0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if axially symmetric: affects efficiency of evaluation.  <a href="#a109bc7c81be65f8fc5d5ec32e6d0c0df">More...</a><br/></td></tr>
<tr class="separator:a109bc7c81be65f8fc5d5ec32e6d0c0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671c7778e707ab11a75a1f5877aa76ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a671c7778e707ab11a75a1f5877aa76ff">isAnalyticX</a></td></tr>
<tr class="memdesc:a671c7778e707ab11a75a1f5877aa76ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if real-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#a671c7778e707ab11a75a1f5877aa76ff">More...</a><br/></td></tr>
<tr class="separator:a671c7778e707ab11a75a1f5877aa76ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad883087f48bb56d90612d940dd60a7ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ad883087f48bb56d90612d940dd60a7ab">isAnalyticK</a></td></tr>
<tr class="memdesc:ad883087f48bb56d90612d940dd60a7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform.  <a href="#ad883087f48bb56d90612d940dd60a7ab">More...</a><br/></td></tr>
<tr class="separator:ad883087f48bb56d90612d940dd60a7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a0bb72927fce3c765a9580de656d1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a08a0bb72927fce3c765a9580de656d1a">centroid</a></td></tr>
<tr class="memdesc:a08a0bb72927fce3c765a9580de656d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (x, y) centroid of an object as a <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format. ">Position</a>.  <a href="#a08a0bb72927fce3c765a9580de656d1a">More...</a><br/></td></tr>
<tr class="separator:a08a0bb72927fce3c765a9580de656d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d8ce421ecd90080bdcaaf6890aed8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8">getFlux</a></td></tr>
<tr class="memdesc:a662d8ce421ecd90080bdcaaf6890aed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flux of the object.  <a href="#a662d8ce421ecd90080bdcaaf6890aed8">More...</a><br/></td></tr>
<tr class="separator:a662d8ce421ecd90080bdcaaf6890aed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30355af05f88c36f078099b6bb792e1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c">xValue</a></td></tr>
<tr class="memdesc:a30355af05f88c36f078099b6bb792e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the object at a chosen 2D position in real space.  <a href="#a30355af05f88c36f078099b6bb792e1c">More...</a><br/></td></tr>
<tr class="separator:a30355af05f88c36f078099b6bb792e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8652894487904b797d7752651b54507"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ac8652894487904b797d7752651b54507">kValue</a></td></tr>
<tr class="memdesc:ac8652894487904b797d7752651b54507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the object at a chosen 2D position in k space.  <a href="#ac8652894487904b797d7752651b54507">More...</a><br/></td></tr>
<tr class="separator:ac8652894487904b797d7752651b54507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f12b6158381ca5ef6da8e94f701f3e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a3f12b6158381ca5ef6da8e94f701f3e5">withFlux</a></td></tr>
<tr class="memdesc:a3f12b6158381ca5ef6da8e94f701f3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a different flux.  <a href="#a3f12b6158381ca5ef6da8e94f701f3e5">More...</a><br/></td></tr>
<tr class="separator:a3f12b6158381ca5ef6da8e94f701f3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5b330e1c7565a2bb56258127d6149"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a21a5b330e1c7565a2bb56258127d6149">withScaledFlux</a></td></tr>
<tr class="memdesc:a21a5b330e1c7565a2bb56258127d6149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with the flux scaled by the given flux ratio.  <a href="#a21a5b330e1c7565a2bb56258127d6149">More...</a><br/></td></tr>
<tr class="separator:a21a5b330e1c7565a2bb56258127d6149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1993652591ddc802b734186391b28894"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a1993652591ddc802b734186391b28894">setFlux</a></td></tr>
<tr class="memdesc:a1993652591ddc802b734186391b28894"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.withFlux(flux)  <a href="#a1993652591ddc802b734186391b28894">More...</a><br/></td></tr>
<tr class="separator:a1993652591ddc802b734186391b28894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4193645a9af52e7d54a044cafec8ab9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#af4193645a9af52e7d54a044cafec8ab9">scaleFlux</a></td></tr>
<tr class="memdesc:af4193645a9af52e7d54a044cafec8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj * flux_ratio.  <a href="#af4193645a9af52e7d54a044cafec8ab9">More...</a><br/></td></tr>
<tr class="separator:af4193645a9af52e7d54a044cafec8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582e45c3a235ce1be2f58bfb2070ef15"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a582e45c3a235ce1be2f58bfb2070ef15">expand</a></td></tr>
<tr class="memdesc:a582e45c3a235ce1be2f58bfb2070ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the linear size of the profile by the given scale factor, while preserving surface brightness.  <a href="#a582e45c3a235ce1be2f58bfb2070ef15">More...</a><br/></td></tr>
<tr class="separator:a582e45c3a235ce1be2f58bfb2070ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa412029f08750972b5714dc518eb0c94"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa412029f08750972b5714dc518eb0c94">createExpanded</a></td></tr>
<tr class="memdesc:aa412029f08750972b5714dc518eb0c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for expand(scale)  <a href="#aa412029f08750972b5714dc518eb0c94">More...</a><br/></td></tr>
<tr class="separator:aa412029f08750972b5714dc518eb0c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b3a054a09da3c729c3dade195b523c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa8b3a054a09da3c729c3dade195b523c">applyExpansion</a></td></tr>
<tr class="memdesc:aa8b3a054a09da3c729c3dade195b523c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.expand(scale).  <a href="#aa8b3a054a09da3c729c3dade195b523c">More...</a><br/></td></tr>
<tr class="separator:aa8b3a054a09da3c729c3dade195b523c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80b6924c48e9708dd9e475f3b48b5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f">dilate</a></td></tr>
<tr class="memdesc:a0e80b6924c48e9708dd9e475f3b48b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilate the linear size of the profile by the given scale factor, while preserving flux.  <a href="#a0e80b6924c48e9708dd9e475f3b48b5f">More...</a><br/></td></tr>
<tr class="separator:a0e80b6924c48e9708dd9e475f3b48b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21997fcb7ef6db0cea9d51a16498283"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ad21997fcb7ef6db0cea9d51a16498283">createDilated</a></td></tr>
<tr class="memdesc:ad21997fcb7ef6db0cea9d51a16498283"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for dilate(scale)  <a href="#ad21997fcb7ef6db0cea9d51a16498283">More...</a><br/></td></tr>
<tr class="separator:ad21997fcb7ef6db0cea9d51a16498283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4301c73bbc1491ebb170e64c509cadd5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a4301c73bbc1491ebb170e64c509cadd5">applyDilation</a></td></tr>
<tr class="memdesc:a4301c73bbc1491ebb170e64c509cadd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.dilate(scale).  <a href="#a4301c73bbc1491ebb170e64c509cadd5">More...</a><br/></td></tr>
<tr class="separator:a4301c73bbc1491ebb170e64c509cadd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac64da7ce1c4165ba048300fede29943"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943">magnify</a></td></tr>
<tr class="memdesc:aac64da7ce1c4165ba048300fede29943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness.  <a href="#aac64da7ce1c4165ba048300fede29943">More...</a><br/></td></tr>
<tr class="separator:aac64da7ce1c4165ba048300fede29943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c086513d5d569e6cd1c4269e83dd2d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ab1c086513d5d569e6cd1c4269e83dd2d">createMagnified</a></td></tr>
<tr class="memdesc:ab1c086513d5d569e6cd1c4269e83dd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for magnify(mu)  <a href="#ab1c086513d5d569e6cd1c4269e83dd2d">More...</a><br/></td></tr>
<tr class="separator:ab1c086513d5d569e6cd1c4269e83dd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d13b0238057f6d5d01f2681d91c09b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a9d13b0238057f6d5d01f2681d91c09b0">applyMagnification</a></td></tr>
<tr class="memdesc:a9d13b0238057f6d5d01f2681d91c09b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.magnify(mu)  <a href="#a9d13b0238057f6d5d01f2681d91c09b0">More...</a><br/></td></tr>
<tr class="separator:a9d13b0238057f6d5d01f2681d91c09b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ac16f75958b4a14246e944662ce3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#acc3ac16f75958b4a14246e944662ce3f">shear</a></td></tr>
<tr class="memdesc:acc3ac16f75958b4a14246e944662ce3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with an area-preserving shear applied to it.  <a href="#acc3ac16f75958b4a14246e944662ce3f">More...</a><br/></td></tr>
<tr class="separator:acc3ac16f75958b4a14246e944662ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c54a001124280ae550c57c8fdce3563"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a8c54a001124280ae550c57c8fdce3563">createSheared</a></td></tr>
<tr class="memdesc:a8c54a001124280ae550c57c8fdce3563"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for shear(shear)  <a href="#a8c54a001124280ae550c57c8fdce3563">More...</a><br/></td></tr>
<tr class="separator:a8c54a001124280ae550c57c8fdce3563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cc0094dcf470cfbff93d9830ab80bd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a85cc0094dcf470cfbff93d9830ab80bd">applyShear</a></td></tr>
<tr class="memdesc:a85cc0094dcf470cfbff93d9830ab80bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.shear(shear)  <a href="#a85cc0094dcf470cfbff93d9830ab80bd">More...</a><br/></td></tr>
<tr class="separator:a85cc0094dcf470cfbff93d9830ab80bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3feadf744ebeb19048ce5b0b85a1678"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae3feadf744ebeb19048ce5b0b85a1678">lens</a></td></tr>
<tr class="memdesc:ae3feadf744ebeb19048ce5b0b85a1678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with both a lensing shear and magnification applied to it.  <a href="#ae3feadf744ebeb19048ce5b0b85a1678">More...</a><br/></td></tr>
<tr class="separator:ae3feadf744ebeb19048ce5b0b85a1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d3432b800095e5cb949a64cded86d9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a48d3432b800095e5cb949a64cded86d9">createLensed</a></td></tr>
<tr class="memdesc:a48d3432b800095e5cb949a64cded86d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for lens(g1,g2,mu)  <a href="#a48d3432b800095e5cb949a64cded86d9">More...</a><br/></td></tr>
<tr class="separator:a48d3432b800095e5cb949a64cded86d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6f6f1096d1a1eb6b0a795ced21dde3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a3b6f6f1096d1a1eb6b0a795ced21dde3">applyLensing</a></td></tr>
<tr class="memdesc:a3b6f6f1096d1a1eb6b0a795ced21dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.lens(g1,g2,mu)  <a href="#a3b6f6f1096d1a1eb6b0a795ced21dde3">More...</a><br/></td></tr>
<tr class="separator:a3b6f6f1096d1a1eb6b0a795ced21dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1733c2288686dd72f5389ede87e8aac3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a1733c2288686dd72f5389ede87e8aac3">rotate</a></td></tr>
<tr class="memdesc:a1733c2288686dd72f5389ede87e8aac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate this object by an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> theta.  <a href="#a1733c2288686dd72f5389ede87e8aac3">More...</a><br/></td></tr>
<tr class="separator:a1733c2288686dd72f5389ede87e8aac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c29613e57067e6ba5ec7297e746cdc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a6c29613e57067e6ba5ec7297e746cdc4">createRotated</a></td></tr>
<tr class="memdesc:a6c29613e57067e6ba5ec7297e746cdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for rotate(theta)  <a href="#a6c29613e57067e6ba5ec7297e746cdc4">More...</a><br/></td></tr>
<tr class="separator:a6c29613e57067e6ba5ec7297e746cdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6236e3153f23f1201396369dd67f1c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ad6236e3153f23f1201396369dd67f1c7">applyRotation</a></td></tr>
<tr class="memdesc:ad6236e3153f23f1201396369dd67f1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.rotate(theta)  <a href="#ad6236e3153f23f1201396369dd67f1c7">More...</a><br/></td></tr>
<tr class="separator:ad6236e3153f23f1201396369dd67f1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3a8a6ccc44432106e64f1003e3daf6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#afe3a8a6ccc44432106e64f1003e3daf6">transform</a></td></tr>
<tr class="memdesc:afe3a8a6ccc44432106e64f1003e3daf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it.  <a href="#afe3a8a6ccc44432106e64f1003e3daf6">More...</a><br/></td></tr>
<tr class="separator:afe3a8a6ccc44432106e64f1003e3daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac545bacc95772067d082a68a282265e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ac545bacc95772067d082a68a282265e7">createTransformed</a></td></tr>
<tr class="memdesc:ac545bacc95772067d082a68a282265e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete sysnonym for <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#afe3a8a6ccc44432106e64f1003e3daf6" title="Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it...">transform()</a>  <a href="#ac545bacc95772067d082a68a282265e7">More...</a><br/></td></tr>
<tr class="separator:ac545bacc95772067d082a68a282265e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad491a1276fda07b148c6466d5dbd07b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ad491a1276fda07b148c6466d5dbd07b1">applyTransformation</a></td></tr>
<tr class="memdesc:ad491a1276fda07b148c6466d5dbd07b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.transform(...)  <a href="#ad491a1276fda07b148c6466d5dbd07b1">More...</a><br/></td></tr>
<tr class="separator:ad491a1276fda07b148c6466d5dbd07b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a4998b3d8ba6e13e9f0779e56f3697"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a17a4998b3d8ba6e13e9f0779e56f3697">shift</a></td></tr>
<tr class="memdesc:a17a4998b3d8ba6e13e9f0779e56f3697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a version of the current object shifted by some amount in real space.  <a href="#a17a4998b3d8ba6e13e9f0779e56f3697">More...</a><br/></td></tr>
<tr class="separator:a17a4998b3d8ba6e13e9f0779e56f3697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c05ef4b77187b6d02d877232e81126"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a96c05ef4b77187b6d02d877232e81126">createShifted</a></td></tr>
<tr class="memdesc:a96c05ef4b77187b6d02d877232e81126"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete synonym for shift(dx,dy)  <a href="#a96c05ef4b77187b6d02d877232e81126">More...</a><br/></td></tr>
<tr class="separator:a96c05ef4b77187b6d02d877232e81126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b547741eeec4086de9abe227dae9325"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a6b547741eeec4086de9abe227dae9325">applyShift</a></td></tr>
<tr class="memdesc:a6b547741eeec4086de9abe227dae9325"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an obsolete method that is roughly equivalent to obj = obj.shift(dx,dy)  <a href="#a6b547741eeec4086de9abe227dae9325">More...</a><br/></td></tr>
<tr class="separator:a6b547741eeec4086de9abe227dae9325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b346a8b438dedbc7f60a52220869d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8">draw</a></td></tr>
<tr class="memdesc:ae0b346a8b438dedbc7f60a52220869d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an Image of the object, with bounds optionally set by an input Image.  <a href="#ae0b346a8b438dedbc7f60a52220869d8">More...</a><br/></td></tr>
<tr class="separator:ae0b346a8b438dedbc7f60a52220869d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac334d2840ba3fa832988e998beca0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0">drawShoot</a></td></tr>
<tr class="memdesc:a42ac334d2840ba3fa832988e998beca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image of the object by shooting individual photons drawn from the surface brightness profile of the object.  <a href="#a42ac334d2840ba3fa832988e998beca0">More...</a><br/></td></tr>
<tr class="separator:a42ac334d2840ba3fa832988e998beca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa4ff2871a15f044689bdf3756fd918"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aafa4ff2871a15f044689bdf3756fd918">drawK</a></td></tr>
<tr class="memdesc:aafa4ff2871a15f044689bdf3756fd918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the k-space Images (real and imaginary parts) of the object, with bounds optionally set by input Images.  <a href="#aafa4ff2871a15f044689bdf3756fd918">More...</a><br/></td></tr>
<tr class="separator:aafa4ff2871a15f044689bdf3756fd918"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a52599607e0e66c8f85a3220791888a3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a52599607e0e66c8f85a3220791888a3b">SBProfile</a></td></tr>
<tr class="separator:a52599607e0e66c8f85a3220791888a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e54bb1d6a0c3619a1cecd8eff5aaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a8c0e54bb1d6a0c3619a1cecd8eff5aaa">noise</a></td></tr>
<tr class="separator:a8c0e54bb1d6a0c3619a1cecd8eff5aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbb0329cb393d4eb3e8b1d73db5cc60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#abbbb0329cb393d4eb3e8b1d73db5cc60">separable</a></td></tr>
<tr class="separator:abbbb0329cb393d4eb3e8b1d73db5cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d8545045968d8bfca471fefcc1c2ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a51d8545045968d8bfca471fefcc1c2ee">SED</a></td></tr>
<tr class="separator:a51d8545045968d8bfca471fefcc1c2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543c3fa387178c1dfeb8aee123ea5ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aa543c3fa387178c1dfeb8aee123ea5ba">wave_list</a></td></tr>
<tr class="separator:aa543c3fa387178c1dfeb8aee123ea5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class describing an exponential profile. </p>
<p>Surface brightness profile with I(r) propto exp[-r/scale_radius]. This is a special case of the <a class="el" href="classgalsim_1_1base_1_1_sersic.html" title="A class describing a Sersic profile. ">Sersic</a> profile, but is given a separate class since the Fourier transform has closed form and can be generated without lookup tables.</p>
<h2>Initialization </h2>
<p>An <a class="el" href="classgalsim_1_1base_1_1_exponential.html" title="A class describing an exponential profile. ">Exponential</a> can be initialized using one (and only one) of two possible size parameters: <code>scale_radius</code> or <code>half_light_radius</code>. Exactly one of these two is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half_light_radius</td><td>The half-light radius of the profile. Typically given in arcsec. [One of scale_radius or half_light_radius is required.] </td></tr>
    <tr><td class="paramname">scale_radius</td><td>The scale radius of the profile. Typically given in arcsec. [One of scale_radius or half_light_radius is required.] </td></tr>
    <tr><td class="paramname">flux</td><td>The flux (in photons) of the profile. [default: 1] </td></tr>
    <tr><td class="paramname">gsparams</td><td>An optional <a class="el" href="structgalsim_1_1_g_s_params.html">GSParams</a> argument. See the docstring for <a class="el" href="structgalsim_1_1_g_s_params.html">galsim.GSParams</a> for details. [default: None]</td></tr>
  </table>
  </dd>
</dl>
<h2>Methods </h2>
<p>In addition to the usual <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> methods, <a class="el" href="classgalsim_1_1base_1_1_exponential.html" title="A class describing an exponential profile. ">Exponential</a> has the following access methods: </p>
<pre class="fragment">r0 = exp_obj.getScaleRadius()
hlr = exp_obj.getHalfLightRadius()</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9ac15d1aae547669a99fe61d69c463b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Exponential.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>half_light_radius</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_radius</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gsparams</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace2781f482d5599469ba51aea46b5b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__add__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a182d9f8b408ee4582d170c760c533d98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__div__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to obj * (1/other) </p>

</div>
</div>
<a class="anchor" id="aa31d94eb1b6367d8034d4cd2c46cd94b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__mul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale the flux of the object by the given factor. </p>
<p>obj * flux_ratio is equivalent to obj.withScaledFlux(flux_ratio)</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount.</p>
<p>You can also multiply by an SED, which will create a ChromaticObject where the SED acts like a wavelength-dependent flux_ratio.</p>
<p>obj * sed is equivalent to galsim.Chromatic(obj, sed) </p>

</div>
</div>
<a class="anchor" id="a1a27f25c7faffd8c29a45477abc21459"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__rmul__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to obj * other. </p>

</div>
</div>
<a class="anchor" id="a7cfe7e40fdb14bfcab71133684685e5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__sub__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf331fe434ce3c71b64ce2745d0b75ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.__truediv__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to obj * (1/other) </p>

</div>
</div>
<a class="anchor" id="a4301c73bbc1491ebb170e64c509cadd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyDilation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.dilate(scale). </p>

</div>
</div>
<a class="anchor" id="aa8b3a054a09da3c729c3dade195b523c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyExpansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.expand(scale). </p>

</div>
</div>
<a class="anchor" id="a3b6f6f1096d1a1eb6b0a795ced21dde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyLensing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.lens(g1,g2,mu) </p>

</div>
</div>
<a class="anchor" id="a9d13b0238057f6d5d01f2681d91c09b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyMagnification </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.magnify(mu) </p>

</div>
</div>
<a class="anchor" id="ad6236e3153f23f1201396369dd67f1c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyRotation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.rotate(theta) </p>

</div>
</div>
<a class="anchor" id="a85cc0094dcf470cfbff93d9830ab80bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyShear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.shear(shear) </p>

</div>
</div>
<a class="anchor" id="a6b547741eeec4086de9abe227dae9325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyShift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.shift(dx,dy) </p>

</div>
</div>
<a class="anchor" id="ad491a1276fda07b148c6466d5dbd07b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.applyTransformation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.transform(...) </p>

</div>
</div>
<a class="anchor" id="a08a0bb72927fce3c765a9580de656d1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.centroid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (x, y) centroid of an object as a <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format. ">Position</a>. </p>

</div>
</div>
<a class="anchor" id="aa0b398d4b0fca70211e4a73f81ea7e1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of an object. </p>
<p>This preserves the original type of the object, so if the caller is a <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2-D Gaussian surface brightness profile. ">Gaussian</a> (for example), the copy will also be a <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2-D Gaussian surface brightness profile. ">Gaussian</a>, and can thus call the methods that are not in <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>, but are in <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2-D Gaussian surface brightness profile. ">Gaussian</a> (e.g. getSigma()). However, not necessarily all instance attributes will be copied across (e.g. the interpolant stored by an OpticalPSF object). </p>

</div>
</div>
<a class="anchor" id="ad21997fcb7ef6db0cea9d51a16498283"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createDilated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for dilate(scale) </p>

</div>
</div>
<a class="anchor" id="aa412029f08750972b5714dc518eb0c94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createExpanded </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for expand(scale) </p>

</div>
</div>
<a class="anchor" id="a48d3432b800095e5cb949a64cded86d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createLensed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for lens(g1,g2,mu) </p>

</div>
</div>
<a class="anchor" id="ab1c086513d5d569e6cd1c4269e83dd2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createMagnified </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for magnify(mu) </p>

</div>
</div>
<a class="anchor" id="a6c29613e57067e6ba5ec7297e746cdc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createRotated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for rotate(theta) </p>

</div>
</div>
<a class="anchor" id="a8c54a001124280ae550c57c8fdce3563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createSheared </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for shear(shear) </p>

</div>
</div>
<a class="anchor" id="a96c05ef4b77187b6d02d877232e81126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createShifted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete synonym for shift(dx,dy) </p>

</div>
</div>
<a class="anchor" id="ac545bacc95772067d082a68a282265e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.createTransformed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete sysnonym for <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#afe3a8a6ccc44432106e64f1003e3daf6" title="Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it...">transform()</a> </p>

</div>
</div>
<a class="anchor" id="a0e80b6924c48e9708dd9e475f3b48b5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.dilate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dilate the linear size of the profile by the given scale factor, while preserving flux. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a582e45c3a235ce1be2f58bfb2070ef15" title="Expand the linear size of the profile by the given scale factor, while preserving surface brightness...">expand()</a> and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> for versions that preserve surface brightness, and thus changes the flux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The linear rescaling factor to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dilated object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0b346a8b438dedbc7f60a52220869d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.draw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wcs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalization</em> = <code>&quot;flux&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_true_center</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an Image of the object, with bounds optionally set by an input Image. </p>
<p>The <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a> method is used to draw an Image of the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>, typically using Fourier space convolution (or, for certain GSObjects that have hard edges, real-space convolution may be used), and using interpolation to carry out image transformations such as shearing. This method can create a new Image or can draw into an existing one, depending on the choice of the <code>image</code> keyword parameter. Other keywords of particular relevance for users are those that set the pixel scale or wcs for the image (<code>scale</code>, <code>wcs</code>), that choose the normalization convention for the flux (<code>normalization</code>), and that decide whether to clear the input Image before drawing into it (<code>add_to_image</code>).</p>
<p>The object will always be drawn with its nominal center at the center location of the image. There is thus a distinction in the behavior at the center for even- and odd-sized images. For a profile with a maximum at (0,0), this maximum will fall at the central pixel of an odd-sized image, but in the corner of the 4 central pixels of an even-sized image. If you care about how the sub-pixel offsets are drawn, you should either make sure you provide an image with the right kind of size, or shift the profile by half a pixel as desired to get the profile's (0,0) location where you want it.</p>
<p>Note that when drawing a <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> that was defined with a particular value of flux, it is not necessarily the case that a drawn image with 'normalization=flux' will have the sum of pixel values equal to flux. That condition is guaranteed to be satisfied only if the profile has been convolved with a pixel response. If there was no convolution by a pixel response, then the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a> method is effectively sampling the surface brightness profile of the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> at pixel centers without integrating over the flux within pixels, so for profiles that are poorly sampled and/or varying rapidly (e.g., high n <a class="el" href="classgalsim_1_1base_1_1_sersic.html" title="A class describing a Sersic profile. ">Sersic</a> profiles), the sum of pixel values might differ significantly from the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> flux.</p>
<p>On return, the image will have a member <code>added_flux</code>, which will be set to be the total flux added to the image. This may be useful as a sanity check that you have provided a large enough image to catch most of the flux. For example: </p>
<pre class="fragment">obj.draw(image)
assert image.added_flux &gt; 0.99 * obj.getFlux()
</pre><p>The appropriate threshold will depend on your particular application, including what kind of profile the object has, how big your image is relative to the size of your object, etc.</p>
<p>Given the periodicity implicitly assumed by use of FFTs, there can occasionally be artifacts due to wrapping at the edges, particularly for objects that are quite extended (e.g., due to the nature of the radial profile). Use of the keyword parameter <code>wmult &gt; 1</code> can be used to reduce the size of these artifacts, at the expense of the calculations taking longer and using more memory. Alternatively, the objects that go into the image can be created with a <code>gsparams</code> keyword that has a lower-than-default value for <code>alias_threshold</code>; see help(<a class="el" href="structgalsim_1_1_g_s_params.html">galsim.GSParams</a>) for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the image on which to draw the profile. If <code>image = None</code>, then an automatically-sized image will be created. If <code>image != None</code>, but its bounds are undefined (e.g. if it was constructed with <code>image = galsim.Image()</code>), then it will be resized appropriately based on the profile's size [default: None]. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale for the image. If <code>scale</code> is <code>None</code> and <code>image != None</code>, then take the provided image's pixel scale. If <code>scale</code> is <code>None</code> and <code>image == None</code>, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of image), then use the Nyquist scale. [default: None] </td></tr>
    <tr><td class="paramname">wcs</td><td>If provided, use this as the wcs for the image. At most one of scale or wcs may be provided. [default: None] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1] </td></tr>
    <tr><td class="paramname">wmult</td><td>A multiplicative factor by which to enlarge (in each direction) the default automatically calculated FFT grid size used for any intermediate calculations in Fourier space. The size of the intermediate images is normally automatically chosen to reach some preset accuracy targets [cf. <a class="el" href="structgalsim_1_1_g_s_params.html">galsim.GSParams()</a>]; however, if you see strange artifacts in the image, you might try using <code>wmult &gt; 1</code>. This will take longer of course, but it will produce more accurate images, since they will have less "folding" in Fourier space. If the image size is not specified, then the output real-space image will be enlarged by a factor of <code>wmult</code>. If the image size is specified by the user, rather than automatically-sized, use of <code>wmult&gt;1</code> will still affect the size of the images used for the Fourier-space calculations and hence can reduce image artifacts, even though the image that is returned will be the size that was requested. [default: 1] </td></tr>
    <tr><td class="paramname">normalization</td><td>Two options for the normalization: "flux" or "f" means that the sum of the output pixels is normalized to be equal to the total flux. (Modulo any flux that falls off the edge of the image of course, and note the caveat in the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a> method documentation regarding the need to convolve with a pixel response.) "surface brightness" or "sb" means that the output pixels sample the surface brightness distribution at each location. [default: "flux"] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. Note: This requires that image be provided and that it have defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">use_true_center</td><td>Normally, the profile is drawn to be centered at the true center of the image (using the function <code>image.bounds.trueCenter()</code>). If you would rather use the integer center (given by <code>image.bounds.center()</code>), set this to <code>False</code>. [default: True] </td></tr>
    <tr><td class="paramname">offset</td><td>The location at which to center the profile being drawn relative to the center of the image (either the true center if use_true_center=True, or the nominal center if use_true_center=False). [default: None]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the drawn image. </dd></dl>

</div>
</div>
<a class="anchor" id="aafa4ff2871a15f044689bdf3756fd918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.drawK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>re</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dk</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the k-space Images (real and imaginary parts) of the object, with bounds optionally set by input Images. </p>
<p>Normalization is always such that re(0,0) = flux. Unlike the real-space <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a> and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0" title="Draw an image of the object by shooting individual photons drawn from the surface brightness profile ...">drawShoot()</a> functions, the (0,0) point will always be one of the actual pixel values. For even-sized images, it will be 1/2 pixel above and to the right of the true center of the image.</p>
<p>Unlike for the draw and drawShoot commands, a wcs other than a simple pixel scale is not allowed. There is no wcs parameter here, and if the images have a non-trivial wcs (and you don't override it with the scale parameter), a TypeError will be raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">re</td><td>If provided, this will be the real part of the k-space image. If <code>re = None</code>, then an automatically-sized image will be created. If <code>re != None</code>, but its bounds are undefined (e.g. if it was constructed with <code>re = galsim.Image()</code>), then it will be resized appropriately based on the profile's size. [default: None] </td></tr>
    <tr><td class="paramname">im</td><td>If provided, this will be the imaginary part of the k-space image. A provided im must match the size and scale of re. If <code>im = None</code>, then an automatically-sized image will be created. If <code>im != None</code>, but its bounds are undefined (e.g. if it was constructed with <code>im = galsim.Image()</code>), then it will be resized appropriately based on the profile's size. [default: None] </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale for the images. If <code>scale</code> is <code>None</code> and <code>re, im != None</code>, then take the provided images' pixel scale (which must be equal). If <code>scale</code> is <code>None</code> and <code>re, im == None</code>, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of image), then use the Nyquist scale. [default: None] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1.] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add to the existing images rather than clear out anything in the image before drawing. Note: This requires that images be provided (i.e. <code>re</code>, <code>im</code> are not <code>None</code>) and that they have defined bounds. [default: False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple of images, (re, im) (created if necessary) </dd></dl>

</div>
</div>
<a class="anchor" id="a42ac334d2840ba3fa832988e998beca0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.drawShoot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>image</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wcs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalization</em> = <code>&quot;flux&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_to_image</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_true_center</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_photons</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an image of the object by shooting individual photons drawn from the surface brightness profile of the object. </p>
<p>The <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0" title="Draw an image of the object by shooting individual photons drawn from the surface brightness profile ...">drawShoot()</a> method is used to draw an image of an object by shooting a number of photons to randomly sample the profile of the object. The resulting image will thus have Poisson noise due to the finite number of photons shot. <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0" title="Draw an image of the object by shooting individual photons drawn from the surface brightness profile ...">drawShoot()</a> can create a new Image or use an existing one, depending on the choice of the <code>image</code> keyword parameter. Other keywords of particular relevance for users are those that set the pixel scale or wcs for the image (<code>scale</code>, <code>wcs</code>), that choose the normalization convention for the flux (<code>normalization</code>), and that decide whether the clear the input Image before shooting photons into it (<code>add_to_image</code>).</p>
<p>As for the draw command, the object will always be drawn with its nominal center at the center location of the image. See the documentation for draw for more discussion about the implications of this for even- and odd-sized images.</p>
<p>It is important to remember that the image produced by <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0" title="Draw an image of the object by shooting individual photons drawn from the surface brightness profile ...">drawShoot()</a> represents the object as convolved with the square image pixel. So when using <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0" title="Draw an image of the object by shooting individual photons drawn from the surface brightness profile ...">drawShoot()</a> instead of <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a>, you should not explicitly include the pixel response by convolving with a <a class="el" href="classgalsim_1_1base_1_1_pixel.html" title="A class describing a pixel profile. ">Pixel</a> <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. Using drawShoot without convolving with a <a class="el" href="classgalsim_1_1base_1_1_pixel.html" title="A class describing a pixel profile. ">Pixel</a> will produce the equivalent image (for very large n_photons) as <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a> produces when the same object is convolved with <code><a class="el" href="classgalsim_1_1base_1_1_pixel.html" title="A class describing a pixel profile. ">Pixel</a>(scale=scale)</code> when drawing onto an image with pixel scale <code>scale</code>.</p>
<p>Note that the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0" title="Draw an image of the object by shooting individual photons drawn from the surface brightness profile ...">drawShoot()</a> method is unavailable for Deconvolve objects or compound objects (e.g. Add, Convolve) that include a Deconvolve.</p>
<p>On return, the image will have a member <code>added_flux</code>, which will be set to be the total flux of photons that landed inside the image bounds. This may be useful as a sanity check that you have provided a large enough image to catch most of the flux. For example: </p>
<pre class="fragment">obj.drawShoot(image)
assert image.added_flux &gt; 0.99 * obj.getFlux()
</pre><p>The appropriate threshold will depend on your particular application, including what kind of profile the object has, how big your image is relative to the size of your object, whether you are keeping <code>poisson_flux = True</code>, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>If provided, this will be the image on which to draw the profile. If <code>image = None</code>, then an automatically-sized image will be created. If <code>image != None</code>, but its bounds are undefined (e.g. if it was constructed with <code>image = galsim.Image()</code>), then it will be resized appropriately based on the profile's size [default: None]. </td></tr>
    <tr><td class="paramname">scale</td><td>If provided, use this as the pixel scale for the image. If <code>scale</code> is <code>None</code> and <code>image != None</code>, then take the provided image's pixel scale. If <code>scale</code> is <code>None</code> and <code>image == None</code>, then use the Nyquist scale. If <code>scale &lt;= 0</code> (regardless of image), then use the Nyquist scale. [default: None] </td></tr>
    <tr><td class="paramname">wcs</td><td>If provided, use this as the wcs for the image. At most one of scale or wcs may be provided. [default: None] </td></tr>
    <tr><td class="paramname">gain</td><td>The number of photons per ADU ("analog to digital units", the units of the numbers output from a CCD). [default: 1] </td></tr>
    <tr><td class="paramname">wmult</td><td>A factor by which to make an automatically-sized image larger than it would normally be made. [default: 1] </td></tr>
    <tr><td class="paramname">normalization</td><td>Two options for the normalization: "flux" or "f" means that the sum of the output pixels is normalized to be equal to the total flux. (Modulo any flux that falls off the edge of the image of course, and note the caveat in the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8" title="Draws an Image of the object, with bounds optionally set by an input Image. ">draw()</a> method documentation regarding the need to convolve with a pixel response.) "surface brightness" or "sb" means that the output pixels sample the surface brightness distribution at each location. [default: "flux"] </td></tr>
    <tr><td class="paramname">add_to_image</td><td>Whether to add flux to the existing image rather than clear out anything in the image before drawing. Note: This requires that image be provided and that it have defined bounds. [default: False] </td></tr>
    <tr><td class="paramname">use_true_center</td><td>Normally, the profile is drawn to be centered at the true center of the image (using the function <code>image.bounds.trueCenter()</code>). If you would rather use the integer center (given by <code>image.bounds.center()</code>), set this to <code>False</code>. [default: True] </td></tr>
    <tr><td class="paramname">offset</td><td>The location at which to center the profile being drawn relative to the center of the image (either the true center if use_true_center=True, or the nominal center if use_true_center=False). [default: None] </td></tr>
    <tr><td class="paramname">n_photons</td><td>If provided, the number of photons to use. If not provided (i.e. <code>n_photons = 0</code>), use as many photons as necessary to result in an image with the correct Poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to <code>n_photons = flux</code>. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). [default: 0] </td></tr>
    <tr><td class="paramname">rng</td><td>If provided, a random number generator to use for photon shooting. (may be any kind of <code><a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">galsim.BaseDeviate</a></code> object) If <code>rng=None</code>, one will be automatically created, using the time as a seed. [default: None] </td></tr>
    <tr><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel. This is only relevant if <code>n_photons=0</code>, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, you can get away with using fewer shot photons than the full <code>n_photons = flux</code>. Essentially each shot photon can have a <code>flux &gt; 1</code>, which increases the noise in each pixel. The <code>max_extra_noise</code> parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this might be <code>max_extra_noise = sky_level / 100</code> where <code>sky_level</code> is the flux per pixel due to the sky. If the natural number of photons produces less noise than this value for all pixels, we lower the number of photons to bring the resultant noise up to this value. If the natural value produces more noise than this, we accept it and just use the natural value. Note that this uses a "variance" definition of noise, not a "sigma" definition. [default: 0.] </td></tr>
    <tr><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>n_photons</code> samples. [default: True, unless n_photons is given, in which case the default is False]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the drawn image. </dd></dl>

</div>
</div>
<a class="anchor" id="abb2f53aa19bbfcc16f980072ef07fc9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.evaluateAtWavelength </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return profile at a given wavelength. </p>
<p>For <code><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a></code> instances, this is just <code>self</code>. This allows <code><a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a></code> instances to be duck-typed as <code>ChromaticObject</code> instances. </p>

</div>
</div>
<a class="anchor" id="a582e45c3a235ce1be2f58bfb2070ef15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.expand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the linear size of the profile by the given scale factor, while preserving surface brightness. </p>
<p>e.g. <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * scale</code></p>
<p>This doesn't correspond to either of the normal operations one would typically want to do to a galaxy. The functions <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> are the more typical usage. But this function is conceptually simple. It rescales the linear dimension of the profile, while preserving surface brightness. As a result, the flux will necessarily change as well.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> for a version that applies a scale factor to the area while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The factor by which to scale the linear dimension of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expanded object. </dd></dl>

</div>
</div>
<a class="anchor" id="a662d8ce421ecd90080bdcaaf6890aed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.getFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the flux of the object. </p>

</div>
</div>
<a class="anchor" id="a573a5adaf2444150c2a62db4afef98fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Exponential.getHalfLightRadius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the half light radius for this <a class="el" href="classgalsim_1_1base_1_1_exponential.html" title="A class describing an exponential profile. ">Exponential</a> profile. </p>

</div>
</div>
<a class="anchor" id="a0508398c3b3f8ec6829d9866be77c7e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.Exponential.getScaleRadius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the scale radius for this <a class="el" href="classgalsim_1_1base_1_1_exponential.html" title="A class describing an exponential profile. ">Exponential</a> profile. </p>

</div>
</div>
<a class="anchor" id="a4f480514538e924d29af411563384a6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.hasHardEdges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if there are any hard edges in the profile, which would require very small k spacing when working in the Fourier domain. </p>

</div>
</div>
<a class="anchor" id="ad883087f48bb56d90612d940dd60a7ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.isAnalyticK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if k-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>

</div>
</div>
<a class="anchor" id="a671c7778e707ab11a75a1f5877aa76ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.isAnalyticX </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if real-space values can be determined immediately at any position without requiring a Discrete Fourier Transform. </p>

</div>
</div>
<a class="anchor" id="a109bc7c81be65f8fc5d5ec32e6d0c0df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.isAxisymmetric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if axially symmetric: affects efficiency of evaluation. </p>

</div>
</div>
<a class="anchor" id="ac8652894487904b797d7752651b54507"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.kValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the object at a chosen 2D position in k space. </p>
<p>This function returns the amplitude of the fourier transform of the surface brightness profile at a given position in k space. The position argument may be provided as a PositionD or PositionI argument, or it may be given as kx,ky (either as a tuple or as two arguments).</p>
<p>Techinically, <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ac8652894487904b797d7752651b54507" title="Returns the value of the object at a chosen 2D position in k space. ">kValue()</a> is available if and only if the given obj has obj.isAnalyticK() == True, but this is the case for all GSObjects currently, so that should never be an issue (unlike for xValue).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position in k space at which you want the fourier amplitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amplitude of the fourier transform at that position. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3feadf744ebeb19048ce5b0b85a1678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.lens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with both a lensing shear and magnification applied to it. </p>
<p>This <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> method applies a lensing (reduced) shear and magnification. The shear must be specified using the g1, g2 definition of shear (see galsim.Shear documentation for more details). This is the same definition as the outputs of the galsim.PowerSpectrum and galsim.NFWHalo classes, which compute shears according to some lensing power spectrum or lensing by an NFW dark matter halo. The magnification determines the rescaling factor for the object area and flux, preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g1</td><td>First component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">g2</td><td>Second component of lensing (reduced) shear to apply to the object. </td></tr>
    <tr><td class="paramname">mu</td><td>Lensing magnification to apply to the object. This is the factor by which the solid angle subtended by the object is magnified, preserving surface brightness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lensed object. </dd></dl>

</div>
</div>
<a class="anchor" id="aac64da7ce1c4165ba048300fede29943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.magnify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. </p>
<p>This process applies a lensing magnification mu, which scales the linear dimensions of the image by the factor sqrt(mu), i.e., <code>half_light_radius</code> &lt;&ndash; <code>half_light_radius * sqrt(mu)</code> while increasing the flux by a factor of mu. Thus, <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a> preserves surface brightness.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a0e80b6924c48e9708dd9e475f3b48b5f" title="Dilate the linear size of the profile by the given scale factor, while preserving flux...">dilate()</a> for a version that applies a linear scale factor while preserving flux.</p>
<p>See <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a582e45c3a235ce1be2f58bfb2070ef15" title="Expand the linear size of the profile by the given scale factor, while preserving surface brightness...">expand()</a> for a version that applies a linear scale factor while preserving surface brightness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>The lensing magnification to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the magnified object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ab9d51f34703ced5be1592e112605ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.maxK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value of k beyond which aliasing can be neglected. </p>

</div>
</div>
<a class="anchor" id="a98091310691b1ecdd0d8bfacf48b73c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.nyquistDx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An obsolete synonym for <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ab95676589d95590c2ce593adcf4f4198" title="Returns Image pixel spacing that does not alias maxK. ">nyquistScale()</a> </p>

</div>
</div>
<a class="anchor" id="ab95676589d95590c2ce593adcf4f4198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.nyquistScale </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Image pixel spacing that does not alias maxK. </p>

</div>
</div>
<a class="anchor" id="a1733c2288686dd72f5389ede87e8aac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.rotate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate this object by an <a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>Rotation angle (<a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">Angle</a> object, +ve anticlockwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated object. </dd></dl>

</div>
</div>
<a class="anchor" id="af4193645a9af52e7d54a044cafec8ab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.scaleFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj * flux_ratio. </p>

</div>
</div>
<a class="anchor" id="a1993652591ddc802b734186391b28894"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.setFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an obsolete method that is roughly equivalent to obj = obj.withFlux(flux) </p>

</div>
</div>
<a class="anchor" id="acc3ac16f75958b4a14246e944662ce3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.shear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with an area-preserving shear applied to it. </p>
<p>The arguments may be either a galsim.Shear or arguments to be used to initialize one.</p>
<p>For more details about the allowed keyword arguments, see the documentation for galsim.Shear (for doxygen documentation, see <a class="el" href="classgalsim_1_1shear_1_1_shear.html" title="A class to represent shears in a variety of ways. ">galsim.shear.Shear</a>).</p>
<p>The <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#acc3ac16f75958b4a14246e944662ce3f" title="Create a version of the current object with an area-preserving shear applied to it. ">shear()</a> method precisely preserves the area. To include a lensing distortion with the appropriate change in area, either use <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#acc3ac16f75958b4a14246e944662ce3f" title="Create a version of the current object with an area-preserving shear applied to it. ">shear()</a> with <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#aac64da7ce1c4165ba048300fede29943" title="Create a version of the current object with a lensing magnification applied to it, scaling the area and flux by mu at fixed surface brightness. ">magnify()</a>, or use <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#ae3feadf744ebeb19048ce5b0b85a1678" title="Create a version of the current object with both a lensing shear and magnification applied to it...">lens()</a>, which combines both operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shear</td><td>The shear to be applied. Or, as described above, you may instead supply parameters do construct a shear directly. eg. <code>obj.shear(g1=g1,g2=g2)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sheared object. </dd></dl>

</div>
</div>
<a class="anchor" id="a17a4998b3d8ba6e13e9f0779e56f3697"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object shifted by some amount in real space. </p>
<p>After this call, the caller's type will be a <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a>. This means that if the caller was a derived type that had extra methods beyond those defined in <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> (e.g. getSigma() for a <a class="el" href="classgalsim_1_1base_1_1_gaussian.html" title="A class describing a 2-D Gaussian surface brightness profile. ">Gaussian</a>), then these methods are no longer available.</p>
<p>Note: in addition to the dx,dy parameter names, you may also supply dx,dy as a tuple, or as a galsim.PositionD or galsim.PositionI object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>Horizontal shift to apply. </td></tr>
    <tr><td class="paramname">dy</td><td>Vertical shift to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shifted object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b5da3e499f3c00def5f7f54cab532f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.stepK </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sampling in k space necessary to avoid folding of image in x space. </p>

</div>
</div>
<a class="anchor" id="afe3a8a6ccc44432106e64f1003e3daf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with an arbitrary Jacobian matrix transformation applied to it. </p>
<p>This applies a Jacobian matrix to the coordinate system in which this object is defined. It changes a profile defined in terms of (x,y) to one defined in terms of (u,v) where: </p>
<pre class="fragment">u = dudx x + dudy y
v = dvdx x + dvdy y
</pre><p>That is, an arbitrary affine transform, but without the translation (which is easily effected via the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a17a4998b3d8ba6e13e9f0779e56f3697" title="Create a version of the current object shifted by some amount in real space. ">shift()</a> method).</p>
<p>Note that this function is similar to expand in that it preserves surface brightness, not flux. If you want to preserve flux, you should also do </p>
<pre class="fragment">prof *= 1./abs(dudx*dvdy - dudy*dvdx)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dudx</td><td>du/dx, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dudy</td><td>du/dy, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dvdx</td><td>dv/dx, where (x,y) are the current coords, and (u,v) are the new coords. </td></tr>
    <tr><td class="paramname">dvdy</td><td>dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transformed object </dd></dl>

</div>
</div>
<a class="anchor" id="a3f12b6158381ca5ef6da8e94f701f3e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.withFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with a different flux. </p>
<p>This function is equivalent to obj.withScaledFlux(flux / obj.getFlux())</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location rescaled such that the total flux will be the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux</td><td>The new flux for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux </dd></dl>

</div>
</div>
<a class="anchor" id="a21a5b330e1c7565a2bb56258127d6149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.withScaledFlux </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flux_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a version of the current object with the flux scaled by the given flux ratio. </p>
<p>This function is equivalent to obj.withFlux(flux_ratio * obj.getFlux()). However, this function is the more efficient one, since it doesn't actually require the call to obj.getFlux(). Indeed, <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a3f12b6158381ca5ef6da8e94f701f3e5" title="Create a version of the current object with a different flux. ">withFlux()</a> is implemented in terms of this one and <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8" title="Returns the flux of the object. ">getFlux()</a>.</p>
<p>It creates a new object that has the same profile as the original, but with the surface brightness at every location scaled by the given amount.</p>
<p>An equivalent, and usually simpler, way to effect this scaling is </p>
<pre class="fragment">obj = obj * flux_ratio
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flux_ratio</td><td>The new flux for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object with the new flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a30355af05f88c36f078099b6bb792e1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.base.GSObject.xValue </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the object at a chosen 2D position in real space. </p>
<p>This function returns the surface brightness of the object at a particular position in real space. The position argument may be provided as a PositionD or PositionI argument, or it may be given as x,y (either as a tuple or as two arguments).</p>
<p>The object surface brightness profiles are typically defined in world coordinates, so the position here should be in world coordinates as well.</p>
<p>Not all <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html" title="Base class for all GalSim classes that represent some kind of surface brightness profile. ">GSObject</a> classes can use this method. Classes like Convolve that require a Discrete Fourier Transform to determine the real space values will not do so for a single position. Instead a RuntimeError will be raised. The xValue(pos) method is available if and only if obj.isAnalyticX() == True.</p>
<p>Users who wish to use the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method for an object that is the convolution of other profiles can do so by drawing the convolved profile into an image, using the image to initialize a new InterpolatedImage, and then using the <a class="el" href="classgalsim_1_1base_1_1_g_s_object.html#a30355af05f88c36f078099b6bb792e1c" title="Returns the value of the object at a chosen 2D position in real space. ">xValue()</a> method for that new object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position at which you want the surface brightness of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the surface brightness at that position. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8c0e54bb1d6a0c3619a1cecd8eff5aaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.noise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52599607e0e66c8f85a3220791888a3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.SBProfile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51d8545045968d8bfca471fefcc1c2ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.SED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbbb0329cb393d4eb3e8b1d73db5cc60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.separable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa543c3fa387178c1dfeb8aee123ea5ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">galsim.base.GSObject.wave_list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="base_8py.html">base.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>

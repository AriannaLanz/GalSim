<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GalSim: galsim::SBTransform Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="classgalsim_1_1_s_b_transform.html">SBTransform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">galsim::SBTransform Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An affine transformation of another <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>.  
 <a href="classgalsim_1_1_s_b_transform.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_b_transform_8h_source.html">SBTransform.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for galsim::SBTransform:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgalsim_1_1_s_b_transform.png" usemap="#galsim::SBTransform_map" alt=""/>
  <map id="galsim::SBTransform_map" name="galsim::SBTransform_map">
<area href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw..." alt="galsim::SBProfile" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>

<p><a href="classgalsim_1_1_s_b_transform-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06acc17da2c7e84aa7fe4bc9dbe5edc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_transform.html#a06acc17da2c7e84aa7fe4bc9dbe5edc1">SBTransform</a> (const <a class="el" href="classgalsim_1_1_s_b_profile.html">SBProfile</a> &amp;sbin, double mA, double mB, double mC, double mD, const <a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt; &amp;cen=<a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt;(0., 0.), double fluxScaling=1.)</td></tr>
<tr class="memdesc:a06acc17da2c7e84aa7fe4bc9dbe5edc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General constructor.  <a href="#a06acc17da2c7e84aa7fe4bc9dbe5edc1"></a><br/></td></tr>
<tr class="memitem:a998b4cc834d351a30042b8319786760e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_transform.html#a998b4cc834d351a30042b8319786760e">SBTransform</a> (const <a class="el" href="classgalsim_1_1_s_b_profile.html">SBProfile</a> &amp;sbin, const <a class="el" href="classgalsim_1_1_cpp_ellipse.html">CppEllipse</a> &amp;e=<a class="el" href="classgalsim_1_1_cpp_ellipse.html">CppEllipse</a>(), double fluxScaling=1.)</td></tr>
<tr class="memdesc:a998b4cc834d351a30042b8319786760e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an input <a class="el" href="classgalsim_1_1_cpp_ellipse.html" title="A base class representing transformation from an ellipse to the unit circle.">CppEllipse</a>.  <a href="#a998b4cc834d351a30042b8319786760e"></a><br/></td></tr>
<tr class="memitem:a56913a54dc5812caa95fd42432b65e80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_transform.html#a56913a54dc5812caa95fd42432b65e80">SBTransform</a> (const <a class="el" href="classgalsim_1_1_s_b_transform.html">SBTransform</a> &amp;rhs)</td></tr>
<tr class="memdesc:a56913a54dc5812caa95fd42432b65e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a56913a54dc5812caa95fd42432b65e80"></a><br/></td></tr>
<tr class="memitem:adf65ab999eaac1fe4e2077027df9fd67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_transform.html#adf65ab999eaac1fe4e2077027df9fd67">~SBTransform</a> ()</td></tr>
<tr class="memdesc:adf65ab999eaac1fe4e2077027df9fd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#adf65ab999eaac1fe4e2077027df9fd67"></a><br/></td></tr>
<tr class="memitem:a11558695546a3b4129971d09df8332bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a11558695546a3b4129971d09df8332bf">xValue</a> (const <a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt; &amp;p) const </td></tr>
<tr class="memdesc:a11558695546a3b4129971d09df8332bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> at a chosen 2D position in real space.  <a href="#a11558695546a3b4129971d09df8332bf"></a><br/></td></tr>
<tr class="memitem:aeeef4c5230553a57f35a70490b97eb06"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#aeeef4c5230553a57f35a70490b97eb06">kValue</a> (const <a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt; &amp;k) const </td></tr>
<tr class="memdesc:aeeef4c5230553a57f35a70490b97eb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> at a chosen 2D position in k space.  <a href="#aeeef4c5230553a57f35a70490b97eb06"></a><br/></td></tr>
<tr class="memitem:a20a8cdf69b7c134ebd815fe272771b21"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a20a8cdf69b7c134ebd815fe272771b21">maxK</a> () const </td></tr>
<tr class="memdesc:a20a8cdf69b7c134ebd815fe272771b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of k beyond which aliasing can be neglected.  <a href="#a20a8cdf69b7c134ebd815fe272771b21"></a><br/></td></tr>
<tr class="memitem:ae7956c43a3b82f40a5b5014fcf3653f0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#ae7956c43a3b82f40a5b5014fcf3653f0">nyquistDx</a> () const </td></tr>
<tr class="memdesc:ae7956c43a3b82f40a5b5014fcf3653f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-space image pixel spacing that does not alias maxK.  <a href="#ae7956c43a3b82f40a5b5014fcf3653f0"></a><br/></td></tr>
<tr class="memitem:a81e8f62302e15417bdd4a474b3f6fe55"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a81e8f62302e15417bdd4a474b3f6fe55">stepK</a> () const </td></tr>
<tr class="memdesc:a81e8f62302e15417bdd4a474b3f6fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling in k-space necessary to avoid folding too much of image in x space.  <a href="#a81e8f62302e15417bdd4a474b3f6fe55"></a><br/></td></tr>
<tr class="memitem:a407cf518440b2c132364ccae9c98b613"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a407cf518440b2c132364ccae9c98b613">getGoodImageSize</a> (double dx, double wmult=1.) const </td></tr>
<tr class="memdesc:a407cf518440b2c132364ccae9c98b613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a good size for a drawn image based on dx and <a class="el" href="classgalsim_1_1_s_b_profile.html#a81e8f62302e15417bdd4a474b3f6fe55" title="Sampling in k-space necessary to avoid folding too much of image in x space.">stepK()</a>  <a href="#a407cf518440b2c132364ccae9c98b613"></a><br/></td></tr>
<tr class="memitem:a752163179fa64df1b24d51cc13649b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a752163179fa64df1b24d51cc13649b7d">isAxisymmetric</a> () const </td></tr>
<tr class="memdesc:a752163179fa64df1b24d51cc13649b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is known to have rotational symmetry about x=y=0.  <a href="#a752163179fa64df1b24d51cc13649b7d"></a><br/></td></tr>
<tr class="memitem:a3d9f16bb409318f98b5fafb2a577c1a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a3d9f16bb409318f98b5fafb2a577c1a9">hasHardEdges</a> () const </td></tr>
<tr class="memdesc:a3d9f16bb409318f98b5fafb2a577c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The presence of hard edges help determine whether real space convolution might be a better choice.  <a href="#a3d9f16bb409318f98b5fafb2a577c1a9"></a><br/></td></tr>
<tr class="memitem:a574382e3ede9ac14c0174fc8a9643265"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a574382e3ede9ac14c0174fc8a9643265">isAnalyticX</a> () const </td></tr>
<tr class="memdesc:a574382e3ede9ac14c0174fc8a9643265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is analytic in the real domain.  <a href="#a574382e3ede9ac14c0174fc8a9643265"></a><br/></td></tr>
<tr class="memitem:a22cb3ddd3d82cfc8abb5b63664f9bf49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a22cb3ddd3d82cfc8abb5b63664f9bf49">isAnalyticK</a> () const </td></tr>
<tr class="memdesc:a22cb3ddd3d82cfc8abb5b63664f9bf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is analytic in the Fourier domain.  <a href="#a22cb3ddd3d82cfc8abb5b63664f9bf49"></a><br/></td></tr>
<tr class="memitem:af07f3685954696376c51d86b3acf2600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#af07f3685954696376c51d86b3acf2600">centroid</a> () const </td></tr>
<tr class="memdesc:af07f3685954696376c51d86b3acf2600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (X, Y) centroid of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>.  <a href="#af07f3685954696376c51d86b3acf2600"></a><br/></td></tr>
<tr class="memitem:a926fae5ebf1d3f4b6bd03b9ed412402f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a926fae5ebf1d3f4b6bd03b9ed412402f">getFlux</a> () const </td></tr>
<tr class="memdesc:a926fae5ebf1d3f4b6bd03b9ed412402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total flux of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>.  <a href="#a926fae5ebf1d3f4b6bd03b9ed412402f"></a><br/></td></tr>
<tr class="memitem:aeefb2c61d26fae17c5a55d9e60dd4ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#aeefb2c61d26fae17c5a55d9e60dd4ac2">scaleFlux</a> (double fluxRatio)</td></tr>
<tr class="memdesc:aeefb2c61d26fae17c5a55d9e60dd4ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple the flux by fluxRatio.  <a href="#aeefb2c61d26fae17c5a55d9e60dd4ac2"></a><br/></td></tr>
<tr class="memitem:a31093a62c9086296fdf519c720edadb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a31093a62c9086296fdf519c720edadb9">setFlux</a> (double flux)</td></tr>
<tr class="memdesc:a31093a62c9086296fdf519c720edadb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flux to a new value.  <a href="#a31093a62c9086296fdf519c720edadb9"></a><br/></td></tr>
<tr class="memitem:a71800215b6832553a71f6bc8bb768e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a71800215b6832553a71f6bc8bb768e68">applyTransformation</a> (const <a class="el" href="classgalsim_1_1_cpp_ellipse.html">CppEllipse</a> &amp;e)</td></tr>
<tr class="memdesc:a71800215b6832553a71f6bc8bb768e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a given ellipse distortion (affine without rotation).  <a href="#a71800215b6832553a71f6bc8bb768e68"></a><br/></td></tr>
<tr class="memitem:a364f6b7e568889bd3b43872e56e98570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a364f6b7e568889bd3b43872e56e98570">applyShear</a> (double g1, double g2)</td></tr>
<tr class="memdesc:a364f6b7e568889bd3b43872e56e98570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a given shear.  <a href="#a364f6b7e568889bd3b43872e56e98570"></a><br/></td></tr>
<tr class="memitem:a789dc712e9141115b4b4a43938da344b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a789dc712e9141115b4b4a43938da344b">applyShear</a> (<a class="el" href="classgalsim_1_1_cpp_shear.html">CppShear</a> s)</td></tr>
<tr class="memdesc:a789dc712e9141115b4b4a43938da344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a given shear.  <a href="#a789dc712e9141115b4b4a43938da344b"></a><br/></td></tr>
<tr class="memitem:a8d861c3513863ac3c78a853d2f93a4aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a8d861c3513863ac3c78a853d2f93a4aa">applyRotation</a> (const <a class="el" href="classgalsim_1_1_angle.html">Angle</a> &amp;theta)</td></tr>
<tr class="memdesc:a8d861c3513863ac3c78a853d2f93a4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a given rotation.  <a href="#a8d861c3513863ac3c78a853d2f93a4aa"></a><br/></td></tr>
<tr class="memitem:a89d5ad319a343091947e2bde69e87fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a89d5ad319a343091947e2bde69e87fa2">applyShift</a> (double dx, double dy)</td></tr>
<tr class="memdesc:a89d5ad319a343091947e2bde69e87fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a translation.  <a href="#a89d5ad319a343091947e2bde69e87fa2"></a><br/></td></tr>
<tr class="memitem:ab168c1e486689f65adf9769d062c3f94"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classgalsim_1_1_photon_array.html">PhotonArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94">shoot</a> (int N, <a class="el" href="classgalsim_1_1_uniform_deviate.html">UniformDeviate</a> ud) const </td></tr>
<tr class="memdesc:ab168c1e486689f65adf9769d062c3f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shoot photons through this <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>.  <a href="#ab168c1e486689f65adf9769d062c3f94"></a><br/></td></tr>
<tr class="memitem:a9e31ecd8ecf842abba08120cd8cb7e82"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a9e31ecd8ecf842abba08120cd8cb7e82">getPositiveFlux</a> () const </td></tr>
<tr class="memdesc:a9e31ecd8ecf842abba08120cd8cb7e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return expectation value of flux in positive photons when <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a> is called.  <a href="#a9e31ecd8ecf842abba08120cd8cb7e82"></a><br/></td></tr>
<tr class="memitem:a873e64397c04624cc8454f037f709dce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a873e64397c04624cc8454f037f709dce">getNegativeFlux</a> () const </td></tr>
<tr class="memdesc:a873e64397c04624cc8454f037f709dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return expectation value of absolute value of flux in negative photons from <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a>  <a href="#a873e64397c04624cc8454f037f709dce"></a><br/></td></tr>
<tr class="memitem:aee82d2bd31b21f44465ee905366d3718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee82d2bd31b21f44465ee905366d3718"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#aee82d2bd31b21f44465ee905366d3718">drawShoot</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; image, double N, <a class="el" href="classgalsim_1_1_uniform_deviate.html">UniformDeviate</a> ud, double gain=1., double max_extra_noise=0., bool poisson_flux=true) const </td></tr>
<tr class="memdesc:aee82d2bd31b21f44465ee905366d3718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw this <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> into <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a> by shooting photons.  <a href="#aee82d2bd31b21f44465ee905366d3718"></a><br/></td></tr>
<tr class="memitem:a56a60e7942736380f45b82695ab2170c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56a60e7942736380f45b82695ab2170c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a56a60e7942736380f45b82695ab2170c">draw</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; image, double gain=1., double wmult=1.) const </td></tr>
<tr class="memdesc:a56a60e7942736380f45b82695ab2170c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in real space returning the summed flux.  <a href="#a56a60e7942736380f45b82695ab2170c"></a><br/></td></tr>
<tr class="memitem:a4b3cc4cad1f119cc9ea95f3f78af9bb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b3cc4cad1f119cc9ea95f3f78af9bb6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a4b3cc4cad1f119cc9ea95f3f78af9bb6">plainDraw</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; image, double gain=1.) const </td></tr>
<tr class="memdesc:a4b3cc4cad1f119cc9ea95f3f78af9bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in real space forcing the use of real methods where we have a formula for x values. For SBProfiles without an analytic real-space representation, an exception will be thrown.  <a href="#a4b3cc4cad1f119cc9ea95f3f78af9bb6"></a><br/></td></tr>
<tr class="memitem:ac02be0d9d736b3a12d92f5c51518e398"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac02be0d9d736b3a12d92f5c51518e398"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#ac02be0d9d736b3a12d92f5c51518e398">fourierDraw</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; image, double gain=1., double wmult=1.) const </td></tr>
<tr class="memdesc:ac02be0d9d736b3a12d92f5c51518e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in real space forcing the use of Fourier transform from k space.  <a href="#ac02be0d9d736b3a12d92f5c51518e398"></a><br/></td></tr>
<tr class="memitem:a0ddbb12c5a09580778548338d2b9ffeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ddbb12c5a09580778548338d2b9ffeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a0ddbb12c5a09580778548338d2b9ffeb">drawK</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; re, <a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; im, double gain=1., double wmult=1.) const </td></tr>
<tr class="memdesc:a0ddbb12c5a09580778548338d2b9ffeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space.  <a href="#a0ddbb12c5a09580778548338d2b9ffeb"></a><br/></td></tr>
<tr class="memitem:a03ae250814e299f4a7b81b9320c5ba29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03ae250814e299f4a7b81b9320c5ba29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a03ae250814e299f4a7b81b9320c5ba29">plainDrawK</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; re, <a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; im, double gain=1.) const </td></tr>
<tr class="memdesc:a03ae250814e299f4a7b81b9320c5ba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space forcing the use of k space methods where we have a formula for k values.  <a href="#a03ae250814e299f4a7b81b9320c5ba29"></a><br/></td></tr>
<tr class="memitem:a95bdbd701e35010b9cdb48134d931f10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95bdbd701e35010b9cdb48134d931f10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a95bdbd701e35010b9cdb48134d931f10">fourierDrawK</a> (<a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; re, <a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt; im, double gain=1., double wmult=1.) const </td></tr>
<tr class="memdesc:a95bdbd701e35010b9cdb48134d931f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space forcing the use of Fourier transform from real space.  <a href="#a95bdbd701e35010b9cdb48134d931f10"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae5a2125c390c01bcde7d8f9603134c5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#ae5a2125c390c01bcde7d8f9603134c5e">getXRange</a> (double &amp;xmin, double &amp;xmax, std::vector&lt; double &gt; &amp;splits) const </td></tr>
<tr class="memdesc:ae5a2125c390c01bcde7d8f9603134c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the range over which the profile is not trivially zero.  <a href="#ae5a2125c390c01bcde7d8f9603134c5e"></a><br/></td></tr>
<tr class="memitem:a3fc25a15c465df01a218d99f0e6a262f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a3fc25a15c465df01a218d99f0e6a262f">getYRange</a> (double &amp;ymin, double &amp;ymax, std::vector&lt; double &gt; &amp;splits) const </td></tr>
<tr class="memitem:a607e4a0b179cf9d6d1039ce8b4b11c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1_s_b_profile.html#a607e4a0b179cf9d6d1039ce8b4b11c26">getYRangeX</a> (double x, double &amp;ymin, double &amp;ymax, std::vector&lt; double &gt; &amp;splits) const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An affine transformation of another <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. </p>
<p>Origin of original shape will now appear at <code>_cen</code>. Flux is NOT conserved in transformation - surface brightness is preserved. We keep track of all distortions in a 2x2 matrix <code>M = [(A B), (C D)]</code> = [row1, row2] plus a 2-element Positon object <code>cen</code> for the shift, and a flux scaling, in addition to the scaling implicit in the matrix M = abs(det(M)). </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a06acc17da2c7e84aa7fe4bc9dbe5edc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim::SBTransform::SBTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_s_b_profile.html">SBProfile</a> &amp;&#160;</td>
          <td class="paramname"><em>sbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cen</em> = <code><a class="el" href="classgalsim_1_1_position.html">Position</a>&lt;&#160;double&#160;&gt;(0.,&#160;0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fluxScaling</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General constructor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sbin</td><td><a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> being transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mA</td><td>A element of 2x2 distortion matrix <code>M = [(A B), (C D)]</code> = [row1, row2] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mB</td><td>B element of 2x2 distortion matrix <code>M = [(A B), (C D)]</code> = [row1, row2] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mC</td><td>C element of 2x2 distortion matrix <code>M = [(A B), (C D)]</code> = [row1, row2] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mD</td><td>D element of 2x2 distortion matrix <code>M = [(A B), (C D)]</code> = [row1, row2] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cen</td><td>2-element (x, y) <a class="el" href="classgalsim_1_1_position.html" title="Class for storing 2d position vectors in an (x, y) format.">Position</a> for the translational shift. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxScaling</td><td>Amount by which the flux should be multiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a998b4cc834d351a30042b8319786760e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim::SBTransform::SBTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_s_b_profile.html">SBProfile</a> &amp;&#160;</td>
          <td class="paramname"><em>sbin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_cpp_ellipse.html">CppEllipse</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em> = <code><a class="el" href="classgalsim_1_1_cpp_ellipse.html">CppEllipse</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fluxScaling</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from an input <a class="el" href="classgalsim_1_1_cpp_ellipse.html" title="A base class representing transformation from an ellipse to the unit circle.">CppEllipse</a>. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sbin</td><td><a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> being transformed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td><a class="el" href="classgalsim_1_1_cpp_ellipse.html" title="A base class representing transformation from an ellipse to the unit circle.">CppEllipse</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxScaling</td><td>Amount by which the flux should be multiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56913a54dc5812caa95fd42432b65e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim::SBTransform::SBTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_s_b_transform.html">SBTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="adf65ab999eaac1fe4e2077027df9fd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim::SBTransform::~SBTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8d861c3513863ac3c78a853d2f93a4aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::applyRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a given rotation. </p>
<p>This rotates the object by the given angle. As with scaleFlux, it does not invalidate any previous uses of this object. </p>

</div>
</div>
<a class="anchor" id="a364f6b7e568889bd3b43872e56e98570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::applyShear </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>g2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a given shear. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g1</td><td>Reduced shear g1 by which to shear the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2</td><td>Reduced shear g2 by which to shear the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. This shears the object by the given shear. As with scaleFlux, it does not invalidate any previous uses of this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a789dc712e9141115b4b4a43938da344b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::applyShear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_cpp_shear.html">CppShear</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a given shear. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><a class="el" href="classgalsim_1_1_cpp_shear.html" title="A base class representing shears.">CppShear</a> object by which to shear the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. This shears the object by the given shear (see class description for <a class="el" href="classgalsim_1_1_cpp_shear.html" title="A base class representing shears.">CppShear</a> for more information about shearing conventions). As with scaleFlux, it does not invalidate any previous uses of this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89d5ad319a343091947e2bde69e87fa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::applyShift </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a translation. </p>
<p>This shifts the object by the given amount. As with scaleFlux, it does not invalidate any previous uses of this object. </p>

</div>
</div>
<a class="anchor" id="a71800215b6832553a71f6bc8bb768e68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::applyTransformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_cpp_ellipse.html">CppEllipse</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a given ellipse distortion (affine without rotation). </p>
<p>This transforms the object by the given transformation. As with scaleFlux, it does not invalidate any previous uses of this object. </p>

</div>
</div>
<a class="anchor" id="af07f3685954696376c51d86b3acf2600"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgalsim_1_1_position.html">Position</a>&lt;double&gt; galsim::SBProfile::centroid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns (X, Y) centroid of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. </p>

</div>
</div>
<a class="anchor" id="a56a60e7942736380f45b82695ab2170c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in real space returning the summed flux. </p>
<p>The image will be drawn on the provided <a class="el" href="classgalsim_1_1_image_view.html" title="ImageView class is a mutable view of an Image.">ImageView</a>, although for an FFT draw method, the k-image may be calculated internally on a larger grid to avoid folding. The default <a class="el" href="classgalsim_1_1_s_b_profile.html#a56a60e7942736380f45b82695ab2170c" title="Draw the SBProfile in real space returning the summed flux.">draw()</a> routines decide internally whether image can be drawn directly in real space or needs to be done via FFT from k space.</p>
<p>The image is not cleared out before drawing. So this profile will be added to anything already on the input image.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">image</td><td>(any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wmult</td><td>If desired, a scaling to make intermediate images larger than normal. (default <code>wmult</code> = 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>summed flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ddbb12c5a09580778548338d2b9ffeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::drawK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space. </p>
<p>For drawing in k space: routines are analagous to real space, except 2 images are needed since the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is complex. If the input images are <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a>'s and have null dimension, square images will be drawn which are big enough to avoid "folding." If drawing is done using FFT, they will be scaled up to a power of 2, or 3x2^n, whicher fits. If input image has finite dimensions then these will be used, although in an FFT the image may be calculated internally on a larger grid to avoid folding in real space. Note that if you give an input image, its origin may be redefined by the time it comes back.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">re</td><td>image of real argument of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space (any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">im</td><td>image of imaginary argument of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space (any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wmult</td><td>If desired, a scaling to make intermediate images larger than normal. (default <code>wmult</code> = 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee82d2bd31b21f44465ee905366d3718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::drawShoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_uniform_deviate.html">UniformDeviate</a>&#160;</td>
          <td class="paramname"><em>ud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_extra_noise</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>poisson_flux</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw this <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> into <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a> by shooting photons. </p>
<p>The drawShoot method produces a 2d sampled rendering of a given <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> using the <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a> class. The input image must have defined boundaries and pixel scale. The photons generated by the <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a> method will be binned into the target <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a>. See caveats in <code><a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a></code> docstring. Scale and location of the <code><a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a></code> pixels will not be altered.</p>
<p>The image is not cleared out before drawing. So this profile will be added to anything already on the input image.</p>
<p>It is important to remember that the <code><a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a></code> produced by <code>drawShoot</code> represents the <code><a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a></code> <em>as convolved with the square <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a> pixel.</em> So do not expect an exact match, even in the limit of large photon number, between the outputs of <code>draw</code> and <code>drawShoot</code>. You should convolve the <code><a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a></code> with an <code>SBBox(dx)</code> in order to match what will be produced by <code>drawShoot</code> onto an image with pixel scale <code>dx</code>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">image</td><td>(any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Total number of photons to produce. N is input as a double so that very large values of N don't have to worry about overflowing int on systems with a small MAX_INT. Internally it will be rounded to the nearest integer. If N=0, use as many photons as necessary to end up with an image with the correct poisson shot noise for the object's flux. For positive definite profiles, this is equivalent to N = flux. However, some profiles need more than this because some of the shot photons are negative (usually due to interpolants). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ud</td><td><a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.).">UniformDeviate</a> that will be used to draw photons from distribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_extra_noise</td><td>If provided, the allowed extra noise in each pixel. This is only relevant if N=0, so the number of photons is being automatically calculated. In that case, if the image noise is dominated by the sky background, you can get away with using fewer shot photons than the full N = flux. Essentially each shot photon can have a flux &gt; 1. Then extra poisson noise is added after the fact. The max_extra_noise parameter specifies how much extra noise per pixel is allowed because of this approximation. A typical value for this would be max_extra_noise = sky_level / 100 where sky_level is the flux per pixel due to the sky. Note that this uses a "variance" definition of noise, not a "sigma" definition. (default <code>max_extra_noise = 0.</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poisson_flux</td><td>Whether to allow total object flux scaling to vary according to Poisson statistics for <code>N</code> samples (default <code>poisson_flux = true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The total flux of photons the landed inside the image bounds.</dd></dl>
<p>Note: N is input as a double so that very large values of N don't have to worry about overflowing int on systems with a small MAX_INT. Internally it will be rounded to the nearest integer. </p>

</div>
</div>
<a class="anchor" id="ac02be0d9d736b3a12d92f5c51518e398"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::fourierDraw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in real space forcing the use of Fourier transform from k space. </p>
<p>The image will be drawn on the provided <a class="el" href="classgalsim_1_1_image_view.html" title="ImageView class is a mutable view of an Image.">ImageView</a>, although the k-image may be calculated internally on a larger grid to avoid folding. The FFT image will also be scaled up to either a power of 2 or 3 x a power of 2, whichever fits.</p>
<p>The image is not cleared out before drawing. So this profile will be added to anything already on the input image.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">image</td><td>(any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wmult</td><td>If desired, a scaling to make intermediate images larger than normal. (default <code>wmult</code> = 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>summed flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a95bdbd701e35010b9cdb48134d931f10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::fourierDrawK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space forcing the use of Fourier transform from real space. </p>
<p>For drawing in k space: routines are analagous to real space, except 2 images are needed since the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is complex. If the input images are <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a>'s and have null dimension, square images will be drawn which are big enough to avoid "folding." Drawing is done using FFT, and the images will be scaled up to a power of 2, or 3x2^n, whicher fits. If input image has finite dimensions then these will be used, although in an FFT the image may be calculated internally on a larger grid to avoid folding in real space. Note that if you give an input image, its origin may be redefined by the time it comes back.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">re</td><td>image of real argument of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space (any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">im</td><td>image of imaginary argument of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space (any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wmult</td><td>If desired, a scaling to make intermediate images larger than normal. (default <code>wmult</code> = 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a926fae5ebf1d3f4b6bd03b9ed412402f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::getFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total flux of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. </p>

</div>
</div>
<a class="anchor" id="a407cf518440b2c132364ccae9c98b613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int galsim::SBProfile::getGoodImageSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wmult</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a good size for a drawn image based on dx and <a class="el" href="classgalsim_1_1_s_b_profile.html#a81e8f62302e15417bdd4a474b3f6fe55" title="Sampling in k-space necessary to avoid folding too much of image in x space.">stepK()</a> </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dx</td><td>The pixel scale of the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wmult</td><td>If desired, a scaling to make the image larger than normal. (default <code>wmult</code> = 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the recommended image size.</dd></dl>
<p>The basic formula is 2pi * wmult / (dx * <a class="el" href="classgalsim_1_1_s_b_profile.html#a81e8f62302e15417bdd4a474b3f6fe55" title="Sampling in k-space necessary to avoid folding too much of image in x space.">stepK()</a>) But then we round up to the next even integer value. </p>

</div>
</div>
<a class="anchor" id="a873e64397c04624cc8454f037f709dce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::getNegativeFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return expectation value of absolute value of flux in negative photons from <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a> </p>
<p>Returns expectation value of (absolute value of) flux returned in negative-valued photons when <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a> is called for this object. Default implementation is to return <a class="el" href="classgalsim_1_1_s_b_profile.html#a926fae5ebf1d3f4b6bd03b9ed412402f" title="Get the total flux of the SBProfile.">getFlux()</a> if it is negative, 0 otherwise, which will be the case when the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is constructed entirely from elements that have the same sign.</p>
<p>It should be generally true that <code><a class="el" href="classgalsim_1_1_s_b_profile.html#a9e31ecd8ecf842abba08120cd8cb7e82" title="Return expectation value of flux in positive photons when shoot() is called.">getPositiveFlux()</a> - <a class="el" href="classgalsim_1_1_s_b_profile.html#a873e64397c04624cc8454f037f709dce" title="Return expectation value of absolute value of flux in negative photons from shoot()">getNegativeFlux()</a></code> returns the same thing as <code><a class="el" href="classgalsim_1_1_s_b_profile.html#a926fae5ebf1d3f4b6bd03b9ed412402f" title="Get the total flux of the SBProfile.">getFlux()</a></code>. Small difference may accrue from finite numerical accuracy in cases involving lookup tables, etc.</p>
<dl class="section return"><dt>Returns:</dt><dd>Expected absolute value of negative-photon flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e31ecd8ecf842abba08120cd8cb7e82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::getPositiveFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return expectation value of flux in positive photons when <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94" title="Shoot photons through this SBProfile.">shoot()</a> is called. </p>
<p>Returns expectation value of flux returned in positive-valued photons when <a class="el" href="classgalsim_1_1_s_b_profile.html#ab168c1e486689f65adf9769d062c3f94">shoot()</a> is called for this object. Default implementation is to return <a class="el" href="classgalsim_1_1_s_b_profile.html#a926fae5ebf1d3f4b6bd03b9ed412402f" title="Get the total flux of the SBProfile.">getFlux()</a>, if it is positive, or 0 otherwise, which will be the case when the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is constructed entirely from elements of the same sign.</p>
<p>It should be generally true that <code><a class="el" href="classgalsim_1_1_s_b_profile.html#a9e31ecd8ecf842abba08120cd8cb7e82" title="Return expectation value of flux in positive photons when shoot() is called.">getPositiveFlux()</a> - <a class="el" href="classgalsim_1_1_s_b_profile.html#a873e64397c04624cc8454f037f709dce" title="Return expectation value of absolute value of flux in negative photons from shoot()">getNegativeFlux()</a></code> returns the same thing as <code><a class="el" href="classgalsim_1_1_s_b_profile.html#a926fae5ebf1d3f4b6bd03b9ed412402f" title="Get the total flux of the SBProfile.">getFlux()</a></code>. Small difference may accrue from finite numerical accuracy in cases involving lookup tables, etc.</p>
<dl class="section return"><dt>Returns:</dt><dd>Expected positive-photon flux. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a2125c390c01bcde7d8f9603134c5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::getXRange </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the range over which the profile is not trivially zero. </p>
<p>These values are used when a real-space convolution is requested to define the appropriate range of integration. The implementation here is +- infinity for both x and y. Derived classes may override this if they a have different range. </p>

</div>
</div>
<a class="anchor" id="a3fc25a15c465df01a218d99f0e6a262f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::getYRange </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ymax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a607e4a0b179cf9d6d1039ce8b4b11c26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::getYRangeX </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ymax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3d9f16bb409318f98b5fafb2a577c1a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool galsim::SBProfile::hasHardEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The presence of hard edges help determine whether real space convolution might be a better choice. </p>

</div>
</div>
<a class="anchor" id="a22cb3ddd3d82cfc8abb5b63664f9bf49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool galsim::SBProfile::isAnalyticK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is analytic in the Fourier domain. </p>
<p>An <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is "analytic" in the k domain if values can be determined immediately at any position through formula or a stored table (no DFT); this makes certain calculations more efficient. </p>

</div>
</div>
<a class="anchor" id="a574382e3ede9ac14c0174fc8a9643265"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool galsim::SBProfile::isAnalyticX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is analytic in the real domain. </p>
<p>An <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is "analytic" in the real domain if values can be determined immediately at any position through formula or a stored table (no DFT); this makes certain calculations more efficient. </p>

</div>
</div>
<a class="anchor" id="a752163179fa64df1b24d51cc13649b7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool galsim::SBProfile::isAxisymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is known to have rotational symmetry about x=y=0. </p>
<p>If the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> has rotational symmetry, certain calculations can be simplified. </p>

</div>
</div>
<a class="anchor" id="aeeef4c5230553a57f35a70490b97eb06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; galsim::SBProfile::kValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return value of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> at a chosen 2D position in k space. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>2D position in k space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20a8cdf69b7c134ebd815fe272771b21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::maxK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value of k beyond which aliasing can be neglected. </p>

</div>
</div>
<a class="anchor" id="ae7956c43a3b82f40a5b5014fcf3653f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::nyquistDx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Real-space image pixel spacing that does not alias maxK. </p>

</div>
</div>
<a class="anchor" id="a4b3cc4cad1f119cc9ea95f3f78af9bb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::plainDraw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in real space forcing the use of real methods where we have a formula for x values. For SBProfiles without an analytic real-space representation, an exception will be thrown. </p>
<p>The image is not cleared out before drawing. So this profile will be added to anything already on the input image.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">image</td><td>(any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>summed flux. </dd></dl>

</div>
</div>
<a class="anchor" id="a03ae250814e299f4a7b81b9320c5ba29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::plainDrawK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_image_view.html">ImageView</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an image of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space forcing the use of k space methods where we have a formula for k values. </p>
<p>For drawing in k space: routines are analagous to real space, except 2 images are needed since the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> is complex. If the input images are <a class="el" href="classgalsim_1_1_image.html" title="Image class.">Image</a>'s and have null dimension, square images will be drawn which are big enough to avoid "folding." Note that if you give an input image, its origin may be redefined by the time it comes back.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">re</td><td>image of real argument of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space (any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">im</td><td>image of imaginary argument of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> in k space (any of ImageViewF, ImageViewD, ImageViewS, ImageViewI) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>Number of photons per ADU. (default <code>gain</code> = 1.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeefb2c61d26fae17c5a55d9e60dd4ac2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::scaleFlux </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fluxRatio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiple the flux by fluxRatio. </p>
<p>This resets the internal pointer to a new <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> that wraps the old one with a scaled flux. This does not change any previous uses of the <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>, so if it had been used in some other context (e.g. in <a class="el" href="classgalsim_1_1_s_b_add.html" title="Sums SBProfiles.">SBAdd</a> or <a class="el" href="classgalsim_1_1_s_b_convolve.html" title="Convolve SBProfiles.">SBConvolve</a>), that object will be unchanged and still valid. </p>

</div>
</div>
<a class="anchor" id="a31093a62c9086296fdf519c720edadb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void galsim::SBProfile::setFlux </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the flux to a new value. </p>
<p>This sets the flux to a new value. As with scaleFlux, it does not invalidate any previous uses of this object. </p>

</div>
</div>
<a class="anchor" id="ab168c1e486689f65adf9769d062c3f94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classgalsim_1_1_photon_array.html">PhotonArray</a>&gt; galsim::SBProfile::shoot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgalsim_1_1_uniform_deviate.html">UniformDeviate</a>&#160;</td>
          <td class="paramname"><em>ud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shoot photons through this <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. </p>
<p>Returns an array of photon coordinates and fluxes that are drawn from the light distribution of this <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a>. Absolute value of each photons' flux should be approximately equal, but some photons can be negative as needed to represent negative regions. Note that the ray-shooting method is not intended to produce a randomized value of the total object flux, so do not assume that there will be sqrt(N) error on the flux. In fact most implementations will return a <a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions.">PhotonArray</a> with exactly correct flux, with only the <em>distribution</em> of flux on the sky that will definitely have sampling noise.</p>
<p>The one definitive gaurantee is that, in the limit of large number of photons, the surface brightness distribution of the photons will converge on the SB pattern defined by the object.</p>
<p>Objects with regions of negative flux will result in creation of photons with negative flux. Absolute value of negative photons' flux should be nearly equal to the standard flux of positive photons. Shot-noise fluctuations between the number of positive and negative photons will produce noise in the total net flux carried by the output <a class="el" href="classgalsim_1_1_photon_array.html">PhotonArray</a>.</p>
<p>The typical implementation will be to take the integral of the absolute value of flux, and divide it nearly equally into N photons. The photons are then drawn from the distribution of the <em>absolute value</em> of flux. If a photon is drawn from a region of negative flux, then that photon's flux is negated. Because of cancellation, this means that each photon will carry more than <code><a class="el" href="classgalsim_1_1_s_b_profile.html#a926fae5ebf1d3f4b6bd03b9ed412402f" title="Get the total flux of the SBProfile.">getFlux()</a>/N</code> flux if there are negative-flux regions in the object. It also means that during convolution, addition, or interpolation, positive- and negative-flux photons can be contributing to the same region of the image. Their cancellation means that the shot noise may be substantially higher than you would expect if you had only positive-flux photons.</p>
<p>The photon flux may also vary slightly as a means of speeding up photon-shooting, as an alternative to rejection sampling. See <code><a class="el" href="classgalsim_1_1_one_dimensional_deviate.html" title="Class which implements random sampling of an arbitrary one-dimensional distribution, for photon shooting.">OneDimensionalDeviate</a></code> documentation.</p>
<p>It should be rare to use this method or any <code><a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions.">PhotonArray</a></code> in user code - the method <code><a class="el" href="classgalsim_1_1_s_b_profile.html#aee82d2bd31b21f44465ee905366d3718" title="Draw this SBProfile into Image by shooting photons.">drawShoot()</a></code> will more typically put the results directly into an image.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Total number of photons to produce. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ud</td><td><a class="el" href="classgalsim_1_1_uniform_deviate.html" title="Pseudo-random number generator with uniform distribution in interval [0.,1.).">UniformDeviate</a> that will be used to draw photons from distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd><a class="el" href="classgalsim_1_1_photon_array.html" title="Class to hold a list of &quot;photon&quot; arrival positions.">PhotonArray</a> containing all the photons' info. </dd></dl>

</div>
</div>
<a class="anchor" id="a81e8f62302e15417bdd4a474b3f6fe55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::stepK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sampling in k-space necessary to avoid folding too much of image in x space. </p>

</div>
</div>
<a class="anchor" id="a11558695546a3b4129971d09df8332bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double galsim::SBProfile::xValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgalsim_1_1_position.html">Position</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return value of <a class="el" href="classgalsim_1_1_s_b_profile.html" title="A base class representing all of the 2D surface brightness profiles that we know how to draw...">SBProfile</a> at a chosen 2D position in real space. </p>
<p>Assume all are real-valued. <a class="el" href="classgalsim_1_1_s_b_profile.html#a11558695546a3b4129971d09df8332bf" title="Return value of SBProfile at a chosen 2D position in real space.">xValue()</a> may not be implemented for derived classes (<a class="el" href="classgalsim_1_1_s_b_convolve.html" title="Convolve SBProfiles.">SBConvolve</a>) that require an FFT to determine real-space values. In this case, an SBError will be thrown.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>2D position in real space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/galsim/<a class="el" href="_s_b_transform_8h_source.html">SBTransform.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1</small></address>
</body>
</html>

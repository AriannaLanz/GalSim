Plan for changes to the code in response to issue #134 (shearing conventions):

The overall aim is to achieve consistency in shearing conventions by having the default mean the
same thing in C++ and python, while allowing users to easily specify if they want something other
than the default.  First, for clarity, here is the terminology that I use (which is consistent with
SBProfile, not surprisingly since it comes from Bernstein & Jarvis 2002):

conformal shear = eta
axis ratio q = b/a = exp(-eta) ~ 1-eta
distortion e = (a^2 - b^2)/(a^2 + b^2) = tanh(eta)
reduced shear g = (a - b)/(a + b) = tanh(eta/2)
There are other ways people define ellipticity, e.g. 1-q, but let's ignore that for now and assume
that if the user doesn't want to specify distortion / reduced shear / conformal shear, then they
will specify an axis ratio.

Given the consensus in #134 that we want "shear" to mean "reduced shear", this will require some
small changes to the C++, in which Shear objects are currently initialized with a distortion e1/e2
rather than reduced shear.  As Mike says, we'd be changing the constructor from:

explicit Shear(double _e1=0., double _e2=0.) :
    e1(_e1),e2(_e2), hasMatrix(false),
    matrixA(0), matrixB(0), matrixC(0)
{}

to

explicit Shear(double g1=0., double g2=0.) :
    hasMatrix(false), matrixA(0), matrixB(0), matrixC(0)
{ setG1G2(g1,g2); }

and we'd be leaving the internals of the Shear class in terms of e1 and e2.  The only other detail
related to the Shear object that requires minor changes is the negation operator (line 78 in
include/galsim/Shear.h), which currently creates another Shear, so its use of the constructor has to
be updated to be consistent with the above change.

Other possible places in the C++ that could require changes:

* The Ellipse class in Shear.h does not necessarily represent an elliptical distortion (can be used
  just for size change and/or centroid shift), but when it does represent a shape distortion, it
  takes e1/e2-type distortions.  I think that this is actually okay: its name is not "shear" so it is
  not confusing that it doesn't take a reduced shear by default.  It is arguable whether users will
  really want to use an e1/e2 type distortion or some other way of specifying ellipticity, but most
  users will not access Ellipse objects directly.  So, I propose to leave the Ellipse class alone
  for now.

* The shear method in SBProfile.h currently takes e1/e2 as arguments.  I propose that for clarity it
  should take g1/g2. The entirety of the change would be from

virtual SBProfile* shear(double e1, double e2) const { return distort(Ellipse(e1,e2)); }

to

virtual SBProfile* shear(double g1, double g2) const { 
        s = Shear(g1, g2);
        return distort(Ellipse(s.getE1(), s.getE2()));
}

* The distort method in SBProfile.h takes an Ellipse as arguments, and is not usually called
  directly, but rather indirectly through rotate, shift, shear.  Based on discussion on github, I
  propose to change the name of this function to "transform" (to avoid confusion with e1/e2
  distortion or detector effects or other things that get called distortion).  Should we change the
  SBDistort class to SBTransform, for the sake of consistency?  This last point about distort
  vs. transform and SBDistort vs. SBTransform is more arguable than the shear convention issues, so
  if there is some disagreement, we can defer this for later.

*********************************

At the python level, we have the following methods and classes for which the shear convention is an
issue:

applyShear
createSheared

These currently take as arguments g1/g2 shears, which is what we'd like to maintain as a default,
but we also want to have other options.  I propose to make them take a set of arguments, which could
be -

1 unnamed arg = a Shear object
2 unnamed args = (g1, g2)
or, using keywords, they could give any of the following combinations:
e1, e2
eta1, eta2
e, theta (position angle)
g, theta
eta, theta

So if we want to shear some base class object my_base by (0.05, 0) then we can still use
my_base.applyShear(0.05, 0.0) without having to specify that we're working in terms of g1, g2.  In
practice, this could be implemented as follows:

def applyShear(self, g1=None, g2=None, e1=None, e2=None, eta1=None, eta2=None, e=None, g=None, eta=None,
               q=None, theta=None):
    # use the keywords to make a Shear object, if not provided
    if not isinstance(g1, galsim.Shear)
       g1 = galsim.Shear(g1=g1, g2=g2, e1=e1, e2=e2, eta1=eta1, eta2=eta2, e=e, g=g, eta=eta, q=q, theta=theta)
    # and then apply the shear using a modified version of how applyShear currently works
    GSObject.__init__(self, self.SBProfile.distort(galsim.Ellipse(g1.getE1(), g1.getE2())))

** Note: I realize it is clumsy and makes for somewhat weird-looking code to have an argument called
   "g1" potentially be a Shear object rather than a single component of the reduced shear.  But I
   cannot think of another way to make it possible to have 1 unnamed argument by default be treated
   as a Shear, and 2 unnamed arguments by default be treated as g1/g2.

This will require modifying the wrappers in pysrc/Shear.cpp so that Shear objects can be initialized
with the above set of args (similarly to how pysrc/SBProfile.cpp changes the set of required
arguments when creating SBProfiles).  All error handling related to the set of keywords provided
will take place in pysrc/Shear.cpp.  So for example, if we do something strange like

my_base.applyShear(0.05)

then when we try to create the Shear object in applyShear, it will raise an exception since 2 float
arguments are needed to specify a shear.  The code for handling arguments in pysrc/Shear.cpp will be
unfortunately kind of hairy since there are many possible combinations that could be specified, but
it will just have to be maintained in place (not duplicated elsewhere, since all python functions
that apply a shear will have error-handling take place when they try to create the appropriate Shear
object).  As a result of these changes, it will be possible to do something like

my_shear = galsim.Shear(e1=my_e1, e2=my_e2)

or many other ways of specifying the shear in python, which is not the same as in C++, where Shear
objects must be initialized using (g1, g2) ONLY.  This is similar in spirit to what we've done with
radii.

Other possible changes in python:

* We have applyDistortion and createDistorted which take Ellipse objects as arguments.  I propose to
  change the names to applyTransform and createTransformed, similar to the proposed changes in C++
  (but, again, these are less critical changes and could be deferred if there is argument on this
  point).

* It would be useful to have applyDilation/createDilated as another special-case transformation at
  fixed total flux.  We could also have applyMagnification/createMagnified which would do the same
  but at fixed surface brightness.  **I suggest that we postpone this until issue #159 has been
  resolved, so I will open another issue for it rather than including it with this work!**


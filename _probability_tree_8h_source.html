<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GalSim: include/galsim/ProbabilityTree.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>include/galsim/ProbabilityTree.h</h1><a href="_probability_tree_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- c++ -*-</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright 2012-2014 The GalSim developers:</span>
<a name="l00003"></a>00003 <span class="comment"> * https://github.com/GalSim-developers</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * This file is part of GalSim: The modular galaxy image simulation toolkit.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * GalSim is free software: you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment"> * the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment"> * (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * GalSim is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment"> * along with GalSim.  If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#ifndef PROBABILITY_TREE_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#define PROBABILITY_TREE_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="keyword">namespace </span>galsim {
<a name="l00027"></a>00027 
<a name="l00049"></a>00049     <span class="keyword">template</span> &lt;<span class="keyword">class</span> FluxData&gt;
<a name="l00050"></a><a class="code" href="classgalsim_1_1_probability_tree.html">00050</a>     <span class="keyword">class </span><a class="code" href="classgalsim_1_1_probability_tree.html" title="Class to build binary tree for random draw among objects with known probabilities...">ProbabilityTree</a> :
<a name="l00052"></a>00052         <span class="keyword">private</span> std::vector&lt;FluxData&gt; 
<a name="l00054"></a>00054     {
<a name="l00055"></a>00055         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;FluxData&gt;::iterator VecIter;
<a name="l00056"></a>00056         <span class="keyword">class </span>FluxCompare;
<a name="l00057"></a>00057     <span class="keyword">public</span>:
<a name="l00058"></a>00058         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::size;
<a name="l00059"></a>00059         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::begin;
<a name="l00060"></a>00060         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::end;
<a name="l00061"></a>00061         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::push_back;
<a name="l00062"></a>00062         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::insert;
<a name="l00063"></a>00063         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::empty;
<a name="l00064"></a>00064         <span class="keyword">using</span> std::vector&lt;FluxData&gt;::clear;
<a name="l00065"></a>00065 
<a name="l00067"></a><a class="code" href="classgalsim_1_1_probability_tree.html#aa9bba9cbd3eec11b7b85617c7bf61e87">00067</a>         <a class="code" href="classgalsim_1_1_probability_tree.html#aa9bba9cbd3eec11b7b85617c7bf61e87" title="Constructor - nothing to do.">ProbabilityTree</a>() : _root(0) {}
<a name="l00068"></a>00068 
<a name="l00070"></a><a class="code" href="classgalsim_1_1_probability_tree.html#a5132f76b4a71d79b7e837650c88d3f08">00070</a>         <a class="code" href="classgalsim_1_1_probability_tree.html#a5132f76b4a71d79b7e837650c88d3f08" title="Destructor - kill the `Element`s that have been stored away.">~ProbabilityTree</a>() { <span class="keywordflow">if</span> (_root) <span class="keyword">delete</span> _root; }
<a name="l00071"></a>00071 
<a name="l00086"></a><a class="code" href="classgalsim_1_1_probability_tree.html#a46dbb2e8781b166d5a965bc5bcbe032b">00086</a>         <span class="keyword">const</span> FluxData* <a class="code" href="classgalsim_1_1_probability_tree.html#a46dbb2e8781b166d5a965bc5bcbe032b" title="Choose a member of the tree based on a uniform deviate.">find</a>(<span class="keywordtype">double</span>&amp; unitRandom)<span class="keyword"> const </span>
<a name="l00087"></a>00087 <span class="keyword">        </span>{
<a name="l00088"></a>00088             <span class="comment">// Note: Don&apos;t need floor here, since rhs is positive, so floor is superfluous.</span>
<a name="l00089"></a>00089             <span class="keywordtype">int</span> i = int(unitRandom * _shortcut.size());
<a name="l00090"></a>00090             assert(i &lt; <span class="keywordtype">int</span>(_shortcut.size()));
<a name="l00091"></a>00091             assert(_shortcut[i]);
<a name="l00092"></a>00092             unitRandom *= _totalAbsFlux;
<a name="l00093"></a>00093             <span class="keywordflow">return</span> _shortcut[i]-&gt;find(unitRandom);
<a name="l00094"></a>00094         }
<a name="l00095"></a>00095 
<a name="l00100"></a><a class="code" href="classgalsim_1_1_probability_tree.html#a1ebab8f7b10d5ffaab93892af4294f07">00100</a>         <span class="keywordtype">void</span> <a class="code" href="classgalsim_1_1_probability_tree.html#a1ebab8f7b10d5ffaab93892af4294f07" title="Construct the tree from current vector elements.">buildTree</a>(<span class="keywordtype">double</span> threshold=0.)
<a name="l00101"></a>00101         {
<a name="l00102"></a>00102             dbg&lt;&lt;<span class="stringliteral">&quot;buildTree\n&quot;</span>;
<a name="l00103"></a>00103             assert(!empty());
<a name="l00104"></a>00104             assert(!_root);
<a name="l00105"></a>00105             <span class="comment">// Sort the list so the largest flux regions are first.</span>
<a name="l00106"></a>00106             std::sort(begin(), end(), FluxCompare());
<a name="l00107"></a>00107             VecIter last = 
<a name="l00108"></a>00108                 threshold == 0. ? end() :
<a name="l00109"></a>00109                 std::upper_bound(begin(), end(), threshold, FluxCompare());
<a name="l00110"></a>00110             <span class="keyword">const</span> <span class="keywordtype">int</span> nelem = last-begin();
<a name="l00111"></a>00111             dbg&lt;&lt;<span class="stringliteral">&quot;N elements to build tree with = &quot;</span>&lt;&lt;nelem&lt;&lt;std::endl;
<a name="l00112"></a>00112             <span class="comment">// Figure out what the total absolute flux is</span>
<a name="l00113"></a>00113             _totalAbsFlux = 0.;
<a name="l00114"></a>00114             <span class="keywordflow">for</span> (VecIter it=begin(); it!=last; ++it) 
<a name="l00115"></a>00115                 _totalAbsFlux += std::abs(it-&gt;getFlux());
<a name="l00116"></a>00116             dbg&lt;&lt;<span class="stringliteral">&quot;totalAbsFlux = &quot;</span>&lt;&lt;_totalAbsFlux&lt;&lt;std::endl;
<a name="l00117"></a>00117             <span class="comment">// leftAbsFlux will be updated for each element to be the total flux up the that one.</span>
<a name="l00118"></a>00118             <span class="keywordtype">double</span> leftAbsFlux = 0.;
<a name="l00119"></a>00119             _root = <span class="keyword">new</span> Element(begin(), last, leftAbsFlux, _totalAbsFlux);
<a name="l00120"></a>00120             xdbg&lt;&lt;<span class="stringliteral">&quot;Finished making root.\n&quot;</span>;
<a name="l00121"></a>00121             xdbg&lt;&lt;<span class="stringliteral">&quot;leftAbs = &quot;</span>&lt;&lt;leftAbsFlux&lt;&lt;<span class="stringliteral">&quot;, tot = &quot;</span>&lt;&lt;_totalAbsFlux&lt;&lt;std::endl;
<a name="l00122"></a>00122             xdbg&lt;&lt;<span class="stringliteral">&quot;abs(diff) = &quot;</span>&lt;&lt;std::abs(leftAbsFlux - _totalAbsFlux)&lt;&lt;std::endl;
<a name="l00123"></a>00123             xdbg&lt;&lt;<span class="stringliteral">&quot;cf. &quot;</span>&lt;&lt;1.e-8 * _totalAbsFlux&lt;&lt;std::endl;
<a name="l00124"></a>00124             xassert(std::abs(leftAbsFlux - _totalAbsFlux) &lt; 1.e-8 * _totalAbsFlux);
<a name="l00125"></a>00125             dbg&lt;&lt;<span class="stringliteral">&quot;Done buildTree\n&quot;</span>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127             <span class="comment">// shortcut is a quick way to get to the right Element, or at least a better</span>
<a name="l00128"></a>00128             <span class="comment">// starting point, rather than always starting at root.</span>
<a name="l00129"></a>00129             <span class="comment">// We build this as we build the tree in the Element constructors.</span>
<a name="l00130"></a>00130             _shortcut.resize(nelem,0);
<a name="l00131"></a>00131             buildShortcut(_root, 0, nelem);
<a name="l00132"></a>00132             <span class="comment">// Make sure all the shortcut entries were set.</span>
<a name="l00133"></a>00133             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;nelem;++i) xassert(_shortcut[i]);
<a name="l00134"></a>00134         }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keyword">private</span>:
<a name="l00137"></a>00137 
<a name="l00139"></a>00139         <span class="keyword">class </span>Element 
<a name="l00140"></a>00140         {
<a name="l00141"></a>00141         <span class="keyword">public</span>:
<a name="l00142"></a>00142             Element(VecIter start, VecIter end, <span class="keywordtype">double</span>&amp; leftAbsFlux, <span class="keywordtype">double</span> absFlux) :
<a name="l00143"></a>00143                 _dataPtr(0), _left(0), _right(0),
<a name="l00144"></a>00144                 _leftAbsFlux(leftAbsFlux), _absFlux(absFlux), _invAbsFlux(1./absFlux)
<a name="l00145"></a>00145             {
<a name="l00146"></a>00146                 xassert(start != end);
<a name="l00147"></a>00147                 <span class="keywordflow">if</span> (start + 1 == end) {
<a name="l00148"></a>00148                     <span class="comment">// Only one element.</span>
<a name="l00149"></a>00149                     _dataPtr = &amp;(*start);
<a name="l00150"></a>00150                     <span class="comment">// absFlux on input should equal the absolute flux in this dataPtr.</span>
<a name="l00151"></a>00151                     xassert(std::abs(std::abs(_dataPtr-&gt;getFlux()) - absFlux) &lt; 
<a name="l00152"></a>00152                             1.e-8 * (leftAbsFlux+absFlux));
<a name="l00153"></a>00153                     <span class="comment">// Update the running total of leftAbsFlux.</span>
<a name="l00154"></a>00154                     leftAbsFlux += _absFlux;
<a name="l00155"></a>00155                 } <span class="keywordflow">else</span> {
<a name="l00156"></a>00156                     xassert(end &gt;= start+2);
<a name="l00157"></a>00157                     VecIter mid = start;
<a name="l00158"></a>00158                     <span class="comment">// Divide the range by probability, not by number.</span>
<a name="l00159"></a>00159                     <span class="comment">// The tree is intentionally unbalanced, so most of the time, the search</span>
<a name="l00160"></a>00160                     <span class="comment">// stops quickly with the large flux Elements on the left.</span>
<a name="l00161"></a>00161                     <span class="keywordtype">double</span> half_tot = absFlux/2.;
<a name="l00162"></a>00162                     <span class="keywordtype">double</span> leftSum=0.;
<a name="l00163"></a>00163                     <span class="keywordflow">for</span> (; leftSum &lt;= half_tot; ++mid) leftSum += std::abs(mid-&gt;getFlux());
<a name="l00164"></a>00164                     <span class="keywordflow">if</span> (mid == end) {
<a name="l00165"></a>00165                         <span class="comment">// Shouldn&apos;t happen in exact arithmetic, but just in case...</span>
<a name="l00166"></a>00166                         --mid;
<a name="l00167"></a>00167                         leftSum -= std::abs(mid-&gt;getFlux());
<a name="l00168"></a>00168                     }
<a name="l00169"></a>00169                     xassert(mid != start);
<a name="l00170"></a>00170                     xassert(mid != end);
<a name="l00171"></a>00171                     _left = <span class="keyword">new</span> Element(start, mid, leftAbsFlux, leftSum);
<a name="l00172"></a>00172                     _right = <span class="keyword">new</span> Element(mid, end, leftAbsFlux, absFlux - leftSum);
<a name="l00173"></a>00173                     <span class="comment">// absFlux on input should equal the sum of the two children&apos;s fluxes.</span>
<a name="l00174"></a>00174                     xassert(std::abs((_left-&gt;_absFlux + _right-&gt;_absFlux) - absFlux) &lt; 
<a name="l00175"></a>00175                             1.e-8 * (leftAbsFlux+absFlux));
<a name="l00176"></a>00176                 }
<a name="l00177"></a>00177             }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179             ~Element() 
<a name="l00180"></a>00180             {
<a name="l00181"></a>00181                 <span class="keywordflow">if</span> (_left) {
<a name="l00182"></a>00182                     assert(_right);
<a name="l00183"></a>00183                     <span class="keyword">delete</span> _left;
<a name="l00184"></a>00184                     <span class="keyword">delete</span> _right; 
<a name="l00185"></a>00185                 }
<a name="l00186"></a>00186             }
<a name="l00187"></a>00187 
<a name="l00196"></a>00196             <span class="keyword">const</span> FluxData* <a class="code" href="classgalsim_1_1_probability_tree.html#a46dbb2e8781b166d5a965bc5bcbe032b" title="Choose a member of the tree based on a uniform deviate.">find</a>(<span class="keywordtype">double</span>&amp; cumulativeFlux)<span class="keyword"> const </span>
<a name="l00197"></a>00197 <span class="keyword">            </span>{
<a name="l00198"></a>00198                 xassert(cumulativeFlux &gt;= _leftAbsFlux);
<a name="l00199"></a>00199                 xassert(cumulativeFlux &lt;= _leftAbsFlux + _absFlux);
<a name="l00200"></a>00200                 <span class="keywordflow">if</span> (!_left) {
<a name="l00201"></a>00201                     xassert(!_right);
<a name="l00202"></a>00202                     <span class="comment">// This is a leaf.  Answer is this element.</span>
<a name="l00203"></a>00203                     cumulativeFlux = (cumulativeFlux - _leftAbsFlux) * _invAbsFlux;
<a name="l00204"></a>00204                     xassert(cumulativeFlux &gt;= 0.);
<a name="l00205"></a>00205                     xassert(cumulativeFlux &lt;= 1.);
<a name="l00206"></a>00206                     <span class="keywordflow">return</span> _dataPtr;
<a name="l00207"></a>00207                 } <span class="keywordflow">else</span> {
<a name="l00208"></a>00208                     xassert(_right);
<a name="l00209"></a>00209                     <span class="keywordflow">if</span> (cumulativeFlux &lt; _right-&gt;_leftAbsFlux)
<a name="l00210"></a>00210                         <span class="keywordflow">return</span> _left-&gt;find(cumulativeFlux);
<a name="l00211"></a>00211                     <span class="keywordflow">else</span>
<a name="l00212"></a>00212                         <span class="keywordflow">return</span> _right-&gt;find(cumulativeFlux);
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214             }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216             <span class="keywordtype">double</span> getAbsFlux()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _absFlux; }
<a name="l00217"></a>00217             <span class="keywordtype">double</span> getLeftAbsFlux()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _leftAbsFlux; }
<a name="l00218"></a>00218             <span class="keyword">const</span> Element* getLeft()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _left; }
<a name="l00219"></a>00219             <span class="keyword">const</span> Element* getRight()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _right; }
<a name="l00220"></a>00220             <span class="keyword">const</span> FluxData* getData()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _dataPtr; }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222             <span class="keywordtype">bool</span> isNode()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bool(_left); }
<a name="l00223"></a>00223             <span class="keywordtype">bool</span> isLeaf()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !isNode(); }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="keyword">private</span>:
<a name="l00226"></a>00226 
<a name="l00227"></a>00227             <span class="comment">// Each Element has either a dataPtr (if it is a leaf) or left/right (if it is a node)</span>
<a name="l00228"></a>00228             <span class="keyword">const</span> FluxData* _dataPtr; 
<a name="l00229"></a>00229             Element* _left; 
<a name="l00230"></a>00230             Element* _right; 
<a name="l00231"></a>00231 
<a name="l00233"></a>00233             <span class="keywordtype">double</span> _leftAbsFlux;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235             <span class="keywordtype">double</span> _absFlux; 
<a name="l00236"></a>00236             <span class="keywordtype">double</span> _invAbsFlux; 
<a name="l00237"></a>00237 
<a name="l00238"></a>00238         };
<a name="l00239"></a>00239 
<a name="l00241"></a>00241         <span class="keyword">class </span>FluxCompare 
<a name="l00242"></a>00242         {
<a name="l00243"></a>00243         <span class="keyword">public</span>:
<a name="l00244"></a>00244             <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> FluxData&amp; lhs, <span class="keyword">const</span> FluxData&amp; rhs)<span class="keyword"> const </span>
<a name="l00245"></a>00245 <span class="keyword">            </span>{ <span class="keywordflow">return</span> std::abs(lhs.getFlux()) &gt; std::abs(rhs.getFlux()); }
<a name="l00246"></a>00246             <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> FluxData&amp; lhs, <span class="keywordtype">double</span> val)<span class="keyword"> const </span>
<a name="l00247"></a>00247 <span class="keyword">            </span>{ <span class="keywordflow">return</span> std::abs(lhs.getFlux()) &gt; val; }
<a name="l00248"></a>00248             <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> val, <span class="keyword">const</span> FluxData&amp; lhs)<span class="keyword"> const </span>
<a name="l00249"></a>00249 <span class="keyword">            </span>{ <span class="keywordflow">return</span> val &gt; std::abs(lhs.getFlux()); }
<a name="l00250"></a>00250         };
<a name="l00251"></a>00251   
<a name="l00252"></a>00252         <span class="keywordtype">void</span> buildShortcut(<span class="keyword">const</span> Element* element, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)
<a name="l00253"></a>00253         {
<a name="l00254"></a>00254             <span class="comment">// If i1 == i2, then we&apos;ve already assigned everything, so stop recursing.</span>
<a name="l00255"></a>00255             <span class="keywordflow">if</span> (i1 == i2) <span class="keywordflow">return</span>;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257             <span class="comment">// Figure out which bins in the shortcut vector should point to this element.</span>
<a name="l00258"></a>00258             <span class="comment">// On input, we are tasked with assigning indices i1 &lt;= i &lt; i2 to be either</span>
<a name="l00259"></a>00259             <span class="comment">// this element or one of its decendents.</span>
<a name="l00260"></a>00260             xassert(i1*_totalAbsFlux/_shortcut.size() &gt;= element-&gt;getLeftAbsFlux()-1.e-8);
<a name="l00261"></a>00261             xassert(i2*_totalAbsFlux/_shortcut.size() &lt;= 
<a name="l00262"></a>00262                     element-&gt;getLeftAbsFlux()+element-&gt;getAbsFlux()+1.e-8);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264             <span class="comment">// If this is a node, then the only one we should assign is the shortcut</span>
<a name="l00265"></a>00265             <span class="comment">// bin that include both left and right.  In other words the bin corresponding</span>
<a name="l00266"></a>00266             <span class="comment">// to the dividing flux.</span>
<a name="l00267"></a>00267             <span class="keywordflow">if</span> (element-&gt;isNode()) {
<a name="l00268"></a>00268                 <span class="keywordtype">double</span> <a class="code" href="_int_8h.html#a1e69c193646d41e1aed232d10b1b5d8d">f</a> = element-&gt;getRight()-&gt;getLeftAbsFlux();
<a name="l00269"></a>00269                 <span class="keywordtype">int</span> imid = int(f * _shortcut.size() / _totalAbsFlux);
<a name="l00270"></a>00270                 <span class="keywordflow">if</span> (imid &lt; i1) {
<a name="l00271"></a>00271                     <span class="comment">// Then the appropriate range is all in the right subtree</span>
<a name="l00272"></a>00272                     buildShortcut(element-&gt;getRight(), i1, i2);
<a name="l00273"></a>00273                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imid &gt;= i2) {
<a name="l00274"></a>00274                     <span class="comment">// Then the appropriate range is all in the left subtree</span>
<a name="l00275"></a>00275                     buildShortcut(element-&gt;getLeft(), i1, i2);
<a name="l00276"></a>00276                 } <span class="keywordflow">else</span> {
<a name="l00277"></a>00277                     <span class="comment">// Then there is an unassigned bin that spans both children.</span>
<a name="l00278"></a>00278                     <span class="comment">// Set it to this element.</span>
<a name="l00279"></a>00279                     assert(imid &gt;= i1);
<a name="l00280"></a>00280                     assert(imid &lt; i2);
<a name="l00281"></a>00281                     _shortcut[imid] = element;
<a name="l00282"></a>00282                     <span class="comment">// Continue on with the sub-ranges on each side.</span>
<a name="l00283"></a>00283                     buildShortcut(element-&gt;getLeft(), i1, imid);
<a name="l00284"></a>00284                     buildShortcut(element-&gt;getRight(), imid+1, i2);
<a name="l00285"></a>00285                 }
<a name="l00286"></a>00286             } <span class="keywordflow">else</span> {
<a name="l00287"></a>00287                 <span class="comment">// If we are at a leaf, then this leaf encompasses all the bins in the range.</span>
<a name="l00288"></a>00288                 <span class="comment">// Assigne them all to this element.</span>
<a name="l00289"></a>00289                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=i1; i&lt;i2; ++i) _shortcut[i] = element; 
<a name="l00290"></a>00290             }
<a name="l00291"></a>00291         }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         Element* _root;  
<a name="l00294"></a>00294         <span class="keywordtype">double</span> _totalAbsFlux; 
<a name="l00295"></a>00295 
<a name="l00299"></a>00299         std::vector&lt;const Element*&gt; _shortcut;
<a name="l00300"></a>00300     };
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 } <span class="comment">// end namespace galsim</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="preprocessor">#endif</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1</small></address>
</body>
</html>

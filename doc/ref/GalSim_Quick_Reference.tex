\documentclass[preprint,11pt]{aastex}

% packages for figures
\usepackage{graphicx,times}
% packages for symbols
\usepackage{latexsym,amssymb,hyperref}
% AMS-LaTeX package for e.g. subequations
\usepackage{amsmath}

%=====================================================================
% FRONT MATTER
%=====================================================================

\slugcomment{Draft \today}

%=====================================================================
% BEGIN DOCUMENT
%=====================================================================

\begin{document}

\setlength{\parskip}{2.0ex plus 0.5ex minus 0.5ex}
\setlength{\parindent}{0cm} 

\title{GalSim Quick Reference}

\tableofcontents

\newpage

\section{Overview}

%\emph{BARNEY TODO: Tidy this whole thing up, make it look a lot less ugly,
%maybe use an entirely different document class.}

The GalSim package provides a number of Python classes and methods for
simulating astronomical images.  We assuming GalSim is installed; see the
\href{https://github.com/GalSim-developers/GalSim/wiki}{\emph{GalSim
    Wiki}} or the file \texttt{INSTALL.md} in the base directory \texttt{/your/path/to/GalSim/}
for instructions.  The package is imported into Python with

\texttt{>>> import galsim}

and the typical work flow, as demonstrated in the example scripts in the {\tt
examples/} directory (all paths given relative to
\texttt{/your/path/to/GalSim/} from now on), will normally
be something like the following:
\begin{itemize}

\item Construct a representation of your desired astronomical object
  as an instance of the {\tt GSObject} class, which represent surface brightness profiles (of galaxies or PSFs).  Multiple components can be
  combined using the special
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_add.html}{\texttt{Add}}
  and 
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_convolve.html}{\texttt{Convolve}}
  classes --- see Section~\ref{sect:gsobjects}.
\item Apply transformations such as shears, shifts or magnification
  using the methods of the \texttt{GSObject}~ --- see Section~\ref{sect:gsobjectmethods}.
\item Draw the object into a GalSim \texttt{Image}, representing a postage
  stamp image of your astronomical object.  This can be done using the
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{obj.draw(...)}}
  or
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{obj.drawShoot(...)}}
  methods carried by all \texttt{GSObject}s for rendering images --- see
  Sections~\ref{sect:gsobjectmethods}~\&~\ref{sect:image}.
\item Add noise to the \texttt{Image}~using one of the GalSim
  random deviate classes --- see Section~\ref{sect:random}.
\item Add the postage stamp \texttt{Image}~to a subsection of a larger
  \texttt{Image} 
  instance --- see
  Section~\ref{sect:imagemethods} --- or to a Python
  \texttt{list} contaning multiple \texttt{Image} instances.
\item Save the \texttt{Image}(s) to file in FITS (Flexible Image Transport
  System) format --- see Sections~\ref{sect:imagemethods}~\&~\ref{sect:multifits}.
\end{itemize}

There are many examples of this workflow in the directory {\tt
 examples/}, showing most of the GalSim library in action, in
the scripts named \texttt{demo1.py} -- \texttt{demo8.py}.  This
document provides a brief, reference description of the GalSim classes
and methods which can be used in these workflows.

Where possible in the following Sections this document has been hyperlinked to the online
GalSim documentation generated by \emph{doxygen} where a more detailed
description can be found.  We also suggest accessing the full docstrings for the \emph{all} the
classes and functions descrbed below in Python itself, e.g.\ by typing

{\tt >>> print galsim.<ObjectName>.\_\,\_doc\_\,\_}

within the Python interpreter.  If using the \emph{ipython} package,
which is recommended, instead simply type

{\tt In [1]: galsim.<ObjectName>?}

and be sure to use the excellent tab-completion feature to explore the many
methods and attributes of the GalSim classes.

\newpage

%\section{GSObject classes and methods}
\section{GSObjects}\label{sect:gsobjects}

\subsection{GSObject classes and when to use them}\label{sect:gsobjectclasses}
There are currently 13 types of \texttt{GSObject}s that represent various types of surface brightness
profiles. The first 11 listed are 
`simple' \texttt{GSObject}s that can be initialized by providing values for
their required and optional parameters.  The last two are `compound'
classes used to represent combinations of \texttt{GSObject}s.  

They are summarized in the following hyperlinked list, in which we also give
the required parameters for initializing each class in parentheses
after the class name.  For more information and initialization details for each \texttt{GSObject},
the Python docstring for each class is available within the python interpreter, for example for
\texttt{Sersic} the documentation would be accessed using 

{\tt >>> print galsim.Sersic.\_\,\_doc\_\,\_}

Alternatively follow the hyperlinks on
the class names listed below to view the documentation based
on the Python docstrings.

In the order in which
the classes appear in {\tt galsim/base.py}:
\begin{itemize}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_gaussian.html}{\texttt{galsim.Gaussian(...)}}
  \newline \emph{a 2D Gaussian light profile.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_moffat.html}{\texttt{galsim.Moffat(beta,
    ...)}}
  \newline \emph{a Moffat profile with slope parameter \texttt{beta}, used to approximate ground-based
    telescope PSFs.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_atmospheric_p_s_f.html}{\texttt{galsim.AtmosphericPSF(...)}}
  \newline \emph{currently simply an image-based
  implementation of a Kolmogorov PSF (see below), and therefore deprecated, but expected to evolve to
  store a stochastically modelled atmospheric PSF in the near future.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_airy.html}{\texttt{galsim.Airy(lam\_over\_diam,
      ...)}} \newline \emph{an Airy PSF for ideal diffraction
  through a circular aperture, parameterized by the wavelength-aperture
  diameter ratio \texttt{lam\_over\_diam}, with optional obscuration.}
\item[$\circ$] \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_kolmogorov.html}{\texttt{galsim.Kolmogorov(...)}} \newline \emph{the Kolmogorov PSF for long-exposure
  images through a turbulent atmosphere.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_optical_p_s_f.html}{\texttt{galsim.OpticalPSF(lam\_over\_diam,
      ...)}} \newline \emph{a simple model for non-ideal
  (aberrated) propagation through circular or square apertures, parameterized by the wavelength-aperture
  dimension ratio \texttt{lam\_over\_diam}, with
  optional obscuration.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_pixel.html}{\texttt{galsim.Pixel(xw,
    ...)}} \newline \emph{used for integrating light onto square or
  rectangular pixels, requires at least one side dimension \texttt{xw}.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_sersic.html}{\texttt{galsim.Sersic(n,
    ...)}} \newline\emph{ the S\'{e}rsic family of galaxy light
  profiles, parameterized by an index \texttt{n}.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_exponential.html}{\texttt{galsim.Exponential(...)}}
  \newline \emph{the Exponential galaxy disc profile, a S\'{e}rsic with index \texttt{n=1}.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_de_vaucouleurs.html}{\texttt{galsim.DeVaucouleurs(...)}}
  \newline \emph{the De Vaucouleurs galaxy bulge profile, a S\'{e}rsic with index \texttt{n=4}.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_real_galaxy.html}{\texttt{galsim.RealGalaxy(real\_galaxy\_catalog,
      ...)}} \newline \emph{models galaxies using real
  data, including a correction for the original PSF.  Requires the
  download of external data, stored and input in \texttt{real\_galaxy\_catalog} (an instance of the
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1real_1_1_real_galaxy_catalog.html}{\texttt{RealGalaxyCatalog}}
  class), for full functionality.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_add.html}{\texttt{galsim.Add(...)}}
  \newline \emph{a \emph{compound} object representing the sum of 
  multiple \texttt{GSObject}s.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_convolve.html}{\texttt{galsim.Convolve(...)}}
  \newline \emph{a \emph{compound} object representing the convolution of 
multiple \texttt{GSObject}s.}
\end{itemize}

Note that all of the \texttt{GSObject}s except for \texttt{RealGalaxy}, \texttt{Add}, and
\texttt{Convolve} {\em require} the specification of some radius parameter, where the choice of
possible radii to specify (e.g., half-light radius, FWHM, etc.) is given in the documentation for
the class.

\subsection{Units}
The choice of units for these size specifications is up to the user,
but it must be kept consistent between all \texttt{GSObjects}.  These
units must also adopted when specifying the \texttt{Image} sample
rate \texttt{dx}, whether this is set via the \texttt{GSObject}
instance methods \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{obj.draw(...)}}
and
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{obj.drawShoot(...)}}
(see Section~\ref{sect:gsobjectmethods}),
or when setting the scale of an \texttt{Image} with a given
\texttt{dx} using the \texttt{image.setScale(dx)} method (see Section~\ref{sect:image}).

As an example, consider the
\texttt{lam\_over\_diam} parameter which provides an angular scale for
the \texttt{Airy} via
the ratio $\lambda / D$ for light at wavelength $\lambda$ passing
through a telescope of diameter $D$. Putting both $\lambda$ and
$D$ in metres and taking the ratio gives \texttt{lam\_over\_diam} in
radians, but this is not a commonly used angular scale when describing
astronomical objects such as galaxies and stellar PSFs, nor is
it often used for image pixel scales.  If wishing to use arcsec, which
is more common in both cases, the user should multiply the result in
radians by the conversion factor
$648000 / \pi$.  In principle, however, any consistent
system of units could be used.\footnote{Unfortunately, as it happens, there is
  currently an issue in the use of \texttt{OpticalPSF} with very small
  numerical values
  of \texttt{lam\_over\_diam}, such as those which would be needed if using
  radians as the system of units.  This will hopefully be fixed soon.}


\subsection{Important GSObject methods}\label{sect:gsobjectmethods}
A number of methods are shared by all the \texttt{GSObject}s of
Section~\ref{sect:gsobjects}, and are also to be found in \\ {\tt
 galsim/base.py} within the definition of the
\texttt{GSObject} base class.  In what follows, we assume that a
\texttt{GSObject} labelled \texttt{obj} has been instantiated using
one of the calls described in the documentation linked above.  For
example,

{\tt >>> obj = galsim.Sersic(n=3.5, half\_light\_radius=1.743)}.

One important fact about \texttt{GSObject}s is that all of the
methods which change the properties of the astronomical object
representend by the instance (e.g., \texttt{setFlux()},
  \texttt{applyShear()} etc.) also make fundamental changes to the
  instance itself.  In most cases this will mean that special methods
  available to individual classes described in Section
  \ref{sect:gsobjectclasses}, such as \texttt{getFWHM()} for the
  \texttt{Moffat}, will be unavailable.

Some of the most important and commonly-used methods for such an
instance are:
\begin{itemize}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#aa0b398d4b0fca70211e4a73f81ea7e1a}{\texttt{obj.copy()}}
  \newline \emph{return a copy of the \texttt{GSObject}.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8}{\texttt{obj.centroid()}}
  \newline \emph{return the $(x, y)$ centroid of the \texttt{GSObject} as a
    \texttt{PositionD} (see Section~\ref{sect:bounds}).}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a662d8ce421ecd90080bdcaaf6890aed8}{\texttt{obj.getFlux()}}
  \newline \emph{get the flux of the \texttt{GSObject}.}
\item[$\circ$]\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#af4193645a9af52e7d54a044cafec8ab9}{\texttt{obj.scaleFlux(flux\_ratio)}}
  \newline \emph{multiply the flux of the \texttt{GSObject}~by \texttt{flux\_ratio}.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a1993652591ddc802b734186391b28894}{\texttt{obj.setFlux(flux)}}
    \newline \emph{set the flux of the \texttt{GSObject}~to \texttt{flux}.}
\item[$\circ$]
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ad491a1276fda07b148c6466d5dbd07b1}{\texttt{obj.applyTransformation(ellipse)}}
\newline \emph{apply an \texttt{Ellipse} transformation represented by
  \texttt{ellipse} to the \texttt{GSObject} (see \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1ellipse_1_1_ellipse.html}{\texttt{Ellipse}}; Section~\ref{sect:shears}).}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a4301c73bbc1491ebb170e64c509cadd5}{\texttt{obj.applyDilation(scale)}}
  \newline \emph{change of the linear size of the \texttt{GSObject}~by a
    factor \texttt{scale}, conserving flux.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a9d13b0238057f6d5d01f2681d91c09b0}{\texttt{obj.applyMagnification(scale)}}
  \newline \emph{dilate linear size by \texttt{scale} and multiply total flux by
  \texttt{scale}$^2$, conserving surface brightness.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a85cc0094dcf470cfbff93d9830ab80bd}{\texttt{obj.applyShear(...)}}
  \newline \emph{apply a shear to the \texttt{GSObject}, handling a number of different
  input conventions (see also 
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1shear_1_1_shear.html}{\texttt{Shear}};
  Section~\ref{sect:shears}).  Commonly-used input conventions:
   \begin{itemize}
  \item \texttt{obj.applyShear(g1, g2)} \\
    apply the first (\texttt{g1}) and second (\texttt{g2}) component
    of a shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{obj.applyShear(e1, e2)} \\
   apply the first (\texttt{e1}) and second (\texttt{e2}) component
    of a shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{obj.applyShear(g, beta)} \\
   apply magnitude (\texttt{g}) and polar angle (\texttt{beta}) of a
   shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{obj.applyShear(e, beta)} \\
    apply magnitude (\texttt{e}) and polar angle (\texttt{beta}) of a
   shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \end{itemize}}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ad6236e3153f23f1201396369dd67f1c7}{\texttt{obj.applyRotation(theta)}}
  \newline \emph{apply a rotation of \texttt{theta} (positive direction
  anti-clockwise) to the \texttt{GSObject}, where \texttt{theta} is an
  \texttt{Angle} instance (see Section~\ref{sect:angles}).}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a6b547741eeec4086de9abe227dae9325}{\texttt{obj.applyShift(dx,
      dy)}} \newline \emph{apply a $(dx, dy)$ position shift to the
    \texttt{GSObject} centroid.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{obj.draw(...,
      dx=1)}}
  \newline \emph{draw an image of the \texttt{GSObject}~using Discrete Fourier
  Transforms and interpolation to perform the image rendering.  The
  optional image sample scale \texttt{dx} (default \texttt{dx~=~1})
  should use the same units as used for the \texttt{GSobject} size parameters.}
\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{obj.drawShoot(image,
      ..., dx=1)}}
  \newline \emph{draw an image of the \texttt{GSObject}~by shooting a finite number of
  photons into a user-supplied \texttt{Image} instance,
  \texttt{image}, which unlike for \texttt{draw()} is a required input.  The resulting rendering
  therefore contains stochastic noise, but uses few approximations. The
  optional image sample scale \texttt{dx} (default \texttt{dx~=~1})
  should use the same units as used for the \texttt{GSobject} size parameters.}
\end{itemize}
Once again, for more information regarding each \texttt{galsim.GSObject}~method,
the Python docstring is available

{\tt >>> print obj.<methodName>.\_\,\_doc\_\,\_}

within the Python interpreter.  Alternatively follow the hyperlinks on
the class names above to view the documentation based
on the Python docstrings.  You will see that many of the \texttt{GSObject}
instances also have their own specialized methods, often for
retreiving parameter values. Examples are
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_gaussian.html#a418f2826a7b8934cfedc181de23ce826}{\texttt{obj.getSigma()}}
for the
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_gaussian.html}{\texttt{Gaussian}},
or
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_sersic.html#ad6ca39293c6b478fc052d07ea51d086f}{\texttt{obj.getHalfLightRadius()}}
for many of the \texttt{GSObject}s.

\section{Random deviates}\label{sect:random}
\subsection{Random deviate classes and when to use them}
Random deviates will be used when wishing to add a stochastic
component to the modelling of astronomical images, such as drawing
object parameters according to a given distribution or generating random
numbers to be added to image pixel values to model noise. 

A short summary of the 8 random deviates currently implemented in GalSim,
with a short description of their distributions, parameterizations and
default parameter values:
\begin{itemize}

\item[$\circ$] \texttt{galsim.UniformDeviate(...)} \newline \emph{uniform distribution in the
  interval $[0, 1)$.}

\item[$\circ$] \texttt{galsim.GaussianDeviate(..., mean=0., sigma=1.)} \newline \emph{Gaussian distribution
with \texttt{mean} and standard deviation \texttt{sigma}.}

\item[$\circ$] \texttt{galsim.BinomialDeviate(..., N=1, p=0.5)} \newline \emph{Binomial
    distribution for \texttt{N} trials each of probability \texttt{p}.}

\item[$\circ$] \texttt{galsim.PoissonDeviate(..., mean=1.)} \newline \emph{Poisson distribution
    with a single \texttt{mean} rate.}

\item[$\circ$] \texttt{galsim.CCDNoise(..., gain=1., read\_noise=0.)}  \newline \emph{a
    basic detector noise model, parameterized by \texttt{gain} and \texttt{read\_noise}.}

\item[$\circ$] \texttt{galsim.WeibullDeviate(..., a=1., b=1.)} \newline \emph{Weibull distribution
    family (includes Rayleigh and Exponential) with shape parameters \texttt{a} and \texttt{b}.}

\item[$\circ$] \texttt{galsim.GammaDeviate(..., alpha=1., beta=1.)} \newline \emph{Gamma distribution with
    parameters \texttt{alpha} and \texttt{beta}.}

\item[$\circ$] \texttt{galsim.Chi2Deviate(..., n=1.)} \newline \emph{$\chi^2$ distribution
    with degrees-of-freedom parameter \texttt{n}.}

\end{itemize}

It is possible to specify the random seed so as to get fully
deterministic behavior of the noise when running a particular script.
Unfortunately the random deviate classes are not yet fully integrated
within the documentation, due to their being C++ with compiled Python
wrappers.  This means that the class names above and methods below are
not yet hyperlinked.  However, the full docstrings are available in
\texttt{galsim/random.py}, so please refer there for more information,
or type

{\tt >>> print galsim.<RandomDeviateName>.\_\,\_doc\_\,\_}

within the Python interpreter.

\subsection{Important random deviate methods}\label{sect:randommethods}
We now illustrate the most commonly-used methods of the random
deviates, assuming that some random deviate instance \texttt{dev} has
been instantiated, for example by

{\tt >>> dev = galsim.GaussianDeviate(sigma=3.9, mean=50.)}.

The two most important and commonly-used methods for such an
instance are:
\begin{itemize}

\item[$\circ$] \texttt{dev.applyTo(image)} \newline \emph{adds a
    random number, distributed according to the distribution
    represented by \texttt{dev}, to each element in a supplied
    \texttt{Image} instance \texttt{image} (see
    Section~\ref{sect:image}).}

\item[$\circ$] \texttt{dev()} \newline \emph{calling the deviate
    directly simply returns a single new random number drawn from the
    distribution
    represented by \texttt{dev}.  As an example:\newline \\
    {\tt >>> dev = galsim.UniformDeviate()}\\
    {\tt >>> dev()} \\
    {\tt 0.35068059829063714} \\
    {\tt >>> dev() }\\
    {\tt 0.56841182382777333}}

\end{itemize}

\section{Images}\label{sect:image}

\subsection{Image classes and when to use them}
The GalSim \texttt{Image} classes store array data, along with a
figure for the pixel separation in physical units and image bounds
information (origin, extent).  The \texttt{ImageView} provides a
mutable view into \texttt{Image} instance data (although not all
\texttt{Image} methods are available), and
\texttt{ConstImageView} an immutable view into \texttt{Image} instance
data.

If creating these objects directly you will mostly only need to use
\texttt{Image} instances.  The \texttt{ImageView} classes are most
commonly encountered as the output of the \texttt{GSObject} instance
methods
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#ae0b346a8b438dedbc7f60a52220869d8}{\texttt{obj.draw(...)}}
and
\href{http://galsim-developers.github.com/GalSim/classgalsim_1_1base_1_1_g_s_object.html#a42ac334d2840ba3fa832988e998beca0}{\texttt{obj.drawShoot(...)}}.
Both \texttt{Image} and \texttt{ImageView} instances can be operated
on to add stochastic noise simulating real astronomical images (see
Section~\ref{sect:random}), and have methods for writing to FITS
format output.

There are several types of GalSim \texttt{Image}, one for each of four
supported array data types:
\begin{itemize}

\item[$\circ$] \texttt{galsim.ImageS(...)}; \texttt{galsim.ImageViewS(...)};
  \texttt{galsim.ConstImageViewS(...)} \newline \emph{for short integers (typically 16 bit).}

\item[$\circ$] \texttt{galsim.ImageI(...)}; \texttt{galsim.ImageViewI(...)};
  \texttt{galsim.ConstImageViewI(...)} \newline \emph{for integers (typically 32 bit).}

\item[$\circ$] \texttt{galsim.ImageF(...)}; \texttt{galsim.ImageViewF(...)};
  \texttt{galsim.ConstImageViewF(...)} \newline \emph{for single precision (typically 32 bit)
  floats.}

\item[$\circ$] \texttt{galsim.ImageD(...)}; \texttt{galsim.ImageViewD(...)};
  \texttt{galsim.ConstImageViewD(...)} \newline \emph{for double precision (typically 64 bit)
  floats.}

\end{itemize}
To access the data as a Numpy array, simply use the \texttt{img.array}
attribute, where \texttt{img} is an instance of one of these
\texttt{Image} classes.  However, note that the individual elements in
the array attribute are accessed as \texttt{img.array[y,x]}, matching
the standard NumPy convention, while the \texttt{Image} class's own
accessors are all $(x,y)$ in ordering.

Unfortunately the \texttt{Image} classes are not yet fully integrated
within the online documentation, due to their being in C++ with
compiled Python wrappers.  This means that the class names above and
methods below are not hyperlinked.  However, the full docstrings are
available in \texttt{galsim/image.py}, so please refer there for more
information, or type

{\tt >>> print galsim.<ImageName>.\_\,\_doc\_\,\_}

within the Python interpreter.

\subsection{Important Image methods and operations}\label{sect:imagemethods}
We now illustrate the most commonly-used methods of \texttt{Image}
class instances.  We will assume that some \texttt{Image} instance
\texttt{img} has been instantiated, for example by

{\tt img = galsim.ImageD(100, 100)}.

This \texttt{Image} instance is then ready to pass to a
\texttt{GSObject} for drawing.  The most important and commonly-used
methods for such an instance are:
\begin{itemize}

\item[$\circ$] \texttt{img.getScale()} \newline \emph{get the sample
    scale \texttt{dx} for this image.}

\item[$\circ$] \texttt{img.setScale(dx)} \newline \emph{set the sample
    scale for this image to \texttt{dx} --- note that this scale
    should use the same units adopted for the \texttt{GSObject}
    sizes.}

\item[$\circ$] \texttt{img.addNoise(dev)} \newline \emph{this adds
    stochastic noise, distributed as represented by the random deviate
    instance \texttt{dev}, to each element of the data array in
    \texttt{imv}.  This therefore has the same effect as
    \texttt{dev.applyTo(image)} (see Section~\ref{sect:random}; also
    \texttt{galsim/noise.py}).}

\item[$\circ$] \texttt{img.write(fits, ...)}  \newline \emph{write the
    \texttt{imageView} to a FITS file or object as determined by the
    \texttt{fits} input parameter
    (see \\
    \texttt{galsim/fits.py}).  In Section~\ref{sect:multifits} we
    discuss how to write to multi-extension FITS files.}

\end{itemize}

The \texttt{ImageView} classes are also returned when accessing a
sub-section of an existing \texttt{Image}.  For example

{\tt >>> imv = img.subImage(bounds)}

where \texttt{bounds} is a \texttt{BoundsI} instance (see Section
\ref{sect:bounds}) assigns \texttt{imv} as an \texttt{ImageView} into
the sub-region of \texttt{img} lying in the area represented by
\texttt{bounds}.  Equivalent syntax is also

{\tt >>> imv = img[bounds]}.

It is also possible to change the values of a sub-region of an image
this way, for example

{\tt >>> img[imv.bounds] += imv}

if wishing to add the contents of \texttt{imv} to the area lying
within its bounds in \texttt{img}.  Note that here we have made use of
the \texttt{.bounds} attribute carried by all of the \texttt{Image}
classes.

\section{Miscellaneous classes and functions}\label{sect:misc}

A summary of miscellaneous GalSim library objects, subcategorized into
broad themes.  As ever, docstrings for the \emph{all} the classes and
functions below can be accessed via

{\tt >>> print galsim.<Name>.\_\,\_doc\_\,\_}

within the Python interpreter.

\subsection{Angles}\label{sect:angles}
\begin{itemize}

\item[$\circ$] \texttt{galsim.Angle(value, angle\_unit)} \newline
  \emph{class to represent angles and handle multiple unit types,
    which can be initialized very simply by a multipling a numerical
    value and an \texttt{AngleUnit} instance \texttt{angle\_unit} (see
    below, and \texttt{galsim/angle.py}).}

\item[$\circ$] \texttt{galsim.AngleUnit(radians)} \newline \emph{class
    for holding angular unit definitions, specified on initialization
    in \texttt{radians}.  There are five built-in AngleUnits which are
    always available for use:
 \begin{itemize}
 \item {\tt galsim.radians \# = galsim.AngleUnit(1.)}
 \item {\tt galsim.degrees \# = galsim.AngleUnit(pi / 180.)}
 \item {\tt galsim.hours \# = galsim.AngleUnit(pi / 12.)}
 \item {\tt galsim.arcmin \# = galsim.AngleUnit(pi / 180. / 60.)}
 \item {\tt galsim.arcsec \# = galsim.AngleUnit(pi / 180. / 3600.)}
 \end{itemize}}
\end{itemize}

\subsection{Bounds and Positions}\label{sect:bounds}

\begin{itemize}

\item[$\circ$] \texttt{galsim.BoundsI(...)} \&
  \texttt{galsim.BoundsD(...)} \newline \emph{classes to represent
    image bounds in the \texttt{x}-\texttt{y} plane as the vertices of
    a rectangle (see \texttt{galsim/bounds.py}).}

\item[$\circ$] \texttt{galsim.PositionI(x, y)} \&
  \texttt{galsim.PositionD(x, y)} \newline \emph{classes to represent
    2D positions on the \texttt{x}-\texttt{y} plane (see
    \texttt{galsim/position.py}), e.g., for describing object centroid
    positions.}

\end{itemize}

\subsection{Shear and Ellipse transformations}\label{sect:shears}

\begin{itemize}

\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1ellipse_1_1_ellipse.html}{\texttt{galsim.Ellipse(...)}}
  \newline \emph{class to represent ellipses and thus ellipse-type
    transformations.  The class can be initialized using a variety of
    different parameter conventions (see \texttt{galsim/ellipse.py}),
    including being initialized with a Shear instance (see below).}

\item[$\circ$]
  \href{http://galsim-developers.github.com/GalSim/classgalsim_1_1shear_1_1_shear.html}{\texttt{galsim.Shear(...)}}
  \newline \emph{class to represent shears in a variety of ways.  Like
    the \texttt{galsim.Ellipse}, this class can be initialized using a
    variety of different parameter conventions (see
    \texttt{galsim/shear.py}).  Commonly-used examples:
   \begin{itemize}
  \item \texttt{galsim.Shear(g1, g2)} \\
    set via the first (\texttt{g1}) and second (\texttt{g2}) component
    of a shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{galsim.Shear(e1, e2)} \\
   set via the first (\texttt{e1}) and second (\texttt{e2}) component
    of a shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{galsim.Shear(g, beta)} \\
   set via magnitude (\texttt{g}) and polar angle (\texttt{beta}) of a
   shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \item \texttt{galsim.Shear(e, beta)} \\
    set via magnitude (\texttt{e}) and polar angle (\texttt{beta}) of a
   shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
    $b$ are the semi-major and semi-minor axes of an ellipse.
   \end{itemize}}

\end{itemize}

\subsection{Multiple image FITS output tools}\label{sect:multifits}

\begin{itemize}

\item[$\circ$] \texttt{galsim.fits.writeMulti(image\_list, fits, ...)}
  \newline 
\emph{write multiple \texttt{Image} instances stored in a
  Python \texttt{list} object \texttt{image\_list} to a Multi-Extension FITS
  file or object as determined by the \texttt{fits} input parameter (see
  \texttt{galsim/fits.py}).}

\item[$\circ$] \texttt{galsim.fits.writeCube(image\_list, fits, ...)}
  \newline 
\emph{write multiple \texttt{Image} instances stored in a
  Python \texttt{list} object \texttt{image\_list} to a three-dimensional FITS
  datacube object as determined by the \texttt{fits} input parameter (see
  \texttt{galsim/fits.py}).}

\end{itemize}

\end{document}

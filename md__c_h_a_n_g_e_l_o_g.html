<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GalSim: Changes from v1.0 to v1.1:</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Changes from v1.0 to v1.1: </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Python layer API changes:</p>
<ul>
<li>Changed the name of the <code>dx</code> parameter in the <code>draw</code>, <code>drawShoot</code>, <code>drawK</code> methods of <code>GSObject</code> and the constructors of <code>InterpolatedImage</code> and <code>CorrelatedNoise</code> to the name <code>scale</code>. (Issue #364)</li>
<li>Changed the <code>xw</code> and <code>yw</code> parameters of the <code>Pixel</code> constructor to a single <code>scale</code> parameter. (Issue #364)<ul>
<li><code>pix = Pixel(xw=scale)</code> should now be either <code>pix = Pixel(scale=scale)</code> or simply <code>pix = Pixel(scale)</code>.</li>
</ul>
</li>
<li>Added new <code>Box</code> class to take up the functionality that had been <code>Pixel</code> with unequal values of <code>xw</code> and <code>yw</code>. (Issue #364)<ul>
<li><code>box = Pixel(xw=width, yw=height)</code> should now be either <code>box = Box(width=width, height=height)</code> or <code>box = Box(width, height)</code>.</li>
</ul>
</li>
<li>Changed the <code>dx_cosmos</code> parameter of <code>getCOSMOSNoise</code> to <code>cosmos_scale</code>. (Issue #364)</li>
<li>Combined the old <code>Image</code>, <code>ImageView</code> and <code>ConstImageView</code> arrays of class names into a single python layer <code>Image</code> class that automatically constructs the appropriate C++ image class as an attribute. (Issue #364)<ul>
<li><code>im = ImageF(...)</code> and similar is still valid.</li>
<li><code>im = ImageF(...)</code> <em>may</em> now be written as <code>im = Image(...)</code>. That is, the numpy.float32 type is the default data type if you do not specify something else either through the type letter or the <code>dtype</code> parameter.</li>
<li><code>im = ImageViewF(...)</code> and similar should now be <code>im = ImageF(...)</code> (preserving the same type letter S, I, F or D).</li>
<li><code>im = ConstImageViewF(...)</code> and similar should now be <code>im = ImageF(..., make_const=True)</code> (again preserving the type letter).</li>
<li><code>im = Image[type](...)</code> should now be <code>Image(..., dtype=type)</code></li>
<li><code>im = ImageView[type](numpy_array.astype(type))</code> should now be <code>im = Image(numpy_array.astype(type))</code>. i.e. the data type inherits from the numpy_array argument when appropriate. If it is already the correct type, you do not need the <code>astype(type)</code> part.</li>
<li><code>im = ConstImageView[type](numpy_array.astype(type))</code> should now be <code>im = Image(numpy_array.astype(type), make_const=True)</code></li>
</ul>
</li>
<li>Changed the handling of the <code>scale</code> and <code>init_value</code> parameters of the <code>Image</code> constructor, so that now they have to be named keyword arguments rather than positional arguments. (Issue #364)<ul>
<li><code>im = ImageF(nx, ny, scale, init_val)</code> should now be <code>im = ImageF(nx, ny, scale=scale, init_value=init_val)</code>.</li>
</ul>
</li>
<li>Removed the <code>im.at(x,y)</code> syntax. This had been equivalent to <code>im(x,y)</code>, so any such code should now be switched to that. (Issue #364)</li>
<li>Changed <code>Angle.wrap()</code> to return the wrapped angle rather than modifying the original. (Issue #364)<ul>
<li><code>angle.wrap()</code> should now be <code>angle = angle.wrap()</code>.</li>
</ul>
</li>
<li>Removed the previously deprecated <code>Ellipse</code> and <code>AtmosphericPSF</code> classes. Also removed <code>PhotonArray</code> from the python layer, since it is only used by the C++ layer. (Issue #364)</li>
<li>Changed Bounds methods <code>addBorder</code>, <code>shift</code>, and <code>expand</code> to return new Bounds objects rather than changing the original (in the python layer only). (Issue #364)</li>
<li>Changed DES_PSFEx class to take in the original image file to get the correct WCS information to convert from image coordinates to world coordinates. If unavailable, then the returned PSF profiles will be in image coordinates. The old <code>scale</code> parameter in <code>psfex.getPSF</code> is obsolete since it is not really accurate. The new behavior accurately converts the PSFEx profile between image and world coordinates.<ul>
<li><code>psfex = galsim.des.DES_PSFEx(psf_file)</code> <code>psf = psfex.getPSF(pos, scale)</code> should become <code>psfex = galsim.des.DES_PSFEx(psf_file, image_file)</code> <code>psf = psfex.getPSF(pos)</code>.</li>
</ul>
</li>
</ul>
<p>New WCS classes: (Issue #364)</p>
<ul>
<li>Every place in the code that can take a <code>scale</code> parameter (e.g. the <code>Image</code> constructor, <code>GSObject.draw()</code>, <code>InterpolatedImage</code>, etc.) can now take a <code>wcs</code> parameter. The <code>scale</code> parameter is still an option, but now it is just shorthand for <code>wcs = PixelScale(scale)</code>.</li>
<li>There are three LocalWCS classes that have a common origin for image and world coordinates:<ul>
<li><code>PixelScale</code> describes a simple scale conversion from pixels to arcsec.</li>
<li><code>ShearWCS</code> describes a uniformly sheared coordinate system.</li>
<li><code>JacobianWCS</code> describes an arbitrary 2x2 Jacobian matrix.</li>
</ul>
</li>
<li>There are three non-local UniformWCS classes that have a uniform pixel size and shape, but not necessarily the same origin.<ul>
<li><code>OffsetWCS</code> is a <code>PixelScale</code> with the world (0,0) location offset from the (0,0) position in image coordinates.</li>
<li><code>OffsetShearWCS</code> is a <code>ShearWCS</code> with a similar offset.</li>
<li><code>AffineTransform</code> is a <code>JacobianWCS</code> with an offset. It is the most general possible <em>uniform</em> WCS transformation. i.e. one where the pixel shape is uniform across the image.</li>
</ul>
</li>
<li>There is one non-uniform EuclideanWCS class that uses Euclidean coordinates for the world coordinate system:<ul>
<li><code>UVFunction</code> is an arbitrary transformation from (x,y) coordinates to Euclidean (u,v) coordinates. It takes arbitrary functions u(x,y) and v(x,y) as inputs. (And optionally x(u,v) and y(u,v) for the inverse transformations.)</li>
</ul>
</li>
<li>There are five CelestialWCS classes that use celestial coordinates for the world coordinate system. i.e. the world coordinates are in terms of right ascension and declination (RA, Dec). There is a new CelestialCoord class that encapsulates this kind of position on the sphere.<ul>
<li><code>RaDecFunction</code> takes an arbitrary function radec_func(x,y) that returns the RA and Dec.</li>
<li><code>AstropyWCS</code> uses the astropy.wcs package to read in a given FITS file.</li>
<li><code>PyAstWCS</code> uses the starlink.Ast package to read in a given FITS file.</li>
<li><code>WcsToolsWCS</code> uses wcstools commands for a given FITS file.</li>
<li><code>GSFitsWCS</code> is GalSim code to read FITS files that use TAN and TPV WCS types. Less flexible than the others, but still useful since these are probably the most common WCS types for optical astronomical images. Plus it is quite a bit faster than the others.</li>
</ul>
</li>
<li>There is a factory function called <code>FitsWCS</code> that will try the various classes that can read FITS files until it finds one that works. It will revert to <code>AffineTransform</code> if it cannot find anything better.</li>
<li>Another function, <code>TanWCS</code>, acts like a WCS class. It builds a WCS using TAN projection and returns a <code>GSFitsWCS</code> implementing it.</li>
<li>When reading in an image from a FITS file, the image will automatically try to read the WCS information from the header with the <code>FitsWCS</code> function.</li>
</ul>
<p>See the docstring for <code>BaseWCS</code> (the base class for all of these WCS classes) for information about how to use these classes. Also, check out demo3, demo9, demo10, and demo11 for example usage.</p>
<p>New <code>CelestialCoord</code> class: (Issue #364)</p>
<ul>
<li>This class describes a position on the celestial sphere according to RightAscension (RA) and Declination (Dec). These two values are accessible as coord.ra and coord.dec. So it is used by some of the WCS classes for the world coordinate positions.</li>
<li>It has methods to handle a number of spherical trigonometry operations that are sometimes required when dealing with celestial coordinates:<ul>
<li><code>coord1.distanceTo(coord2)</code> returns the great circle distance between two coordinates (as a <code><a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">galsim.Angle</a></code>).</li>
<li><code>coord1.angleBetween(coord2,coord3)</code> returns the angle between the two great circles (coord1-coord2) and (coord1-coord3).</li>
<li><code>coord1.project(coord2)</code> applies a tangent plane projection of coord2 with respect to the tangent point coord1 using one of 4 possible projection schemes specified by the optional keyword <code>projection</code>: lambert, stereographic, gnomonic, or postel. See the docstring for this function for details.</li>
<li><code>coord1.deproject(pos)</code> reverses the projection to go from the position on the tangent plane back to celestial coordinates.</li>
<li><code>coord.precess(from_epoch, to_epoch)</code> precesses the coordinates to a different epoch.</li>
<li><code>coord.getGalaxyPos()</code> returns the longitude and latitude in the galactic coordinate system as a tuple (el, b).</li>
</ul>
</li>
</ul>
<p>New chromatic functionality: (Issue #467)</p>
<ul>
<li>New <code>Bandpass</code> class to represent throughput functions, which can either represent a complete imaging system, or the individual components thereof, such as the atmosphere, mirrors, lenses, filters, detector quantum efficiency, etc. These can be initialized from 2-column ascii files, python functions, <code>eval()</code> string expressions, or <code>galsim.LookupTable</code>s.<ul>
<li>Two methods are available to reduce the samples used to evaluate integrals over wavelength, and hence reduce the time to draw <code>ChromaticObject</code>s:<ul>
<li><code>Bandpass.truncate(blue_limit, red_limit)</code> returns a truncated Bandpass.</li>
<li><code>Bandpass.thin(rel_err)</code> Returns a thinned Bandpass that nonetheless still integrates to the unthinned result within <code>rel_err</code> relative error.</li>
</ul>
</li>
<li>Bandpasses can be multiplied and divided by other Bandpasses.</li>
</ul>
</li>
<li>New <code>SED</code> class to represent stellar and galactic spectra. These can be initialized from 2-column ascii files, python functions, <code>eval()</code> string expressions or <code>galsim.LookupTable</code>s.<ul>
<li><code>sed.withFluxDensity(flux_density, wavelength) returns an SED normalized to have</code>flux_density<code>(photons/nm) at</code>wavelength<code>. *</code>sed.withFlux(flux, bandpass)<code>returns an SED normalized to have</code>flux<code> (photons) through</code>bandpass<code>. *</code>sed.atRedshift(z)<code>will return a new SED with redshift set to</code>z`.</li>
<li>SEDs can be added and subtracted from each other, and multiplied and divided by constants and functions of wavelength.</li>
</ul>
</li>
<li>New <code>ChromaticObject</code> class to represent wavelength-dependent surface brightness profiles:<ul>
<li><code>Chromatic(gsobj, sed)</code> subclass creates a separable wavelength-dependent surface brightness profile: I.e. one that takes the form f(x, y, ) = g(x, y) * h()</li>
<li><code>gsobj * sed</code> is a shortcut for <code>Chromatic(gsobj, sed)</code>.</li>
<li>Galaxies with color gradients can be created as sums of separable chromatic profiles. E.g.: <code>gal = bulge_prof * bulge_sed + disk_prof * disk_sed</code>.</li>
<li><code>ChromaticObject.applyDilation()</code>, <code>.applyExpansion()</code>, and <code>.applyShift()</code>, can take function(s) of wavelength in nanometers as their argument(s), which can be used to create a variety of chromatic effects, for instance, a wavelength-dependent diffraction limit.</li>
<li><code>ChromaticAtmosphere(fiducial_PSF, fiducial_wave, zenith_angle)</code> will modify the monochromatic GSObject PSF <code>fiducial_PSF</code> defined at wavelength <code>fiducial_wave</code> to account for atmospheric differential chromatic refraction and Kolmogorov chromatic seeing for an observation at <code>zenith_angle</code>.</li>
<li><code>ChromaticObject</code>s are drawn with almost identical syntax to <code>GSObjects</code>. The one difference is that <code>ChromaticObject</code>s require an additional argument, (given first) which is the <code>Bandpass</code> throughput function against which to integrate over wavelength. E.g., <code>image = chroma_obj.draw(bandpass, ...)</code></li>
</ul>
</li>
<li>Added demo12.py for wavelength dependence examples.</li>
</ul>
<p>Updates to config options:</p>
<ul>
<li>Changed the previous behavior of the <code>image.wcs</code> field to allow several WCS types: 'PixelScale', 'Shear', 'Jacobian', 'Affine', 'UVFunction', 'RaDecFunction', 'Fits', and 'Tan'. (Issue #364)</li>
<li>Changed the name of <code>sky_pos</code> to <code>world_pos</code>. (Issue #364)</li>
<li>Removed <code>pix</code> top layer in config structure. Add <code>draw_method=no_pixel</code> to do what <code>pix : None</code> used to do. (Issue #364)</li>
<li>Added <code>draw_method=real_space</code> to try to use real-space convolution. This had been an option for the psf draw, but not the main draw. This is only possible if there is only one item being convolved with the pixel. (Issue #364)</li>
<li>Added ability to index <code>Sequence</code> types by any running index, rather than just the default. i.e. <code>obj_num</code>, <code>image_num</code>, or <code>file_num</code>. (Issue #364)</li>
<li>Added <code>Sum</code> type for value types for which it makes sense: float, int, angle, shear, position. (Issue #457)</li>
<li>Allowed the user to modify or add config parameters from the command line. (Issue #479)</li>
<li>Added a new <code>image.retry_failures</code> item that can be set so that if the construction of a GSObject fails for any reason, you can ask it to retry. An example of this functionality has been added to demo8. (Issue #482)</li>
<li>Added a new <code>output.retry_io</code> item that can be set so that if the output write command fails (due to hard drive overloading for example), then it will wait a second and try again. (Issue #482)</li>
<li>Changed the sequence indexing within an image to always start at 0, rather than use <code>obj_num</code> (which continues increasing through all objects in the run). Functionally, this would usually only matter if the number of objects per file or image is not a constant. If the number of objects is constant, the automatic looping of the sequencing index essentially did this for you. (Issue #487)</li>
</ul>
<p>Other new features:</p>
<ul>
<li>Sped up the gzip and bzip2 I/O by using the shell gzip and bzip2 executables if they are available on the system. (Issue #344)</li>
<li>Added some new functions to convert an angle to/from DMS strings. Sometimes handy when dealing with RA or Dec. (Issue #364)<ul>
<li><code><a class="el" href="namespacegalsim_1_1angle.html#a346b4ffc23d58626a58778a4729dc577" title="Return a DMS representation of the angle as a string: (+/-)ddmmss.decimal An optional sep parameter c...">angle.dms()</a></code> returns the angle as a string in the form +/-ddmmss.decimal.</li>
<li><code><a class="el" href="namespacegalsim_1_1angle.html#a8bc5d8b2996aa0a77e018ec3a8048a74" title="Return an HMS representation of the angle as a string: (+/-)hh:mm:ss.decimal. ">angle.hms()</a></code> returns the angle as a string in the form +/-hhmmss.decimal.</li>
<li><code>angle = DMS_Angle(str)</code> converts from a dms string to a <code><a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">galsim.Angle</a></code>.</li>
<li><code>angle = HMS_Angle(str)</code> converts from an hms string to a <code><a class="el" href="classgalsim_1_1_angle.html" title="A class representing an Angle. ">galsim.Angle</a></code>.</li>
</ul>
</li>
<li>Added <code>profile.applyTransformation(dudx, dudy, dvdx, dvdy)</code> applies a general (linear) coordinate transformation to a GSObject profile. It is a generalization of <code>applyShear</code>, <code>applyRotation</code>, etc. There is also the corresponding <code>createTransformed</code> as well. (Issue #364)</li>
<li>Added <code><a class="el" href="namespacegalsim_1_1fits.html#a9bab532310c7ff757c7182c8b04c82e4" title="Read in a Pyfits hdu_list from a FITS file, taking care of the GalSim compression options...">galsim.fits.readFile()</a></code> function, which reads a FITS file and returns the hdu_list. Normally, this is equivalent to <code>pyfits.open(file_name)</code>, but it has a <code>compression</code> option that works the same way <code>compression</code> works for the other <code><a class="el" href="namespacegalsim_1_1fits.html#abbad6f82a80bc74fb22a752af1bbd8e9" title="Now the primary read functions. ">galsim.fits.read</a>*</code> functions, so it may be convenient at times. (Issue #364)</li>
<li>Added some additional options and changed default interpolant for the lensing engine. (Issue #387)</li>
<li>Permit users to initialize <code>OpticalPSF</code> with a list or array of aberrations, as an alternative to specifying each one individually. (The innards of OpticalPSF were also rearranged to use arrays instead of individual values, but this is not important for users, just developers.) (Issue #409)</li>
<li>Added option to FitsHeader and FitsWCS to read in SCamp-style text files with the header information using the parameter <code>text_file=True</code>. (Issue #508) </li>
</ul>
</div></div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>

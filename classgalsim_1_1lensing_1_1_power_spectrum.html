<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GalSim: galsim.lensing.PowerSpectrum Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">0.3</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1lensing.html">lensing</a></li><li class="navelem"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html">PowerSpectrum</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">galsim.lensing.PowerSpectrum Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to represent a lensing shear field according to some power spectrum P(k)  
 <a href="classgalsim_1_1lensing_1_1_power_spectrum.html#details">More...</a></p>

<p><a href="classgalsim_1_1lensing_1_1_power_spectrum-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a497611be3e517f97dbf1a10b1ec813f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a497611be3e517f97dbf1a10b1ec813f6">__init__</a></td></tr>
<tr class="memitem:a8ffabf0f0163723677400baa92d2ee6c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a8ffabf0f0163723677400baa92d2ee6c">buildGriddedShears</a></td></tr>
<tr class="memdesc:a8ffabf0f0163723677400baa92d2ee6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a realization of the current power spectrum on the specified grid.  <a href="#a8ffabf0f0163723677400baa92d2ee6c"></a><br/></td></tr>
<tr class="memitem:a9c3bbbdc586176efa8200d39c6d3f328"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9c3bbbdc586176efa8200d39c6d3f328">getShear</a></td></tr>
<tr class="memdesc:a9c3bbbdc586176efa8200d39c6d3f328"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the shear values for a given list of input positions (or just a single position).  <a href="#a9c3bbbdc586176efa8200d39c6d3f328"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adbe821e6c3acd689850929f397bbc966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#adbe821e6c3acd689850929f397bbc966">e_power_function</a></td></tr>
<tr class="memitem:ad944e6a37bfda383de704ee43bc39d33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#ad944e6a37bfda383de704ee43bc39d33">b_power_function</a></td></tr>
<tr class="memitem:a8dbf3c83d354bbff213d4ca2818a58e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a8dbf3c83d354bbff213d4ca2818a58e8">delta2</a></td></tr>
<tr class="memitem:a9b3ec835a54e215e8842938ddfd3f67f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9b3ec835a54e215e8842938ddfd3f67f">scale</a></td></tr>
<tr class="memitem:a394885d25a4f58dfe80c070850e5ee8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a394885d25a4f58dfe80c070850e5ee8c">interpolant</a></td></tr>
<tr class="memitem:a6a7b9649f3dd057aef02abbfa6decb52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a6a7b9649f3dd057aef02abbfa6decb52">grid_g2</a></td></tr>
<tr class="memitem:a0c29c98e3a4feeaca3d8b52cb2fbbd57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a0c29c98e3a4feeaca3d8b52cb2fbbd57">im_g1</a></td></tr>
<tr class="memitem:aaa5c27dead8114b4e6f6c444e22f22ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#aaa5c27dead8114b4e6f6c444e22f22ec">im_g2</a></td></tr>
<tr class="memitem:a60d3a2afb7fc4229a968a48ca5367533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a60d3a2afb7fc4229a968a48ca5367533">offset</a></td></tr>
<tr class="memitem:a0f933a284671f38d65cf303d83c2a468"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a0f933a284671f38d65cf303d83c2a468">bounds</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Class to represent a lensing shear field according to some power spectrum P(k) </p>
<p>A <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> represents some (flat-sky) shear power spectrum, either for gridded points or at arbitary positions. This class is originally initialized with a power spectrum from which we would like to generate g1 and g2 values. It generates shears on a grid, and if necessary, when getShear is called, it will interpolate to the requested positions.</p>
<p>When creating a <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> instance, you need to specify at least one of the E or B mode power spectra, which is normally given as a function P(k). The typical thing is to just use a lambda function in Python (i.e., a function that is not associated with a name); for example, to define P(k)=k^2, one would use <code>lambda k : k**2</code>. But they can also be more complicated user-defined functions that take a single argument k and return the power at that k value, or they can be instances of the LookupTable class for power spectra that are known at particular k values but for which there is not a simple analytic form.</p>
<p>Cosmologists often express the power spectra in terms of an expansion in spherical harmonics (ell), i.e., the C_ell values. In the flat-sky limit, we can replace ell with k and C_ell with P(k). Thus, k and P(k) have dimensions of inverse angle and angle^2, respectively. It is quite common for people to plot ell(ell+1)C_ell/2pi, a dimensionless quantity; the analogous flat-sky quantity is Delta^2 = k^2 P(k)/2pi. By default, the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> object assumes it is getting P(k), but it is possible to instead give it Delta^2 by setting the optional keyword <code>delta2 = True</code> in the constructor.</p>
<p>Also note that we generate the shears according to the input power spectrum using a DFT approach, which means that we implicitly assume our discrete representation of P(k) on a grid is one complete cell in an infinite periodic series. We are making assumptions about what P(k) is doing outside of our minimum and maximum k range, and those must be kept in mind when comparing with theoretical expectations. Furthermore, the shear generation currently does not include sample variance due to coverage of a finite patch. In other words, we explicitly enforce <code>P(k=0)=0</code>, which is true for the full sky in any reasonable cosmological model, but it ignores the fact that our little patch of sky might reasonably live in some special region with respect to shear correlations. Our <code>P(k=0)=0</code> is essentially setting the integrated power below our minimum k value to zero (i.e., it's implicitly a statement about power in a k range, not just at <code>k=0</code> itself). Future versions of the lensing engine may change this behavior. Moreover, a full comparison of the GalSim power spectrum normalization conventions and behavior in various regimes is in the works and will be available with a future version of GalSim.</p>
<p>The power functions must return a list/array that is the same size as what it was given, e.g., in the case of no power or constant power, a function that just returns a float would not be permitted; it would have to return an array of floats all with the same value.</p>
<p>It is important to note that the power spectra used to initialize the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> object should use the same units for k and P(k), i.e., if k is in inverse radians then P(k) should be in radians^2 (as is natural for outputs from a cosmological shear power spectrum calculator). However, when we actually draw images, there is a natural scale that defines the pitch of the image (dx), which is typically taken to be arcsec. This definition of a specific length scale means that by default we assume all quantities to the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> are in arcsec, and those are the units used for internal calculations, but the <code>units</code> keyword can be used to specify different input units for P(k) (again, within the constraint that k and P(k) must be consistent). If the <code>delta2</code> keyword is set to specify that the input is actually the dimensionless power Delta^2, then the input <code>units</code> are taken to apply only to the k values.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e_power_function</td><td>A function or other callable that accepts a Numpy array of |k| values, and returns the E-mode power spectrum P_E(|k|) in an array of the same shape. The function should return the power spectrum desired in the E (gradient) mode of the image. Set to None (default) for there to be no E-mode power. It may also be a string that can be converted to a function using eval('lambda k : ' + e_power_function), a LookupTable, or file_name from which to read in a LookupTable. </td></tr>
    <tr><td class="paramname">b_power_function</td><td>A function or other callable that accepts a Numpy array of |k| values, and returns the B-mode power spectrum P_B(|k|) in an array of the same shape. The function should return the power spectrum desired in the B (curl) mode of the image. Set to None (default) for there to be no B-mode power. It may also be a string that can be converted to a function using eval('lambda k : ' + b_power_function), a LookupTable, or file_name from which to read in a LookupTable. </td></tr>
    <tr><td class="paramname">delta2</td><td>Is the power actually given as dimensionless Delta^2, which requires us to multiply by 2pi / k^2 to get the shear power P(k) in units of angle^2? [default = False] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the power spectrum (i.e. the units of k^-1 and sqrt(P)). This should be either a <a class="el" href="classgalsim_1_1_angle_unit.html" title="A class defining angle units.">galsim.AngleUnit</a> instance (e.g. <a class="el" href="namespacegalsim.html#aed8d3e3dc27c52616a6006600ec00fea" title="constant with units of radians">galsim.radians</a>) or a string (e.g. 'radians'). [default = arcsec] </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a497611be3e517f97dbf1a10b1ec813f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing.PowerSpectrum.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta2</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8ffabf0f0163723677400baa92d2ee6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing.PowerSpectrum.buildGriddedShears </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_spacing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ngrid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>galsim.PositionD(0,0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a realization of the current power spectrum on the specified grid. </p>
<p>This function will generate a Gaussian random realization of the specified E and B mode shear power spectra at a grid of positions, specified by the input parameters <code>grid_spacing</code> (distance between grid points) and <code>ngrid</code> (number of grid points in each direction.) Units for <code>grid_spacing</code> and <code>center</code> can be specified using the <code>units</code> keyword; the default is arcsec, which is how all values are stored internally.</p>
<p>Note that the convention for axis orientation differs from that for the GREAT10 challenge, so when using codes that deal with GREAT10 challenge outputs, the sign of our g2 shear component must be flipped.</p>
<p>Some examples:</p>
<ol type="1">
<li><p class="startli">Get shears on a grid of points separated by 1 arcsec: </p>
<pre class="fragment">my_ps = galsim.PowerSpectrum(lambda k : k**2)
g1, g2 = my_ps.buildGriddedShears(grid_spacing = 1., ngrid = 100)
</pre><p class="startli">The returned g1,g2 are 2-d numpy arrays of values, corresponding to the values of g1,g2 at the locations of the grid points.</p>
<p class="startli">For a given value of grid_spacing and ngrid, we could get the x and y values on the grid using </p>
<pre class="fragment">import numpy as np
min = (-ngrid/2 + 0.5) * grid_spacing
max = (ngrid/2 - 0.5) * grid_spacing
x, y = np.meshgrid(np.arange(min,max,grid_spacing),
                   np.arange(min,max,grid_spacing))
</pre><p class="startli">where the center of the grid is taken to be (0,0).</p>
</li>
<li>Rebuild the grid using a particular rng and set the location of the center of the grid to be something other than the default (0,0) <pre class="fragment">g1, g2 = my_ps.buildGriddedShears(grid_spacing = 8., ngrid = 65,
                                  rng = galsim.BaseDeviate(1413231),
                                  center = (256.5, 256.5) )
</pre></li>
<li>Make a <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> from a tabulated P(k) that gets interpolated to find the power at all necessary values of k, then generate shears on a grid. Assuming that k and P_k are either lists, tuples, or 1d Numpy arrays containing k and P(k): <pre class="fragment">tab_pk = galsim.LookupTable(k, P_k)
my_ps = galsim.PowerSpectrum(tab_pk)
g1, g2 = my_ps.buildGriddedShears(grid_spacing = 1., grid_nx = 100)
</pre></li>
</ol>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_spacing</td><td>Spacing for an evenly spaced grid of points, by default in arcsec for consistency with the natural length scale of images created using the draw or drawShoot methods. Other units can be specified using the <code>units</code> keyword. </td></tr>
    <tr><td class="paramname">ngrid</td><td>Number of grid points in each dimension. If a number that is not an int (e.g., a float) is supplied, then it gets converted to an int automatically. </td></tr>
    <tr><td class="paramname">rng</td><td>(Optional) A <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution.">galsim.GaussianDeviate</a> object for drawing the random numbers. (Alternatively, any <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates.">BaseDeviate</a> can be used.) [default <code>rng = None</code>] </td></tr>
    <tr><td class="paramname">interpolant</td><td>(Optional) <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions.">Interpolant</a> that will be used for interpolating the gridded shears by <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9c3bbbdc586176efa8200d39c6d3f328" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a> if that method is later called. [default <code>interpolant = galsim.Linear()</code>] </td></tr>
    <tr><td class="paramname">center</td><td>(Optional) If setting up a new grid, define what position you want to consider the center of that grid. Units must be consistent with those for <code>grid_spacing</code>. [default <code>center = (0,0)</code>] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>g1,g2 These are 2-d NumPy arrays corresponding to shears at the gridded positions. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c3bbbdc586176efa8200d39c6d3f328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing.PowerSpectrum.getShear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the shear values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call buildGriddedShears first to define the grid on which to interpolate. However, unlike buildGriddedShears, the getShear function can automatically convert between input units for the input positions relative to the default units (arcsec).</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears) modifies the effective power spectrum somewhat. The user is responsible for choosing a grid size that is small enough not to significantly modify the power spectrum on the scales of interest.</p>
<p>Some examples of how to use getShear:</p>
<ol type="1">
<li><p class="startli">Get the shear for a particular point: </p>
<pre class="fragment">g1, g2 = my_ps.getShear(pos = galsim.PositionD(12, 412))
</pre><p class="startli">This time the returned values are just floats and correspond to the shear for the provided position.</p>
</li>
<li>You can also provide a position as a tuple to save the explicit PositionD construction: <pre class="fragment">g1, g2 = my_ps.getShear(pos = (12, 412))
</pre></li>
<li><p class="startli">Get the shears for a bunch of points at once: </p>
<pre class="fragment">xlist = [ 141, 313,  12, 241, 342 ]
ylist = [  75, 199, 306, 225, 489 ]
poslist = [ galsim.PositionD(xlist[i],ylist[i]) for i in range(len(xlist)) ]
g1, g2 = my_ps.getShear( poslist )
g1, g2 = my_ps.getShear( (xlist, ylist) )
</pre><p class="startli">Both calls do the same thing. The returned g1, g2 this time are lists of g1, g2 values. The lists are the same length as the number of input positions.</p>
</li>
</ol>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single galsim.PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of galsim.PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist ) </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>g1,g2 If given a single position: the two shear components g_1 and g_2. If given a list of positions: each is a python list of values. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad944e6a37bfda383de704ee43bc39d33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.b_power_function</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f933a284671f38d65cf303d83c2a468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.bounds</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8dbf3c83d354bbff213d4ca2818a58e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.delta2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adbe821e6c3acd689850929f397bbc966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.e_power_function</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a7b9649f3dd057aef02abbfa6decb52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.grid_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c29c98e3a4feeaca3d8b52cb2fbbd57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.im_g1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa5c27dead8114b4e6f6c444e22f22ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.im_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a394885d25a4f58dfe80c070850e5ee8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.interpolant</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a60d3a2afb7fc4229a968a48ca5367533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.offset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b3ec835a54e215e8842938ddfd3f67f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.scale</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="lensing_8py.html">lensing.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1</small></address>
</body>
</html>

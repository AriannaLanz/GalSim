<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GalSim: galsim.lensing.PowerSpectrum Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1lensing.html">lensing</a></li><li class="navelem"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html">PowerSpectrum</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">galsim.lensing.PowerSpectrum Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to represent a lensing shear field according to some power spectrum P(k)  
 <a href="classgalsim_1_1lensing_1_1_power_spectrum.html#details">More...</a></p>

<p><a href="classgalsim_1_1lensing_1_1_power_spectrum-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a497611be3e517f97dbf1a10b1ec813f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a497611be3e517f97dbf1a10b1ec813f6">__init__</a></td></tr>
<tr class="memitem:aed4110dd3b584b9185513c0f999959a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#aed4110dd3b584b9185513c0f999959a0">set_power_functions</a></td></tr>
<tr class="memdesc:aed4110dd3b584b9185513c0f999959a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set / change the functions that compute the E and B mode power spectra.  <a href="#aed4110dd3b584b9185513c0f999959a0"></a><br/></td></tr>
<tr class="memitem:a9c3bbbdc586176efa8200d39c6d3f328"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9c3bbbdc586176efa8200d39c6d3f328">getShear</a></td></tr>
<tr class="memdesc:a9c3bbbdc586176efa8200d39c6d3f328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a realization of the current power spectrum at the specified positions.  <a href="#a9c3bbbdc586176efa8200d39c6d3f328"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a27b0f8b55775f6f42b203b82e0c7230b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a27b0f8b55775f6f42b203b82e0c7230b">p_E</a></td></tr>
<tr class="memitem:a9f7b0b85218b8d8e726f2dcbaea9910b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9f7b0b85218b8d8e726f2dcbaea9910b">p_B</a></td></tr>
<tr class="memitem:a6a7b9649f3dd057aef02abbfa6decb52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a6a7b9649f3dd057aef02abbfa6decb52">grid_g2</a></td></tr>
<tr class="memitem:a0c29c98e3a4feeaca3d8b52cb2fbbd57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a0c29c98e3a4feeaca3d8b52cb2fbbd57">im_g1</a></td></tr>
<tr class="memitem:aaa5c27dead8114b4e6f6c444e22f22ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#aaa5c27dead8114b4e6f6c444e22f22ec">im_g2</a></td></tr>
<tr class="memitem:a60d3a2afb7fc4229a968a48ca5367533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a60d3a2afb7fc4229a968a48ca5367533">offset</a></td></tr>
<tr class="memitem:a0f933a284671f38d65cf303d83c2a468"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a0f933a284671f38d65cf303d83c2a468">bounds</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Class to represent a lensing shear field according to some power spectrum P(k) </p>
<p>A <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> represents some (flat-sky) shear power spectrum, either for gridded points or at arbitary positions. This class is originally initialized with a power spectrum from which we would like to generate g1 and g2 values. When the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9c3bbbdc586176efa8200d39c6d3f328" title="Generate a realization of the current power spectrum at the specified positions.">getShear()</a> method is called, it uses a <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum_realizer.html" title="Class for generating realizations of power spectra with any area and pixel size.">PowerSpectrumRealizer</a> to generate shears on an appropriately-spaced grid, and if necessary, interpolates on that grid to the requested positions. Finally, it carries around some information about the underlying shear power spectrum used to generate the field.</p>
<p>It is important to note that the power spectrum used to initialize the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> object should be in the same units as any parameters to the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html#a9c3bbbdc586176efa8200d39c6d3f328" title="Generate a realization of the current power spectrum at the specified positions.">getShear()</a> method that define the locations at which we want to get shears. When we actually draw images, there is a natural scale that defines the pitch of the image (dx), which is typically taken to be arcsec. This definition of a specific length scale means that we should also use the same units (arcsec) for the positions at which we want our galaxies to be located when we draw shears from a power spectrum, and likewise the values of k (wavenumber) going into the power spectrum function should be inverse arcsec. To give a specific example, if we want to draw Gaussians on an image with dx=0.2" (i.e., the argument dx to the draw method will be =0.2), and if we want a grid of galaxies spaced 40 pixels apart, then when we call the getShear method of the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> class, we should use grid_spacing=8 [arcsec, =(40 pixels)*(0.2 arcsec/pixel)].</p>
<p>If the power spectrum used for this calculation comes from a standard cosmology calculator that uses units of inverse radians for the wavenumber, then it is important to convert such that the units are consistent with our choice of inverse arcsec. If there is sufficient interest from users for the code to have a "unit" class that handles conversions between the various units that one might use, then future versions of GalSim might be updated to include this functionality.</p>
<p>When creating a <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> instance, the E and B mode power spectra can optionally be set at initialization or later on with the method set_power_functions. Note that the power spectra should be a function of k. The typical thing is to just use a lambda function in Python (i.e., a function that is not associated with a name); for example, to define P(k)=k^2, one would use <code>lambda k : k**2</code>. But they can also be more complicated user-defined functions that take a single argument k and return the power at that k value. They should be power P(k), not Delta^2(k) = k^2 P(k) / 2pi.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e_power_function</td><td>A function or other callable that accepts a Numpy array of |k| values, and returns the E-mode power spectrum P_E(|k|) in an array of the same shape. It should cope happily with |k|=0. The function should return the power spectrum desired in the E (gradient) mode of the image. Set to None (default) for there to be no E-mode power. It may also be a string that can be converted to a function using eval('lambda k : ' + e_power_function) </td></tr>
    <tr><td class="paramname">b_power_function</td><td>A function or other callable that accepts a Numpy array of |k| values, and returns the B-mode power spectrum P_B(|k|) in an array of the same shape. It should cope happily with |k|=0. The function should return the power spectrum desired in the B (curl) mode of the image. Set to None (default) for there to be no B-mode power. It may also be a string that can be converted to a function using eval('lambda k : ' + b_power_function) </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the power spectrum (i.e. the units of k^-1). Currently only arcsec is implemented. </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a497611be3e517f97dbf1a10b1ec813f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing.PowerSpectrum.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9c3bbbdc586176efa8200d39c6d3f328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing.PowerSpectrum.getShear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_spacing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_nx</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>galsim.PositionD(0,0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a realization of the current power spectrum at the specified positions. </p>
<p>This function currently does two relatively separate things. The plan is to split it into two functions, but we haven't done so yet.</p>
<p>First, it will generate a Gaussian random realization of the specified E and B mode shear power spectrum at a grid of positions, specified by the input parameters <code>grid_spacing</code> (distance between grid points) and <code>grid_nx</code> (number of grid points in each direction.)</p>
<p>The normalization of the shears from a given power spectrum is defined as follows: if P_E(k)=P_B(k)=P [const], i.e., white noise in both shear components, then the shears g1 and g2 will be random Gaussian deviates with variance=P. Note that if we really had power at all k, the variance would be infinite. But we are getting shears on a grid, which has a limited k range, and hence the total power is finite. For grid spacing dx and N grid points, the spacing between k values is dk = 2pi/(N dx) and k ranges from +/-(N/2) dk. There are alternate definitions to consider, e.g., that the variance should be P*(dx)^2 for a grid spacing of dx (i.e., for fixed total grid extent, a smaller grid spacing requires smaller shear variances since the range of k values that are accessible is larger); those who input a continuum P(k) should, when predicting the behavior of shears on a grid, keep in mind our normalization convention and the fact that it's a discrete FFT. If you strongly dislike our convention and would like support for an alternate one, please indicate this on our GitHub issues page.</p>
<p>Also note that the convention for axis orientation differs from that for the GREAT10 challenge, so when using codes that deal with GREAT10 challenge outputs, the sign of our g2 shear component must be flipped.</p>
<p>Second, this function can interpolate between the grid points to find the shear values for a given list of input positions (or just a single position). This can be done in conjunction with the first functionality, in which case the grid will be computed using the <code>grid_*</code> parameters and then that new grid will be used to interpolate the shear values. Or you can omit the <code>grid_*</code> parameters, in which case the funciton will use the most recently computed grid from a previous call. Currently, if you try to interpolate a grid without having previously called <code>getShear</code> with the <code>grid_*</code> parameters, then an exception will be raised. A future version of the code will allow the estimation of shears on non-gridded points by first automatically choosing a grid spacing on which to estimate gridded shears before interpolating, but this functionality is not implemented yet.</p>
<p>Some examples of how to use getShear:</p>
<ol type="1">
<li><p class="startli">Create a grid of points separated by 1": </p>
<pre class="fragment">my_ps = galsim.PowerSpectrum(lambda k : k**2)
g1, g2 = my_ps.getShear(grid_spacing = 1., grid_nx = 100)
</pre><p class="startli">The returned g1,g2 are 2-d numpy arrays of values, corresponding to the values of g1,g2 at the locations of the grid points.</p>
<p class="startli">For a given value of grid_spacing and grid_nx, we could get the x and y values on the grid using </p>
<pre class="fragment">import numpy as np
min = (-grid_nx/2 + 0.5) * grid_spacing
max = (grid_nx/2 - 0.5) * grid_spacing
x, y = np.meshgrid(np.arange(min,max,grid_spacing),
                   np.arange(min,max,grid_spacing))
</pre><p class="startli">where the center of the grid is taken to be (0,0).</p>
</li>
<li>Same thing, but use a particular rng and set the location of the center of the grid to be something other than the default (0,0) <pre class="fragment">im = galsim.ImageF(512, 512)
g1, g2 = my_ps.getShear(grid_spacing = 8., grid_nx = 65.,
                        rng = galsim.BaseDeviate(1413231),
                        center = (256.5, 256.5) )
</pre></li>
<li><p class="startli">Use the previously created grid to get the shear for a particular point: </p>
<pre class="fragment">g1, g2 = my_ps.getShear(pos = galsim.PositionD(12, 412))
</pre><p class="startli">This time the returned values are just floats and correspond to the shear for the provided position.</p>
</li>
<li>You can also provide a position as a tuple to save the explicit PositionD construction: <pre class="fragment">g1, g2 = my_ps.getShear(pos = (12, 412))
</pre></li>
<li><p class="startli">Get the shears for a bunch of points at once: </p>
<pre class="fragment">xlist = [ 141, 313,  12, 241, 342 ]
ylist = [  75, 199, 306, 225, 489 ]
poslist = [ galsim.PositionD(xlist[i],ylist[i]) for i in range(len(xlist)) ]
g1, g2 = my_ps.getShear( poslist )
g1, g2 = my_ps.getShear( (xlist, ylist) )
</pre><p class="startli">Both calls do the same thing. The returned g1, g2 this time are lists of g1, g2 values. The lists are the same length as the number of input positions.</p>
</li>
</ol>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! (It is up to the user to check that the units are consistent with those in the P(k) function, just as for the grid_spacing keyword.) Valid ways to input this:<ul>
<li>Single galsim.PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of galsim.PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist ) pos may also be None to just build a gridded array of (g1,g2). </li>
</ul>
</td></tr>
    <tr><td class="paramname">grid_spacing</td><td>Spacing for an evenly spaced grid of points, in arcsec for consistency with the natural length scale of images created using the draw or drawShoot methods. </td></tr>
    <tr><td class="paramname">grid_nx</td><td>Number of grid points in the x dimension. </td></tr>
    <tr><td class="paramname">rng</td><td>(Optional) A <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution.">galsim.GaussianDeviate</a> object for drawing the random numbers. (Alternatively, any <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates.">BaseDeviate</a> can be used.) </td></tr>
    <tr><td class="paramname">interpolant</td><td>(Optional) <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions.">Interpolant</a> to use for interpolating the shears on a grid to the requested positions. This is highly recommended to be <a class="el" href="classgalsim_1_1_linear.html" title="Linear interpolant.">Linear</a> (which will become bi-linear, since it is in 2 dimensions). Using other interpolants is likely to be inaccurate, though on small enough scales even the linear interpolant will be problematic. A future version of the code will quantify this inaccuracy due to the interpolant in greater detail. [default = galsim.Linear()] </td></tr>
    <tr><td class="paramname">center</td><td>(Optional) If setting up a new grid, define what position you want to consider the center of that grid. [default = (0,0)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>g1,g2 If given a single position: the two shear components g_1 and g_2. If given a list of positions: each is a python list of values. If pos=None, these are 2-d NumPy arrays. </dd></dl>

</div>
</div>
<a class="anchor" id="aed4110dd3b584b9185513c0f999959a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing.PowerSpectrum.set_power_functions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set / change the functions that compute the E and B mode power spectra. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">e_power_function</td><td>See description of this parameter in the documentation for the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> class. </td></tr>
    <tr><td class="paramname">b_power_function</td><td>See description of this parameter in the documentation for the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> class. </td></tr>
    <tr><td class="paramname">units</td><td>See description of this parameter in the documentation for the <a class="el" href="classgalsim_1_1lensing_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k)">PowerSpectrum</a> class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0f933a284671f38d65cf303d83c2a468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.bounds</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a7b9649f3dd057aef02abbfa6decb52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.grid_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c29c98e3a4feeaca3d8b52cb2fbbd57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.im_g1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa5c27dead8114b4e6f6c444e22f22ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.im_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a60d3a2afb7fc4229a968a48ca5367533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.offset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f7b0b85218b8d8e726f2dcbaea9910b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.p_B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a27b0f8b55775f6f42b203b82e0c7230b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing.PowerSpectrum.p_E</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="lensing_8py.html">lensing.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1</small></address>
</body>
</html>

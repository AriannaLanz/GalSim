# Copyright (c) 2012-2014 by the GalSim developers team on GitHub
# https://github.com/GalSim-developers
#
# This file is part of GalSim: The modular galaxy image simulation toolkit.
# https://github.com/GalSim-developers/GalSim
#
# GalSim is free software: redistribution and use in source and binary forms,
# with or without modification, are permitted provided that the following
# conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions, and the disclaimer given in the accompanying LICENSE
#    file.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions, and the disclaimer given in the documentation
#    and/or other materials provided with the distribution.
#
"""Unit tests for the WFIRST module (galsim.wfirst)
"""

import numpy as np

from galsim_test_helpers import *

try:
    import galsim
    import galsim.wfirst
except ImportError:
    import os
    import sys
    path, filename = os.path.split(__file__)
    sys.path.append(os.path.abspath(os.path.join(path, "..")))
    import galsim

def test_wfirst_wcs():
    """Test the WFIRST WCS routines against those from software provided by WFIRST project office.
    """
    import time
    t1 = time.time()

    # The standard against which we will compare is the output of some software provided by Jeff
    # Kruk.  The files used here were generated by Rachel on her Macbook using the script in
    # wfirst_files/make_standards.sh, and none of the parameters below can be changed without
    # modifying and rerunning that script.  We use 4 sky positions and rotation angles (2 defined
    # using the focal plane array, 2 using the observatory coordinates), and in each case, use a
    # different SCA for our tests.  We will simply read in the stored WCS and generate new ones, and
    # check that they have the right value of SCA center and pixel scale at the center, and that if
    # we offset by 500 pixels in some direction that gives the same sky position in each case.
    ra_test = [127., 307.4, -61.52, 0.0]
    dec_test = [-70., 50., 22.7, 0.0]
    pa_test = [160., 79., 23.4, -3.1]
    sca_test = [2, 13, 7, 18]
    pa_is_fpa_test = [True, False, True, False]

    dist_arcsec = []
    dist_2_arcsec = []
    pix_area_ratio = []
    for i_test in range(len(ra_test)):
        # Make the WCS for this test.
        try:
            all_gs_wcs = galsim.wfirst.getWCS(pa_test[i_test]*galsim.degrees,
                                              ra=ra_test[i_test]*galsim.degrees,
                                              dec=dec_test[i_test]*galsim.degrees,
                                              PA_is_FPA=pa_is_fpa_test[i_test])
        except ImportError:
            print "Cannot find any software to read the WFIRST WCS.  Skipping this test."
            return
        # Read in reference.
        test_file = 'test%d_sca_%02d.fits'%(i_test+1, sca_test[i_test])
        ref_wcs = galsim.FitsWCS(os.path.join('wfirst_files',test_file))

        gs_wcs = all_gs_wcs[sca_test[i_test]]

        # Check center position:
        im_cent_pos = galsim.PositionD(galsim.wfirst.n_pix/2., galsim.wfirst.n_pix/2)
        ref_cent_pos = ref_wcs.toWorld(im_cent_pos)
        gs_cent_pos = gs_wcs.toWorld(im_cent_pos)
        dist_arcsec.append(ref_cent_pos.distanceTo(gs_cent_pos) / galsim.arcsec)

        # Check pixel area
        rat = ref_wcs.pixelArea(image_pos=im_cent_pos)/gs_wcs.pixelArea(image_pos=im_cent_pos)
        pix_area_ratio.append(rat-1.)

        # Check another position, just in case rotations are messed up.
        im_other_pos = galsim.PositionD(im_cent_pos.x+500., im_cent_pos.y)
        ref_other_pos = ref_wcs.toWorld(im_other_pos)
        gs_other_pos = gs_wcs.toWorld(im_other_pos)
        dist_2_arcsec.append(ref_other_pos.distanceTo(gs_other_pos) / galsim.arcsec)

    np.testing.assert_array_less(
        np.array(dist_arcsec),
        np.ones(len(ra_test))*galsim.wfirst.pixel_scale/100, 
        err_msg='For at least one WCS, center offset from reference was > 0.01(pixel scale).')
    np.testing.assert_array_less(
        np.array(dist_2_arcsec),
        np.ones(len(ra_test))*galsim.wfirst.pixel_scale/100, 
        err_msg='For at least one WCS, other offset from reference was > 0.01(pixel scale).')
    np.testing.assert_array_less(
        np.array(pix_area_ratio),
        np.ones(len(ra_test))*0.0001,
        err_msg='For at least one WCS, pixel areas differ from reference by >0.01%.')

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_wfirst_backgrounds():
    """Test the WFIRST background estimation routines for basic sanity.
    """
    import time
    t1 = time.time()

    # The routine should not allow us to look directly at the sun since the background there is high
    # (to understate the problem).
    bp_dict = galsim.wfirst.getBandpasses()
    bp = bp_dict['J129'] # one of the standard filters, doesn't really matter which
    try:
        np.testing.assert_raises(ValueError, galsim.wfirst.getSkyLevel, bp,
                                 e_lat=0.*galsim.degrees, e_lon=0.*galsim.degrees)
    except ImportError:
        print 'The assert_raises tests require nose'

    # The routine should have some obvious symmetry, for example, ecliptic latitude above vs. below
    # plane and ecliptic longitude positive vs. negative (or vs. 360 degrees - original value).
    test_lat = 50.*galsim.degrees
    test_lon = 180.*galsim.degrees
    level_p = galsim.wfirst.getSkyLevel(bp, e_lat=test_lat, e_lon=test_lon)
    level_m = galsim.wfirst.getSkyLevel(bp, e_lat=-test_lat, e_lon=test_lon)
    np.testing.assert_almost_equal(level_m, level_p, decimal=8)

    level_m = galsim.wfirst.getSkyLevel(bp, e_lat=test_lat, e_lon=-test_lon)
    np.testing.assert_almost_equal(level_m, level_p, decimal=8)

    level_m = galsim.wfirst.getSkyLevel(bp, e_lat=test_lat, e_lon=360.*galsim.degrees-test_lon)
    np.testing.assert_almost_equal(level_m, level_p, decimal=8)

    # The routine should handle an input exposure time sensibly.
    # Our original level_p was in e-/pix/s.  We will define an exposure time, pass it in, and
    # confirm that the output is consistent with this.
    level_p_epix = level_p * galsim.wfirst.exptime
    level_p_epix_2 = galsim.wfirst.getSkyLevel(bp, e_lat=test_lat, e_lon=test_lon,
                                               exp_time=galsim.wfirst.exptime)
    np.testing.assert_almost_equal(level_p_epix, level_p_epix_2, decimal=8)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_wfirst_bandpass():
    """Test the WFIRST bandpasses for basic sanity.
    """
    import time
    t1 = time.time()

    # Obtain the bandpasses with AB_zeropoint set
    exp_time = 200. # non WFIRST exposure time
    bp = galsim.wfirst.getBandpasses(AB_zeropoint=True, exptime=exp_time)

    # Check if the zeropoints have been set correctly
    AB_spec = lambda x: (3631e-23)*exp_time*(np.pi)*(100.**2)*\
              (galsim.wfirst.diameter**2)*(1-galsim.wfirst.obscuration**2)/4.
    AB_sed = galsim.SED(spec=AB_spec,flux_type='fnu')
    for filter_name, filter_ in bp.iteritems():
        mag = AB_sed.calculateMagnitude(bandpass=filter_)
        np.testing.assert_almost_equal(mag,0.0,decimal=6,
            err_msg="Zeropoint not set accurately enough for bandpass filter \
            {0}".format(filter_name))

    # Check if the thinned bandpasses are accurate enough
    bp = galsim.wfirst.getBandpasses(AB_zeropoint=True, thin_err=1.e-4)

    # Read in the file containing the info.
    datafile = os.path.join(galsim.meta_data.share_dir, "afta_throughput.txt")
    # One line with the column headings, and the rest as a NumPy array.
    data = np.loadtxt(datafile, skiprows=1).transpose()
    first_line = open(datafile).readline().rstrip().split()

    # Identify the index of the column containing the wavelength in microns.  Get the wavelength and
    # convert to nm.
    wave_ind = first_line.index('Wave')
    wave = 1000.*data[wave_ind,:]

    # Loop over the bands.
    for index in range(len(first_line)):
        # Need to skip the entry for wavelength.
        if index==wave_ind:
            continue

        filter_name = first_line[index]
        filter_ = bp[filter_name]

        tp = filter_(wave)
        np.testing.assert_almost_equal(tp,data[index,:],decimal=2)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

if __name__ == "__main__":
    test_wfirst_wcs()
    test_wfirst_backgrounds()
    test_wfirst_bandpass()

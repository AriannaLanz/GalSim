# Copyright 2012, 2013 The GalSim developers:
# https://github.com/GalSim-developers
#
# This file is part of GalSim: The modular galaxy image simulation toolkit.
#
# GalSim is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GalSim is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GalSim.  If not, see <http://www.gnu.org/licenses/>
#
import os

import numpy as np

from galsim_test_helpers import *

path, filename = os.path.split(__file__)
datapath = os.path.abspath(os.path.join(path, "../examples/data/"))

try:
    import galsim
except ImportError:
    sys.path.append(os.path.abspath(os.path.join(path, "..")))
    import galsim

# def plotme(image):
#     from pylab import *
#     imshow(image.array)
#     show()

# liberal use of globals here...
zenith_angle = 20 * galsim.degrees
R500 = galsim.dcr.get_refraction(500.0, zenith_angle) # normalize refraction to 610nm

# some profile parameters to test with
bulge_n = 4.0
bulge_hlr = 0.5
bulge_e1 = 0.2
bulge_e2 = 0.2

disk_n = 1.0
disk_hlr = 1.0
disk_e1 = 0.4
disk_e2 = 0.2

PSF_hlr = 0.3
PSF_beta = 3.0
PSF_e1 = 0.01
PSF_e2 = 0.06

shear_g1 = 0.01
shear_g2 = 0.02

# load a filter
filter_wave, filter_throughput = np.genfromtxt(os.path.join(datapath, 'LSST_r.dat')).T
bandpass = galsim.Bandpass(filter_wave, filter_throughput)
bandpass.truncate(relative_throughput=0.01)

# load some spectra
Egal_wave, Egal_flambda = np.genfromtxt(os.path.join(datapath, 'CWW_E_ext.sed')).T
Egal_wave /= 10 # Angstrom -> nm
bulge_SED = galsim.SED(wave=Egal_wave, flambda=Egal_flambda)
bulge_SED.setNormalization(base_wavelength=500.0, normalization=0.3)

Sbcgal_wave, Sbcgal_flambda = np.genfromtxt(os.path.join(datapath, 'CWW_Sbc_ext.sed')).T
Sbcgal_wave /= 10 # Angstrom -> nm
disk_SED = galsim.SED(wave=Sbcgal_wave, flambda=Sbcgal_flambda)
disk_SED.setNormalization(base_wavelength=500.0, normalization=0.3)

def test_draw_add_commutivity():
    """Compare two chromatic images, one generated by adding up GSObject profiles before drawing,
    and one generated (via galsim.chromatic) by drawing image summands wavelength-by-wavelength
    while updating the profile and adding as you go.
    """
    import time
    t1 = time.time()

    stamp_size = 32
    pixel_scale = 0.2

    #------------------------------------------------------------------------------
    # Use galsim.base functions to generate chromaticity by creating an effective
    # PSF by adding together weighted monochromatic PSFs.
    # Profiles are added together before drawing.
    #------------------------------------------------------------------------------

    # make galaxy
    GS_gal = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    GS_gal.applyShear(e1=bulge_e1, e2=bulge_e2)
    GS_gal.applyShear(g1=shear_g1, g2=shear_g2)

    # make effective PSF with Riemann sum midpoint rule
    mPSFs = [] # list of flux-scaled monochromatic PSFs
    N = 150
    h = (bandpass.redlim * 1.0 - bandpass.bluelim) / N
    ws = [bandpass.bluelim + h*(i+0.5) for i in range(N)]
    shift_fn = lambda w:(0, (galsim.dcr.get_refraction(w, zenith_angle) - R500) / galsim.arcsec)
    dilate_fn = lambda w:(w/500.0)**(-0.2)
    for w in ws:
        flux = bulge_SED(w) * bandpass(w) * h
        mPSF = galsim.Moffat(flux=flux, beta=PSF_beta, half_light_radius=PSF_hlr*dilate_fn(w))
        mPSF.applyShear(e1=PSF_e1, e2=PSF_e2)
        mPSF.applyShift(shift_fn(w))
        mPSFs.append(mPSF)
    PSF = galsim.Add(mPSFs)

    # final profile
    pixel = galsim.Pixel(pixel_scale)
    final = galsim.Convolve([GS_gal, PSF, pixel])
    GS_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    GS_image = final.draw(image=GS_image)
    # plotme(GS_image)

    #------------------------------------------------------------------------------
    # Use galsim.chromatic to generate chromaticity.  Internally, this module draws
    # the result at each wavelength and adds the results together.  I.e., drawing
    # and adding happen in the reverse order of the above.
    #------------------------------------------------------------------------------

    # make galaxy
    mono_gal = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    chromatic_gal = galsim.Chromatic(mono_gal, bulge_SED)
    chromatic_gal.applyShear(e1=bulge_e1, e2=bulge_e2)
    chromatic_gal.applyShear(g1=shear_g1, g2=shear_g2)

    # make chromatic PSF
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    mono_PSF.applyShear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticShiftAndDilate(mono_PSF, shift_fn, dilate_fn)

    # final profile
    chromatic_final = galsim.Convolve([chromatic_gal, chromatic_PSF, pixel])
    chromatic_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    # use chromatic parent class to draw without ChromaticConvolution acceleration...
    galsim.ChromaticObject.draw(chromatic_final, bandpass, image=chromatic_image)
    # plotme(chromatic_image)

    # comparison
    analytic_flux = galsim.integ.int1d(lambda w: bulge_SED(w) * bandpass(w),
                                       bandpass.bluelim, bandpass.redlim)
    peak1 = chromatic_image.array.max()

    printval(GS_image, chromatic_image)
    np.testing.assert_array_almost_equal(
        chromatic_image.array/peak1, GS_image.array/peak1, 5,
        err_msg="Directly computed chromatic image disagrees with image created using "
                +"galsim.chromatic")
    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_ChromaticConvolution_InterpolatedImage():
    import time
    t1 = time.time()

    pixel_scale = 0.2
    stamp_size = 32

    # stars are fundamentally delta-fns with an SED
    star = galsim.Chromatic(galsim.Gaussian(fwhm=1e-8), bulge_SED)
    pix = galsim.Pixel(pixel_scale)
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500.0,
                                     zenith_angle = zenith_angle)

    final = galsim.Convolve([star, PSF, pix])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    II_image = galsim.ChromaticConvolution.draw(final, bandpass, image=image)
    II_flux = II_image.array.sum()

    image2 = image.copy()
    D_image = galsim.ChromaticObject.draw(final, bandpass, image=image2)
    D_flux = D_image.array.sum()

    #compare
    np.testing.assert_array_almost_equal(
        II_image.array, D_image.array, 1, #stupid 10% test right now...  Should this be better?
        err_msg="draw not equivalent to draw")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_add():
    """Test the `+` operator on ChromaticObjects"""
    import time
    t1 = time.time()

    stamp_size = 32
    pixel_scale = 0.2

    # create galaxy profiles
    mono_bulge = galsim.Sersic(n=bulge_n, half_light_radius=bulge_hlr)
    bulge = galsim.Chromatic(mono_bulge, bulge_SED)
    bulge.applyShear(e1=bulge_e1, e2=bulge_e2)

    mono_disk = galsim.Sersic(n=disk_n, half_light_radius=disk_hlr)
    disk = galsim.Chromatic(mono_disk, disk_SED)
    disk.applyShear(e1=disk_e1, e2=disk_e2)

    # test `+` operator
    bdgal = bulge + disk
    bdgal.applyShear(g1=shear_g1, g2=shear_g2)

    # create PSF
    shift_fn = lambda w:(0, (galsim.dcr.get_refraction(w, zenith_angle) - R500) / galsim.arcsec)
    dilate_fn = lambda w:(w/500.0)**(-0.2)
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    mono_PSF.applyShear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500.0,
                                               zenith_angle=zenith_angle)

    # create final profile
    pixel = galsim.Pixel(pixel_scale)
    final = galsim.Convolve([bdgal, chromatic_PSF, pixel])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image = final.draw(bandpass, image=image)

    bulge_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    bulge_part = galsim.Convolve([bulge, chromatic_PSF, pixel])
    bulge_image = bulge_part.draw(bandpass, image=bulge_image)
    disk_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    disk_part = galsim.Convolve([disk, chromatic_PSF, pixel])
    disk_image = disk_part.draw(bandpass, image=disk_image)

    piecewise_image = bulge_image + disk_image
    print 'bulge image flux: {}'.format(bulge_image.array.sum())
    print 'disk image flux: {}'.format(disk_image.array.sum())
    print 'piecewise image flux: {}'.format(piecewise_image.array.sum())
    print 'bdimage flux: {}'.format(image.array.sum())
    printval(image, piecewise_image)
    np.testing.assert_array_almost_equal(
            image.array, piecewise_image.array, 6,
            err_msg="`+` operator doesn't match manual image addition")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_dcr_moments():
    """Check that zenith-direction surface brightness distribution first and second moments obey
    expected behavior for differential chromatic refraction when comparing objects drawn with
    different SEDs."""

    import time
    t1 = time.time()

    stamp_size = 256
    pixel_scale = 0.025

    # stars are fundamentally delta-fns with an SED
    star1 = galsim.Chromatic(galsim.Gaussian(fwhm=1e-8), bulge_SED)
    star2 = galsim.Chromatic(galsim.Gaussian(fwhm=1e-8), disk_SED)

    shift_fn = lambda w:(0, ((galsim.dcr.get_refraction(w, zenith_angle) - R500)
                             / galsim.arcsec))
    mono_PSF = galsim.Moffat(beta=PSF_beta, half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticShiftAndDilate(mono_PSF,shift_fn = shift_fn)

    pix = galsim.Pixel(pixel_scale)
    final1 = galsim.Convolve([star1, PSF, pix])
    final2 = galsim.Convolve([star2, PSF, pix])

    image1 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    image1 = final1.draw(bandpass, image=image1)
    image2 = final2.draw(bandpass, image=image2)
    # plotme(image1)

    mom1 = getmoments(image1)
    mom2 = getmoments(image2)
    dR_image = (mom1[1] - mom2[1]) * pixel_scale
    dV_image = (mom1[3] - mom2[3]) * (pixel_scale)**2

    # analytic first moment differences
    R = lambda w:(galsim.dcr.get_refraction(w, zenith_angle) - R500) / galsim.arcsec
    numR1 = galsim.integ.int1d(lambda w: R(w) * bandpass(w) * bulge_SED(w),
                               bandpass.bluelim, bandpass.redlim)
    numR2 = galsim.integ.int1d(lambda w: R(w) * bandpass(w) * disk_SED(w),
                               bandpass.bluelim, bandpass.redlim)
    den1 = galsim.integ.int1d((lambda w:bandpass(w) * bulge_SED(w)),
                              bandpass.bluelim, bandpass.redlim)
    den2 = galsim.integ.int1d((lambda w:bandpass(w) * disk_SED(w)),
                              bandpass.bluelim, bandpass.redlim)

    R1 = numR1/den1
    R2 = numR2/den2
    dR_analytic = R1 - R2

    # analytic second moment differences
    V1_kernel = lambda w:(R(w) - R1)**2
    V2_kernel = lambda w:(R(w) - R2)**2
    numV1 = galsim.integ.int1d(lambda w:V1_kernel(w) * bandpass(w) * bulge_SED(w),
                               bandpass.bluelim, bandpass.redlim)
    numV2 = galsim.integ.int1d(lambda w:V2_kernel(w) * bandpass(w) * disk_SED(w),
                               bandpass.bluelim, bandpass.redlim)
    V1 = numV1/den1
    V2 = numV2/den2
    dV_analytic = V1 - V2

    print 'image delta R:    {}'.format(dR_image)
    print 'analytic delta R: {}'.format(dR_analytic)
    print 'image delta V:    {}'.format(dV_image)
    print 'analytic delta V: {}'.format(dV_analytic)
    np.testing.assert_almost_equal(dR_image, dR_analytic, 5,
                                   err_msg="Moment Shift from DCR doesn't match analytic formula")
    np.testing.assert_almost_equal(dV_image, dV_analytic, 5,
                                   err_msg="Moment Shift from DCR doesn't match analytic formula")


    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_seeing_moments():
    """Check that surface brightness distribution second moments obey expected behavior
    for chromatic seeing when comparing stars drawn with different SEDs."""

    import time
    t1 = time.time()

    pixel_scale = 0.0075
    stamp_size = 1024

    # stars are fundamentally delta-fns with an SED
    star1 = galsim.Chromatic(galsim.Gaussian(fwhm=1e-8), bulge_SED)
    star2 = galsim.Chromatic(galsim.Gaussian(fwhm=1e-8), disk_SED)
    pix = galsim.Pixel(pixel_scale)

    indices = [-0.2, 0.6, 1.0]
    for index in indices:

        mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
        PSF = galsim.ChromaticShiftAndDilate(mono_PSF,
                                             dilate_fn=lambda w:(w/500.0)**index)

        final1 = galsim.Convolve([star1, PSF, pix])
        final2 = galsim.Convolve([star2, PSF, pix])

        image1 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

        image1 = final1.draw(bandpass, image=image1)
        image2 = final2.draw(bandpass, image=image2)

        mom1 = getmoments(image1)
        mom2 = getmoments(image2)
        dr2byr2_image = ((mom1[2]+mom1[3]) - (mom2[2]+mom2[3])) / (mom1[2]+mom1[3])

        # analytic moment differences
        num1 = galsim.integ.int1d(lambda w:(w/500.0)**(2*index) * bandpass(w) * bulge_SED(w),
                                  bandpass.bluelim, bandpass.redlim)
        num2 = galsim.integ.int1d(lambda w:(w/500.0)**(2*index) * bandpass(w) * disk_SED(w),
                                  bandpass.bluelim, bandpass.redlim)
        den1 = galsim.integ.int1d(lambda w:bandpass(w) * bulge_SED(w),
                                  bandpass.bluelim, bandpass.redlim)
        den2 = galsim.integ.int1d(lambda w:bandpass(w) * disk_SED(w),
                                  bandpass.bluelim, bandpass.redlim)

        r2_1 = num1/den1
        r2_2 = num2/den2

        dr2byr2_analytic = (r2_1 - r2_2) / r2_1

        np.testing.assert_almost_equal(dr2byr2_image, dr2byr2_analytic, 4,
                                       err_msg="Moment Shift from chromatic seeing doesn't"+
                                               " match analytic formula")

        print 'image delta(r^2) / r^2:    {}'.format(dr2byr2_image)
        print 'analytic delta(r^2) / r^2: {}'.format(dr2byr2_analytic)

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_monochromatic_filter():
    """Check that ChromaticObject drawn through a very narrow band filter matches analogous
    GSObject.
    """

    import time
    t1 = time.time()

    pixel_scale = 0.2
    stamp_size = 32

    chromatic_gal = galsim.Chromatic(galsim.Gaussian(fwhm=1.0), bulge_SED)
    GS_gal = galsim.Gaussian(fwhm=1.0)

    shift_fn = lambda w:(0, (galsim.dcr.get_refraction(w, zenith_angle) - R500) / galsim.arcsec)
    dilate_fn = lambda wave: (wave/500.0)**(-0.2)
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    mono_PSF.applyShear(e1=PSF_e1, e2=PSF_e2)
    chromatic_PSF = galsim.ChromaticShiftAndDilate(mono_PSF, shift_fn, dilate_fn)

    pix = galsim.Pixel(pixel_scale)
    chromatic_final = galsim.Convolve([chromatic_gal, chromatic_PSF, pix])

    fws = [350, 475, 625, 750, 875, 975] # approximage ugrizy filter central wavelengths
    for fw in fws:
        chromatic_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        narrow_filter = galsim.Bandpass([fw-0.01, fw, fw+0.01], [1.0, 1.0, 1.0])
        chromatic_image = chromatic_final.draw(narrow_filter, image=chromatic_image)
        # take out normalization
        chromatic_image /= 0.02
        chromatic_image /= bulge_SED(fw)

        # now do non-chromatic version
        GS_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
        GS_PSF.applyShear(e1=PSF_e1, e2=PSF_e2)
        GS_PSF.applyDilation(dilate_fn(fw))
        GS_PSF.applyShift(shift_fn(fw))
        GS_final = galsim.Convolve([GS_gal, GS_PSF, pix])
        GS_image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
        GS_final.draw(image=GS_image)
        # plotme(GS_image)

        printval(chromatic_image, GS_image)
        np.testing.assert_array_almost_equal(chromatic_image.array, GS_image.array, 5,
                err_msg="ChromaticObject.draw() with monochromatic filter doesn't match"+
                        "GSObject.draw()")

        getmoments(GS_image)
    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

def test_chromatic_flux():
    import time
    t1 = time.time()

    pixel_scale = 0.5
    stamp_size = 64

    # stars are fundamentally delta-fns with an SED
    star = galsim.Chromatic(galsim.Gaussian(fwhm=1e-8), bulge_SED)
    pix = galsim.Pixel(pixel_scale)
    mono_PSF = galsim.Gaussian(half_light_radius=PSF_hlr)
    PSF = galsim.ChromaticAtmosphere(mono_PSF, base_wavelength=500,
                                     zenith_angle=zenith_angle)

    final = galsim.Convolve([star, PSF, pix])
    image = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)
    image2 = galsim.ImageD(stamp_size, stamp_size, scale=pixel_scale)

    final.draw(bandpass, image=image)
    ChromaticConvolve_flux = image.array.sum()

    galsim.ChromaticObject.draw(final, bandpass, image=image2)
    ChromaticObject_flux = image2.array.sum()

    # analytic integral...
    analytic_flux = galsim.integ.int1d(lambda w: bulge_SED(w) * bandpass(w),
                                       bandpass.bluelim, bandpass.redlim)

    printval(image, image2)
    np.testing.assert_almost_equal(ChromaticObject_flux/analytic_flux, 1.0, 3,
                                   err_msg="Drawn ChromaticObject flux doesn't match " +
                                   "analytic prediction")
    np.testing.assert_almost_equal(ChromaticConvolve_flux/analytic_flux, 1.0, 3,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "analytic prediction")

    # try adjusting flux to something else.
    target_flux = 2.63
    bulge_SED.setFlux(bandpass, target_flux)
    final = galsim.Convolve([star, PSF, pix])
    final.draw(bandpass, image=image)
    np.testing.assert_almost_equal(image.array.sum()/target_flux, 1.0, 3,
                                   err_msg="Drawn ChromaticConvolve flux doesn't match " +
                                   "SED setFlux")

    t2 = time.time()
    print 'time for %s = %.2f'%(funcname(),t2-t1)

if __name__ == "__main__":
    test_draw_add_commutivity()
    test_ChromaticConvolution_InterpolatedImage()
    test_chromatic_add()
    test_dcr_moments()
    test_chromatic_seeing_moments()
    test_monochromatic_filter()
    test_chromatic_flux()

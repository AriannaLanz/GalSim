***The hopefully not-too-crippling dogma of GalSim development***, v0.1

1. Style: 

Use the LSST documents on C++, Python and Documentation overall as a guide for new code,
exert pragmatism with pre-existing code.  Unless you have good reason for hating LSST style,
or the style suggested here, in which case share it!

Biggish things to highlight/add/modify are...
 4 space indentation, rather than 2 space.

 No tabs.  Just spaces.

 No using statements.  Now all namespaces (especially std::) are explicit (equvalent will be
 adopted in Python, i.e. no "import * from moduleX" or "from moduleY import Z").

 Use C++ std library when possible.  e.g. MAX -> std::max, Assert -> assert, PI -> M_PI, etc.

 Will be readable at 100 character width (this is a departure from LSST style, which specifies
 120 but is slightly annoying for laptop use).

 Python 2.7.x will be supported, not Python 3.x...

 We adhere to the Zen of Python; open python, type "import this", hit enter.

 We use all lowercase letters for all Python packages.  That's a bit of a Python convention, 
 and while it's mostly aimed at compatibility with case-insensitive filesystems, we think we 
 should stick with it anyway.

For vim users, Mike Jarvis has put the c.vim file in the devutils/ directory.  If you put that 
in  .vim/ftplugin/ and add the line "filetype plugin on" in your .vimrc file, then you will 
automatically get the formatting to match what is currently in SBProfile.  We don't (yet) 
have a corresponding file for emacs.  (Sorry.)

LSST Style Guides available here --
http://dev.lsstcorp.org/trac/wiki/DocumentationStandards
http://dev.lsstcorp.org/trac/wiki/PythonCodeStandards
http://dev.lsstcorp.org/trac/wiki/C%2B%2BStandard

Broad reasons for choice of LSST style: These documents just seem to be a fairly sensible 
source of code and  documentation formatting guidance.  See also Peter Melchior's slides 
for sound advice in general, and on documentation:
dl.dropbox.com/u/26820102/talks/software_engineering_150410.pdf


2. Version control: 
Git

Broad reasons why: Modern/distributed. Slightly better general purpose/branching capabilities 
than Hg, albeit at the cost of a mildly steeper learning curve.  Neither is rocket science!


3. Repository hosting: 
Github, with push/pull access to all those in the GalSim-developers organization (based on
the great3-code@princeton.edu mailing list).

Broad reasons why: Code review features, wiki features, popularity within GalSim-developers, 
project forking.


4. Documentation: DOxygen
Broad reasons why: Well-supported by many in GalSim-developers.


5. Builds: SCons
Broad reasons why: Seemingly greater experience among GalSim-developers.


6. Libraries: 
FFTW, Numpy, Pyfits, TMV (+BLAS & LAPACK if tuned versions present), Boost.python, 
Boost.shared_ptr, Boost.random (flexibility to other RNGs)

Notes: will add more if really useful/necessary, but want to keep this list as short as 
possible.  Matplotlib plotting  in Python not featured by default.


7. Array/pixel indexing:

Numpy arrays in Python use the (matrix-style) indexing [y, x], whereas the SBProfile class and the
more arguably natural ordering is (x, y).  PyFITS, and a number of other Numpy-dependent Python
libraries have also adopted the [y, x] paradigm, as well as a number of astronomers who do a lot in
Python.

We will write our Python classes to accept arguments in the (x, y) order, particularly the
galsim.Image class.  However, it will be possible to create an Image using a Numpy array, and also
to get a Numpy view into an image.

This places the boundary between our classes and NumPy.  Our classes would be (x,y) in both C++ and
Python, but we wouldn't make any effort to fit NumPy into that paradigm.

Jim gives a couple more reasons on why this is a good place to put the boundary:
- Square brackets will consistently be [y,x], and parentheses will consistently be (x,y), due to 
  the (usually annoying) fact that you can't overload operator[] with two argument in C++.

- Even in Python, [y,x] is really only used for NumPy arrays - note that matplotlib's plot 
  function takes 1-d x and y arrays in that order, for instance, even though matplotlib expects 
  arrays used as images to be [y,x].

Jim gives a nice example of this functionality for what he has in mind for the Python API of the
galsim.Image class:

>>> import galsim
>>> import numpy
>>> arr1 = numpy.arange(6).reshape(2,3)
>>> print arr1
[[0 1 2]
[3 4 5]]
>>> im1 = galsim.ImageD(arr1, x0=10, y0=100)  # im shares data with arr1
>>> arr2 = im1.array
>>> assert(arr2 is arr1)
>>> print im1(12, 101) # (x, y); includes offsets passed in constructor
5
>>> im2 = galsim.ImageD(x0=1, y0=2, w=3, h=4)
>>> arr3 = im2.array   # arr3 shares data with m3
>>> print arr3.shape   # shape is (h, w)
(4, 3)
>>> arr4 = arr1.transpose()    # arr4 is column-major
>>> im3 = galsim.ImageD(arr4)  # can't do this
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: Cannot create image from noncontiguous array.

This last point is important: Numpy arrays must be kept in c_contiguous storage order, i.e. row-
major.  Some of numpy's array routines invisibly change arrays to Fortran-style (i.e. column-major)
storage, or disrupt contiguous storage altogether.  While developing, keep track of this using

>>> array.flags

in particular ensure that

>>> array.flags.c_contiguous == True

Check out the np.copy() function in Numpy, or array.copy() method to see how to make a c_contiguous array, also see np.ascontiguousarray() or the array.transpose() method.

Finally, the FITS standard is to begin indexing all arrays at (1, 1), and this is the convention
SBProfile currently adopts.  However, we think that our image objects will also carry around an
attribute for the coordinate origin, so this should not be too much of a headache at the interface 
with Python/Numpy (famous last words).


8. Compiler warning flags

By default, Mike will set warn=TRUE as the default SCons build setting to output pretty pedantic 
compiler warnings to us developers when building GalSim routines.  This will be switched off again
before we start actively encouraging the public to download the software.  Though some find these
annoying, we'd rather know about any non-standard usage as it might be the kind of thing that causes
portability/stability issues later on.



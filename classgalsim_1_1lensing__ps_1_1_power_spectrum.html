<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>GalSim: galsim.lensing_ps.PowerSpectrum Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GalSim
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">The modular galaxy image simulation toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegalsim.html">galsim</a></li><li class="navelem"><a class="el" href="namespacegalsim_1_1lensing__ps.html">lensing_ps</a></li><li class="navelem"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html">PowerSpectrum</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgalsim_1_1lensing__ps_1_1_power_spectrum-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">galsim.lensing_ps.PowerSpectrum Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to represent a lensing shear field according to some power spectrum P(k)  
 <a href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for galsim.lensing_ps.PowerSpectrum:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgalsim_1_1lensing__ps_1_1_power_spectrum.png" usemap="#galsim.lensing_ps.PowerSpectrum_map" alt=""/>
  <map id="galsim.lensing_ps.PowerSpectrum_map" name="galsim.lensing_ps.PowerSpectrum_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0bf7a88aee4e7f903a5fe8d19ea6cdf0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0bf7a88aee4e7f903a5fe8d19ea6cdf0">__init__</a></td></tr>
<tr class="separator:a0bf7a88aee4e7f903a5fe8d19ea6cdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2009ebd0aaab64683fcd60ba5b0d8069"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a2009ebd0aaab64683fcd60ba5b0d8069">buildGrid</a></td></tr>
<tr class="memdesc:a2009ebd0aaab64683fcd60ba5b0d8069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a realization of the current power spectrum on the specified grid.  <a href="#a2009ebd0aaab64683fcd60ba5b0d8069">More...</a><br/></td></tr>
<tr class="separator:a2009ebd0aaab64683fcd60ba5b0d8069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1354152d2b348a2fbe33bd8367f041"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041">getShear</a></td></tr>
<tr class="memdesc:a0b1354152d2b348a2fbe33bd8367f041"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the shear values for a given list of input positions (or just a single position).  <a href="#a0b1354152d2b348a2fbe33bd8367f041">More...</a><br/></td></tr>
<tr class="separator:a0b1354152d2b348a2fbe33bd8367f041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7ada810e77c7b4d1d6e24272a54661"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8a7ada810e77c7b4d1d6e24272a54661">getConvergence</a></td></tr>
<tr class="memdesc:a8a7ada810e77c7b4d1d6e24272a54661"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the convergence values for a given list of input positions (or just a single position).  <a href="#a8a7ada810e77c7b4d1d6e24272a54661">More...</a><br/></td></tr>
<tr class="separator:a8a7ada810e77c7b4d1d6e24272a54661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97802ce5dd46c3741cb547a9886a5953"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a97802ce5dd46c3741cb547a9886a5953">getMagnification</a></td></tr>
<tr class="memdesc:a97802ce5dd46c3741cb547a9886a5953"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the lensing magnification (mu) values for a given list of input positions (or just a single position).  <a href="#a97802ce5dd46c3741cb547a9886a5953">More...</a><br/></td></tr>
<tr class="separator:a97802ce5dd46c3741cb547a9886a5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd47f97e7402ca28cffc3e6dec8fe27"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#afdd47f97e7402ca28cffc3e6dec8fe27">getLensing</a></td></tr>
<tr class="memdesc:afdd47f97e7402ca28cffc3e6dec8fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can interpolate between grid positions to find the lensing observable quantities (reduced shears g1 and g2, and magnification mu) for a given list of input positions (or just a single position).  <a href="#afdd47f97e7402ca28cffc3e6dec8fe27">More...</a><br/></td></tr>
<tr class="separator:afdd47f97e7402ca28cffc3e6dec8fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0ade197b0cbf8fb086299ffa00dac880"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0ade197b0cbf8fb086299ffa00dac880">e_power_function</a></td></tr>
<tr class="separator:a0ade197b0cbf8fb086299ffa00dac880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1680823e5f523dbd6bd29b14a7a8f75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#aa1680823e5f523dbd6bd29b14a7a8f75">b_power_function</a></td></tr>
<tr class="separator:aa1680823e5f523dbd6bd29b14a7a8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92406265cb8e981948c8008c5f1b56af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a92406265cb8e981948c8008c5f1b56af">delta2</a></td></tr>
<tr class="separator:a92406265cb8e981948c8008c5f1b56af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a214736f544af923f42a17ca5fb1195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a9a214736f544af923f42a17ca5fb1195">scale</a></td></tr>
<tr class="separator:a9a214736f544af923f42a17ca5fb1195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7700448eb709d4abc8f4fc0575fe22d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a7700448eb709d4abc8f4fc0575fe22d6">interpolant</a></td></tr>
<tr class="separator:a7700448eb709d4abc8f4fc0575fe22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bad4165ff17f51b67bb11c170631a29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8bad4165ff17f51b67bb11c170631a29">grid_kappa</a></td></tr>
<tr class="separator:a8bad4165ff17f51b67bb11c170631a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d639842746d63c080f60c26b42276b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#af5d639842746d63c080f60c26b42276b">grid_g1</a></td></tr>
<tr class="separator:af5d639842746d63c080f60c26b42276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932204e8e0d4d1c0874af50d65f1df3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a932204e8e0d4d1c0874af50d65f1df3f">grid_g2</a></td></tr>
<tr class="separator:a932204e8e0d4d1c0874af50d65f1df3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746956592b3f704836aff1fce0edbfcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a746956592b3f704836aff1fce0edbfcd">im_g1</a></td></tr>
<tr class="separator:a746956592b3f704836aff1fce0edbfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1d0edc315b8bf523bd1146d1227aa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#abe1d0edc315b8bf523bd1146d1227aa5">im_g2</a></td></tr>
<tr class="separator:abe1d0edc315b8bf523bd1146d1227aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348c91e43ddb19bde34b944426f6ca83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a348c91e43ddb19bde34b944426f6ca83">im_kappa</a></td></tr>
<tr class="separator:a348c91e43ddb19bde34b944426f6ca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d464f38c5590802722a310b1d12baf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a1d464f38c5590802722a310b1d12baf1">offset</a></td></tr>
<tr class="separator:a1d464f38c5590802722a310b1d12baf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931e6f1a8d4950ffd770fe76d5789ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0931e6f1a8d4950ffd770fe76d5789ca">bounds</a></td></tr>
<tr class="separator:a0931e6f1a8d4950ffd770fe76d5789ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to represent a lensing shear field according to some power spectrum P(k) </p>
<p>A <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> represents some (flat-sky) shear power spectrum, either for gridded points or at arbitary positions. This class is originally initialized with a power spectrum from which we would like to generate g1 and g2 (and, optionally, convergence kappa) values. It generates shears on a grid, and if necessary, when getShear is called, it will interpolate to the requested positions. For detail on how these processes are carried out, please see the document in the GalSim repository, devel/modules/lensing_engine.pdf.</p>
<p>When creating a <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> instance, you need to specify at least one of the E or B mode power spectra, which is normally given as a function P(k). The typical thing is to just use a lambda function in Python (i.e., a function that is not associated with a name); for example, to define P(k)=k^2, one would use <code>lambda k : k**2</code>. But they can also be more complicated user-defined functions that take a single argument k and return the power at that k value, or they can be instances of the LookupTable class for power spectra that are known at particular k values but for which there is not a simple analytic form.</p>
<p>Cosmologists often express the power spectra in terms of an expansion in spherical harmonics (ell), i.e., the C_ell values. In the flat-sky limit, we can replace ell with k and C_ell with P(k). Thus, k and P(k) have dimensions of inverse angle and angle^2, respectively. It is quite common for people to plot ell(ell+1)C_ell/2pi, a dimensionless quantity; the analogous flat-sky quantity is Delta^2 = k^2 P(k)/2pi. By default, the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> object assumes it is getting P(k), but it is possible to instead give it Delta^2 by setting the optional keyword <code>delta2 = True</code> in the constructor.</p>
<p>Also note that we generate the shears according to the input power spectrum using a DFT approach, which means that we implicitly assume our discrete representation of P(k) on a grid is one complete cell in an infinite periodic series. We are making assumptions about what P(k) is doing outside of our minimum and maximum k range, and those must be kept in mind when comparing with theoretical expectations.</p>
<p>Specifically, since the power spectrum is realized on only a finite grid it has been been effectively bandpass filtered between a minimum and maximum k value in each of the k1, k2 directions. This filter is hard: beyond the minimum and maximum k range the P(k) is set to zero. See the buildGrid method for more information.</p>
<p>Therefore, the shear generation currently does not include sample variance due to coverage of a finite patch. We explicitly enforce <code>P(k=0)=0</code>, which is true for the full sky in a reasonable cosmological model, but it ignores the fact that our little patch of sky might reasonably live in some special region with respect to shear correlations. Our <code>P(k=0)=0</code> is essentially setting the integrated power below our minimum k value to zero (i.e., it's implicitly a statement about power in a k range, not just at <code>k=0</code> itself). The implications of the discrete representation, and the <code>P(k=0)=0</code> choice, are discussed in more detail in devel/modules/lensing_engine.pdf.</p>
<p>Therefore, since the power spectrum is realized on a finite grid, it has been been effectively bandpass filtered between a minimum and maximum k value in each of the k1, k2 directions.</p>
<p>The power functions must return a list/array that is the same size as what it was given, e.g., in the case of no power or constant power, a function that just returns a float would not be permitted; it would have to return an array of floats all with the same value.</p>
<p>It is important to note that the power spectra used to initialize the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> object should use the same units for k and P(k), i.e., if k is in inverse radians then P(k) should be in radians^2 (as is natural for outputs from a cosmological shear power spectrum calculator). However, when we actually draw images, there is a natural scale that defines the pitch of the image (dx), which is typically taken to be arcsec. This definition of a specific length scale means that by default we assume all quantities to the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> are in arcsec, and those are the units used for internal calculations, but the <code>units</code> keyword can be used to specify different input units for P(k) (again, within the constraint that k and P(k) must be consistent). If the <code>delta2</code> keyword is set to specify that the input is actually the dimensionless power Delta^2, then the input <code>units</code> are taken to apply only to the k values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e_power_function</td><td>A function or other callable that accepts a Numpy array of |k| values, and returns the E-mode power spectrum P_E(|k|) in an array of the same shape. The function should return the power spectrum desired in the E (gradient) mode of the image. Set to None (default) for there to be no E-mode power. It may also be a string that can be converted to a function using eval('lambda k : ' + e_power_function), a LookupTable, or file_name from which to read in a LookupTable. If a file_name is given, the resulting LookupTable uses the defaults for the LookupTable class, namely spline interpolation in P(k). Users who wish to deviate from those defaults (for example, to interpolate in log(P) and log(k), as might be more natural for power-law functions) should instead read in the file to create a LookupTable using the necessary non-default settings. </td></tr>
    <tr><td class="paramname">b_power_function</td><td>A function or other callable that accepts a Numpy array of |k| values, and returns the B-mode power spectrum P_B(|k|) in an array of the same shape. The function should return the power spectrum desired in the B (curl) mode of the image. Set to None (default) for there to be no B-mode power. It may also be a string that can be converted to a function using eval('lambda k : ' + b_power_function), a LookupTable, or file_name from which to read in a LookupTable. </td></tr>
    <tr><td class="paramname">delta2</td><td>Is the power actually given as dimensionless Delta^2, which requires us to multiply by 2pi / k^2 to get the shear power P(k) in units of angle^2? [default = False] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the power spectrum (i.e. the units of k^-1 and sqrt(P)). This should be either a <a class="el" href="classgalsim_1_1_angle_unit.html" title="A class defining angle units. ">galsim.AngleUnit</a> instance (e.g. <a class="el" href="namespacegalsim.html#aed8d3e3dc27c52616a6006600ec00fea" title="constant with units of radians ">galsim.radians</a>) or a string (e.g. 'radians'). [default = arcsec] </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0bf7a88aee4e7f903a5fe8d19ea6cdf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b_power_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta2</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2009ebd0aaab64683fcd60ba5b0d8069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.buildGrid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_spacing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ngrid</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rng</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolant</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>galsim.PositionD(0,0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_convergence</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmax_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kmin_factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a realization of the current power spectrum on the specified grid. </p>
<p>This function will generate a Gaussian random realization of the specified E and B mode shear power spectra at a grid of positions, specified by the input parameters <code>grid_spacing</code> (distance between grid points) and <code>ngrid</code> (number of grid points in each direction.) Units for <code>grid_spacing</code> and <code>center</code> can be specified using the <code>units</code> keyword; the default is arcsec, which is how all values are stored internally. It automatically computes and stores grids for the shears and convergence. However, since many users are primarily concerned with shape distortion due to shear, the default is to return only the shear components; the <code>get_convergence</code> keyword can be used to also return the convergence.</p>
<p>The quantities that are returned are the theoretical shears and convergences, usually denoted gamma and kappa, respectively. Users who wish to obtain the more observationally-relevant reduced shear and magnification (that describe real lensing distortions) can either use the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a97802ce5dd46c3741cb547a9886a5953" title="This function can interpolate between grid positions to find the lensing magnification (mu) values fo...">getMagnification()</a>, or <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#afdd47f97e7402ca28cffc3e6dec8fe27" title="This function can interpolate between grid positions to find the lensing observable quantities (reduc...">getLensing()</a> methods after buildGrid, or can use a convenience function that is part of <a class="el" href="namespacegalsim_1_1lensing__ps.html">galsim.lensing_ps</a> to convert from theoretical to observed quantities.</p>
<p>Note that the shears generated using this method correspond to the <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> multiplied by a sharp bandpass filter, set by the dimensions of the grid.</p>
<p>The filter sets <code>P(k)</code> = 0 for </p>
<pre class="fragment">|k1|, |k2| &lt; kmin / 2
</pre><p>and |k1|, |k2| &gt; kmax + kmin / 2</p>
<p>where kmin = 2. * pi / (ngrid * grid_spacing) kmax = pi / grid_spacing</p>
<p>and where we have adopted the convention that grid points at a given <code>k</code> represent the interval between <code>k - <a class="el" href="classgalsim_1_1_delta.html" title="Delta-function interpolant in 1d. ">Delta</a> k</code> and <code>k + <a class="el" href="classgalsim_1_1_delta.html" title="Delta-function interpolant in 1d. ">Delta</a> k</code> (noting that the grid spacing <code><a class="el" href="classgalsim_1_1_delta.html" title="Delta-function interpolant in 1d. ">Delta</a> k</code> in k space is equivalent to <code>kmin</code>).</p>
<p>It is worth remembering that this bandpass filter will <em>not</em> look like a circular annulus in 2D k space, but is rather more like a thick-sided picture frame, having a small square central cutout of dimensions <code>kmin</code> by <code>kmin</code>. These properties are visible in the shears generated by this method.</p>
<p>If you care about these effects and want to ameliorate their effect, there are two optional kwargs you can provide: <code>kmin_factor</code> and <code>kmax_factor</code> both of which are 1 by default. These should be integers &gt;= 1 that specify some factor smaller or larger (for kmin and kmax respectively) you want the code to use for the underlying grid in fourier space. The final shear grid is returned using the specified <code>ngrid</code> and <code>grid_spacing</code> parameters. But the intermediate grid in fourier space will be larger by the specified factors.</p>
<p>Note: These are really just for convenience, since you could easily get the same effect by providing different values of ngrid and grid_spacing and then take a subset of them. The <code>kmin_factor</code> and <code>kmax_factor</code> just handle the scalings appropriately for you.</p>
<p>For more information on the effects of finite grid representation of the power spectrum see <code>devel/modules/lensing_engine.pdf</code>.</p>
<p>Note also that the convention for axis orientation differs from that for the GREAT10 challenge, so when using codes that deal with GREAT10 challenge outputs, the sign of our g2 shear component must be flipped.</p>
<p>Some examples:</p>
<ol type="1">
<li><p class="startli">Get shears on a grid of points separated by 1 arcsec: </p>
<pre class="fragment">my_ps = galsim.PowerSpectrum(lambda k : k**2)
g1, g2 = my_ps.buildGrid(grid_spacing = 1., ngrid = 100)
</pre><p class="startli">The returned g1, g2 are 2-d numpy arrays of values, corresponding to the values of g1 and g2 at the locations of the grid points.</p>
<p class="startli">For a given value of grid_spacing and ngrid, we could get the x and y values on the grid using </p>
<pre class="fragment">import numpy as np
min = (-ngrid/2 + 0.5) * grid_spacing
max = (ngrid/2 - 0.5) * grid_spacing
x, y = np.meshgrid(np.arange(min,max+grid_spacing,grid_spacing),
                   np.arange(min,max+grid_spacing,grid_spacing))
</pre><p class="startli">where the center of the grid is taken to be (0,0).</p>
</li>
<li>Rebuild the grid using a particular rng and set the location of the center of the grid to be something other than the default (0,0) <pre class="fragment">g1, g2 = my_ps.buildGrid(grid_spacing = 8., ngrid = 65,
                         rng = galsim.BaseDeviate(1413231),
                         center = (256.5, 256.5) )
</pre></li>
<li>Make a <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html" title="Class to represent a lensing shear field according to some power spectrum P(k) ">PowerSpectrum</a> from a tabulated P(k) that gets interpolated to find the power at all necessary values of k, then generate shears and convergences on a grid, and convert to reduced shear and magnification so they can be used to transform galaxy images. Assuming that k and P_k are either lists, tuples, or 1d Numpy arrays containing k and P(k): <pre class="fragment">tab_pk = galsim.LookupTable(k, P_k)
my_ps = galsim.PowerSpectrum(tab_pk)
g1, g2, kappa = my_ps.buildGrid(grid_spacing = 1., ngrid = 100,
                                get_convergence = True)
g1_r, g2_r, mu = galsim.lensing_ps.theoryToObserved(g1, g2, kappa)
</pre></li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid_spacing</td><td>Spacing for an evenly spaced grid of points, by default in arcsec for consistency with the natural length scale of images created using the draw or drawShoot methods. Other units can be specified using the <code>units</code> keyword. </td></tr>
    <tr><td class="paramname">ngrid</td><td>Number of grid points in each dimension. [Must be an integer] </td></tr>
    <tr><td class="paramname">rng</td><td>(Optional) A <a class="el" href="classgalsim_1_1_gaussian_deviate.html" title="Pseudo-random number generator with Gaussian distribution. ">galsim.GaussianDeviate</a> object for drawing the random numbers. (Alternatively, any <a class="el" href="classgalsim_1_1_base_deviate.html" title="Base class for all the various Deviates. ">BaseDeviate</a> can be used.) [default <code>rng = None</code>] </td></tr>
    <tr><td class="paramname">interpolant</td><td>(Optional) <a class="el" href="classgalsim_1_1_interpolant.html" title="Base class representing one-dimensional interpolant functions. ">Interpolant</a> that will be used for interpolating the gridded shears by methods like <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a0b1354152d2b348a2fbe33bd8367f041" title="This function can interpolate between grid positions to find the shear values for a given list of inp...">getShear()</a>, <a class="el" href="classgalsim_1_1lensing__ps_1_1_power_spectrum.html#a8a7ada810e77c7b4d1d6e24272a54661" title="This function can interpolate between grid positions to find the convergence values for a given list ...">getConvergence()</a>, etc. if they are later called. [default <code>interpolant = <a class="el" href="classgalsim_1_1_linear.html" title="Linear interpolant. ">galsim.Linear()</a></code>] </td></tr>
    <tr><td class="paramname">center</td><td>(Optional) If setting up a new grid, define what position you want to consider the center of that grid. Units must be consistent with those for <code>grid_spacing</code>. [default <code>center = (0,0)</code>] </td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec] </td></tr>
    <tr><td class="paramname">get_convergence</td><td>Return the convergence in addition to the shear? Regardless of the value of <code>get_convergence</code>, the convergence will still be computed and stored for future use. [Default: <code>get_convergence=False</code>] </td></tr>
    <tr><td class="paramname">kmin_factor</td><td>(Optional) Factor by which the grid spacing in fourier space is smaller than the default. i.e. kmin = 2. * pi / (ngrid * grid_spacing) / kmin_factor [default <code>kmin_factor = 1</code>; must be an integer] </td></tr>
    <tr><td class="paramname">kmax_factor</td><td>(Optional) Factor by which the overall grid in fourier space is larger than the default. i.e. kmax = pi / grid_spacing * kmax_factor [default <code>kmax_factor = 1</code>; must be an integer]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g1,g2[,kappa] 2-d NumPy arrays for the shear components g_1, g_2 and (if <code>get_convergence=True</code>) convergence kappa. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a7ada810e77c7b4d1d6e24272a54661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getConvergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the convergence values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call buildGrid first to define the grid of convergences on which to interpolate.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears) modifies the effective power spectrum somewhat. The user is responsible for choosing a grid size that is small enough not to significantly modify the power spectrum on the scales of interest.</p>
<p>The usage of getConvergence is the same as for getShear, except that it returns only a single number rather than a pair of numbers. See documentation for getShear for some examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single galsim.PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of galsim.PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of galsim.PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kappa If given a single position: the convergence kappa. If given a list of positions: a python list of values. If given a NumPy array of positions: a NumPy array of values. </dd></dl>

</div>
</div>
<a class="anchor" id="afdd47f97e7402ca28cffc3e6dec8fe27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getLensing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the lensing observable quantities (reduced shears g1 and g2, and magnification mu) for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call buildGrid first to define the grid of shears and convergences on which to interpolate.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears) modifies the effective power spectrum somewhat. The user is responsible for choosing a grid size that is small enough not to significantly modify the power spectrum on the scales of interest.</p>
<p>The usage of getLensing is the same as for getShear, except that it returns only a single number rather than a pair of numbers. See documentation for getShear for some examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single galsim.PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of galsim.PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of galsim.PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g1,g2,mu If given a single position: the reduced shears g1 and g2, and magnification mu. If given a list of positions: python lists of values. If given a NumPy array of positions: NumPy arrays of values. </dd></dl>

</div>
</div>
<a class="anchor" id="a97802ce5dd46c3741cb547a9886a5953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getMagnification </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the lensing magnification (mu) values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call buildGrid first to define the grid of shears and convergences on which to interpolate.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears) modifies the effective power spectrum somewhat. The user is responsible for choosing a grid size that is small enough not to significantly modify the power spectrum on the scales of interest.</p>
<p>The usage of getMagnification is the same as for getShear, except that it returns only a single number rather than a pair of numbers. See documentation for getShear for some examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single galsim.PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of galsim.PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of galsim.PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mu If given a single position: the magnification, mu. If given a list of positions: a python list of values. If given a NumPy array of positions: a NumPy array of values. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b1354152d2b348a2fbe33bd8367f041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def galsim.lensing_ps.PowerSpectrum.getShear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>units</em> = <code><a class="el" href="namespacegalsim.html#ac3e6f6efd0f7ad138601e798ff3e1790">galsim.arcsec</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reduced</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can interpolate between grid positions to find the shear values for a given list of input positions (or just a single position). </p>
<p>Before calling this function, you must call buildGrid first to define the grid of shears and convergences on which to interpolate. By default, this method returns the reduced shear, which is defined in terms of shear and convergence as reduced shear <code>g=gamma/(1-kappa)</code>; the <code>reduced</code> keyword can be used to return the non-reduced shear.</p>
<p>Note that the interpolation (carried out using the interpolant that was specified when building the gridded shears) modifies the effective power spectrum somewhat. The user is responsible for choosing a grid size that is small enough not to significantly modify the power spectrum on the scales of interest. Detailed tests of this functionality have not been carried out.</p>
<p>Some examples of how to use getShear:</p>
<ol type="1">
<li><p class="startli">Get the shear for a particular point: </p>
<pre class="fragment">g1, g2 = my_ps.getShear(pos = galsim.PositionD(12, 412))
</pre><p class="startli">This time the returned values are just floats and correspond to the shear for the provided position.</p>
</li>
<li>You can also provide a position as a tuple to save the explicit PositionD construction: <pre class="fragment">g1, g2 = my_ps.getShear(pos = (12, 412))
</pre></li>
<li><p class="startli">Get the shears for a bunch of points at once: </p>
<pre class="fragment">xlist = [ 141, 313,  12, 241, 342 ]
ylist = [  75, 199, 306, 225, 489 ]
poslist = [ galsim.PositionD(xlist[i],ylist[i]) for i in range(len(xlist)) ]
g1, g2 = my_ps.getShear( poslist )
g1, g2 = my_ps.getShear( (xlist, ylist) )
</pre><p class="startli">Both calls do the same thing. The returned g1, g2 this time are lists of g1, g2 values. The lists are the same length as the number of input positions.</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position(s) of the source(s), assumed to be post-lensing! Valid ways to input this:<ul>
<li>Single galsim.PositionD (or PositionI) instance</li>
<li>tuple of floats: (x,y)</li>
<li>list of galsim.PositionD (or PositionI) instances</li>
<li>tuple of lists: ( xlist, ylist )</li>
<li>NumPy array of galsim.PositionD (or PositionI) instances</li>
<li>tuple of NumPy arrays: ( xarray, yarray )</li>
<li>Multidimensional NumPy array, as long as array[0] contains x-positions and array[1] contains y-positions </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>The angular units used for the positions. [default = arcsec] </td></tr>
    <tr><td class="paramname">reduced</td><td>Whether returned shear(s) should be reduced shears. [default=True]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>g1,g2 If given a single position: the two shear components g_1 and g_2. If given a list of positions: each is a python list of values. If given a NumPy array of positions: each is a NumPy array. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa1680823e5f523dbd6bd29b14a7a8f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.b_power_function</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0931e6f1a8d4950ffd770fe76d5789ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.bounds</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a92406265cb8e981948c8008c5f1b56af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.delta2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ade197b0cbf8fb086299ffa00dac880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.e_power_function</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af5d639842746d63c080f60c26b42276b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_g1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a932204e8e0d4d1c0874af50d65f1df3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bad4165ff17f51b67bb11c170631a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.grid_kappa</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a746956592b3f704836aff1fce0edbfcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.im_g1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe1d0edc315b8bf523bd1146d1227aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.im_g2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a348c91e43ddb19bde34b944426f6ca83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.im_kappa</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7700448eb709d4abc8f4fc0575fe22d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.interpolant</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d464f38c5590802722a310b1d12baf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.offset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a214736f544af923f42a17ca5fb1195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">galsim.lensing_ps.PowerSpectrum.scale</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>galsim/<a class="el" href="lensing__ps_8py.html">lensing_ps.py</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for GalSim by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5</small></address>
</body>
</html>
